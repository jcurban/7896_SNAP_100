###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             28/May/2013  13:15:19 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\SNAP\SNAP_100\GS1011_Serial_Handlers.c                #
#    Command line =  C:\SNAP\SNAP_100\GS1011_Serial_Handlers.c -e -Oh         #
#                    --code_model small --data_model small -o                 #
#                    C:\SNAP\SNAP_100\Release\Obj\ --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8ssn.h" -D NDEBUG -D STM8S007 -lC      #
#                    C:\SNAP\SNAP_100\Release\List\ -I .\                     #
#                    --no_system_include --vregs 16                           #
#    List file    =  C:\SNAP\SNAP_100\Release\List\GS1011_Serial_Handlers.lst #
#    Object file  =  C:\SNAP\SNAP_100\Release\Obj\GS1011_Serial_Handlers.o    #
#                                                                             #
#                                                                             #
###############################################################################

C:\SNAP\SNAP_100\GS1011_Serial_Handlers.c
      1          /**
      2            ******************************************************************************
      3            * UART 1 is the GS1011 UART
      4            * @file    stm8s_uart1.c
      5            * @author  MCD Application Team
      6            * @version V2.1.0
      7            * @date    18-November-2011
      8            * @brief   This file contains all the functions for the UART1 peripheral.
      9            ******************************************************************************
     10              
     11            ******************************************************************************
     12            *                                                                            *
     13            *  This file contains the Initialization, and ISR routines for the GS1011    *
     14            *     The initialization sets the port to:                                   *
     15            *             9600 baud, 8 bits, no parity, 1 stop                           *
     16            *     The RX ISR gets the resposes from the GS1011                           *
     17            *     The TX ISR sends commands and device updates to the GS1011             *
     18            *                                                                            *
     19            *     The update data is formatted after it comes in from the device.        *
     20            *     The ACK message is sent if the status:good is returned from the GS1011 *
     21            *                                                                            *
     22            *                                                                            *
     23            *****************************************************************************/
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "stm8s_uart1.h"
     27          
     28          /* definitions ---------------------------------------------------------------*/
     29          void GS1011_Received_Data_Handler(void);
     30          void Sending_GS1011_Data_Handler(void);
     31          void Start_GS1011_Send(void);
     32          void GetNetworkStatusFromGS1011 (void);
     33          void SetupGS1011Association(void);
     34          void SendUpdateToWebsite (void);
     35          void GetResponseFromGS1011(void);
     36          
     37          /* external definitions ---------------------------------------------------------------*/
     38          extern unsigned char GS1011_Xmit_Char;
     39          extern unsigned char GS1011_Xmit_Char_Count;
     40          extern char* GS1011_Xmit_Pointer;
     41          
     42          extern void strcpy(char *s1, char *s2);
     43          extern void Start_GS1011_Send(void);
     44          extern char* GS1011_Xmit_Pointer;
     45          extern char GS1011_Xmit_Buffer;
     46          extern char GetNSTATMessage;
     47          extern unsigned char GS1011_Xmit_Char_Count;
     48          
     49          
     50          #define CR 0x0D
     51          #define LF 0x0A
     52          
     53          
     54          /** @addtogroup STM8S_StdPeriph_Driver
     55            * @{
     56            */
     57          /* Private typedef -----------------------------------------------------------*/
     58          /* Private define ------------------------------------------------------------*/
     59          /* Private macro -------------------------------------------------------------*/
     60          /* Private variables ---------------------------------------------------------*/
     61          /* Private function prototypes -----------------------------------------------*/
     62          /* Private functions ---------------------------------------------------------*/
     63          /* Public functions ----------------------------------------------------------*/
     64          
     65          /** @}
     66            * @addtogroup UART1_Public_Functions
     67            * @{
     68            */
     69          
     70          /*****************************************************************************/
     71          /*****************************************************************************/
     72          /****                       normal routines                                ***/
     73          /*****************************************************************************/
     74          /*****************************************************************************/

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 35 01 ....   MOV       S:GS1011_Xmit_Char_Count, #0x1
   \   000007 A6 ..        LD        A, #GS1011_Xmit_Buffer
   \   000009 5F           CLRW      X
   \   00000A 97           LD        XL, A
   \   00000B BF ..        LDW       S:?w4, X
   \   00000D A6 ..        LD        A, #GetNSTATMessage
   \   00000F 905F         CLRW      Y
   \   000011 9097         LD        YL, A
   \   000013 CD ....      CALL      L:strcpy
   \   000016 92C6 ..      LD        A, [S:?w4.w]
   \   000019 B7 ..        LD        S:GS1011_Xmit_Char, A
   \   00001B BE ..        LDW       X, S:?w4
   \   00001D CD ....      CALL      L:?Subroutine3
   \                     ??CrossCallReturnLabel_25:
   \   000020 CC ....      JP        L:?epilogue_w4

   \                                 In section .near_func.text, align 1
     75          void GetNetworkStatusFromGS1011 (){
   \                     GetNetworkStatusFromGS1011:
   \   000000 20 ..        JRA       L:?Subroutine0
     76            GS1011_Xmit_Char_Count = sizeof(GetNSTATMessage);   /* size of message */
     77            strcpy(&GS1011_Xmit_Buffer, &GetNSTATMessage);      /* copy from stock to buffer*/
     78            GS1011_Xmit_Pointer = &GS1011_Xmit_Buffer;          /* save the start of the buffer*/
     79            Start_GS1011_Send();                                /* kickstart the xmitter*/
     80          }

   \                                 In section .near_func.text, align 1, keep-with-next
     81          void SetupGS1011Association(){
   \                     SetupGS1011Association:
   \   000000 20 ..        JRA       L:?Subroutine0
     82            GS1011_Xmit_Char_Count = sizeof(GetNSTATMessage);   /* size of message */
     83            strcpy(&GS1011_Xmit_Buffer, &GetNSTATMessage);      /* copy from stock to buffer*/
     84            GS1011_Xmit_Pointer = &GS1011_Xmit_Buffer;          /* save the start of the buffer*/
     85            Start_GS1011_Send();                                /* kickstart the xmitter*/
     86          }

   \                                 In section .near_func.text, align 1, keep-with-next
     87          void SendUpdateToWebsite (){
   \                     SendUpdateToWebsite:
   \   000000              REQUIRE ?Subroutine0
   \   000000              ;               // Fall through to label ?Subroutine0
     88            GS1011_Xmit_Char_Count = sizeof(GetNSTATMessage);   /* size of message */
     89            strcpy(&GS1011_Xmit_Buffer, &GetNSTATMessage);      /* copy from stock to buffer*/
     90            GS1011_Xmit_Pointer = &GS1011_Xmit_Buffer;          /* save the start of the buffer*/
     91            Start_GS1011_Send();                                /* kickstart the xmitter*/
     92          }

   \                                 In section .near_func.text, align 1
     93          void GetResponseFromGS1011(){
     94          }
   \                     GetResponseFromGS1011:
   \   000000 81           RET
     95          
     96          /*****************************************************************************/
     97          /*****************************************************************************/
     98          /****                        ISR routines                                  ***/
     99          /*****************************************************************************/
    100          /*****************************************************************************/
    101            /*****************************************************************************
    102            *   Handle_GS1011_Received_Data                                              *
    103            *                                                                            *
    104            *   Get a character from the data register.                                  *
    105            *         Set a timer for x seconds(timer value is dependent upon command.   *
    106            *                                                                            *
    107            *   If the timer expires check if the response matches the command.          *
    108            *                                                                            *
    109            *   If the command was an update, and the response was status:good then      *
    110            *             Send the stock ACK message to the device                       *
    111            *                                                                            *
    112            *****************************************************************************/

   \                                 In section .near_func.text, align 1
    113          void GS1011_Received_Data_Handler(){
    114          }
   \                     GS1011_Received_Data_Handler:
   \   000000 81           RET
    115          
    116           /******************************************************************************
    117            *   Start_GS1011_Send                                                        *
    118            *                                                                            *
    119            *   This routine is passed a pointer to a buffer to send to the GS1011       *
    120            *                                                                            *
    121            *   Gets the first character and sets the buffer count and pointer.          *
    122            *   It sends the first character then the interupts take over.               *
    123            *                                                                            *
    124            *****************************************************************************/

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000 CD ....      CALL      L:?Subroutine8
   \                     ??CrossCallReturnLabel_38:
   \   000003 B6 ..        LD        A, S:GS1011_Xmit_Char
   \   000005 C7 5231      LD        L:0x5231, A
   \   000008 7216 5235    BSET      L:0x5235, #0x3
   \   00000C 81           RET

   \                                 In section .near_func.text, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000 5C           INCW      X
   \   000001 BF ..        LDW       S:GS1011_Xmit_Pointer, X
   \   000003 B6 ..        LD        A, S:GS1011_Xmit_Char_Count
   \   000005 4A           DEC       A
   \   000006 B7 ..        LD        S:GS1011_Xmit_Char_Count, A
   \   000008 81           RET

   \                                 In section .near_func.text, align 1
    125          void Start_GS1011_Send(){
    126             GS1011_Xmit_Char = *GS1011_Xmit_Pointer;
   \                     Start_GS1011_Send:
   \   000000 92C6 ..      LD        A, [S:GS1011_Xmit_Pointer.w]
   \   000003 B7 ..        LD        S:GS1011_Xmit_Char, A
    127            GS1011_Xmit_Pointer++;
   \   000005 BE ..        LDW       X, S:GS1011_Xmit_Pointer
   \   000007 CD ....      CALL      L:?Subroutine3
    128            GS1011_Xmit_Char_Count--;
    129            UART1->DR = GS1011_Xmit_Char;
    130            UART1->CR2 |= (uint8_t)UART1_CR2_TEN;
    131          }
   \                     ??CrossCallReturnLabel_24:
   \   00000A 81           RET
    132            /*****************************************************************************
    133            *   Handle_Sending_GS1011_Data                                               *
    134            *                                                                            *
    135            *   Send a character to the data register.                                   *
    136            *         Continue till count = 00                                           *
    137            *                                                                            *
    138            *****************************************************************************/

   \                                 In section .near_func.text, align 1
    139          void Sending_GS1011_Data_Handler(){
    140            if (GS1011_Xmit_Char_Count != 0){
   \                     Sending_GS1011_Data_Handler:
   \   000000 3D ..        TNZ       S:GS1011_Xmit_Char_Count
   \   000002 27 0E        JREQ      L:??Sending_GS1011_Data_Handler_0
    141                GS1011_Xmit_Char = *GS1011_Xmit_Pointer;
   \   000004 92C6 ..      LD        A, [S:GS1011_Xmit_Pointer.w]
   \   000007 B7 ..        LD        S:GS1011_Xmit_Char, A
    142                UART1->DR= GS1011_Xmit_Char;
   \   000009 C7 5231      LD        L:0x5231, A
    143                GS1011_Xmit_Pointer++;
   \   00000C BE ..        LDW       X, S:GS1011_Xmit_Pointer
   \   00000E CD ....      CALL      L:?Subroutine8
    144                GS1011_Xmit_Char_Count--;}
   \                     ??CrossCallReturnLabel_37:
   \   000011 81           RET
    145            else UART1->CR2 &= (uint8_t)~(UART1_CR2_TEN);     
   \                     ??Sending_GS1011_Data_Handler_0:
   \   000012 7217 5235    BRES      L:0x5235, #0x3
    146          }
   \   000016 81           RET
    147          
    148          
    149          /**
    150            * @brief  Deinitializes the UART peripheral.
    151            * @param  None
    152            * @retval None
    153          */

   \                                 In section .near_func.text, align 1
    154          void UART1_DeInit(void)
    155          {
    156              /* Clear the Idle Line Detected bit in the status rerister by a read
    157                 to the UART1_SR register followed by a Read to the UART1_DR register */
    158              (void)UART1->SR;
   \                     UART1_DeInit:
   \   000000 C6 5230      LD        A, L:0x5230
    159              (void)UART1->DR;
   \   000003 C6 5231      LD        A, L:0x5231
    160          
    161              UART1->BRR2 = UART1_BRR2_RESET_VALUE;  /* Set UART1_BRR2 to reset value 0x00 */
   \   000006 725F 5233    CLR       L:0x5233
    162              UART1->BRR1 = UART1_BRR1_RESET_VALUE;  /* Set UART1_BRR1 to reset value 0x00 */
   \   00000A 725F 5232    CLR       L:0x5232
    163          
    164              UART1->CR1 = UART1_CR1_RESET_VALUE;  /* Set UART1_CR1 to reset value 0x00 */
   \   00000E 725F 5234    CLR       L:0x5234
    165              UART1->CR2 = UART1_CR2_RESET_VALUE;  /* Set UART1_CR2 to reset value 0x00 */
   \   000012 725F 5235    CLR       L:0x5235
    166              UART1->CR3 = UART1_CR3_RESET_VALUE;  /* Set UART1_CR3 to reset value 0x00 */
   \   000016 725F 5236    CLR       L:0x5236
    167              UART1->CR4 = UART1_CR4_RESET_VALUE;  /* Set UART1_CR4 to reset value 0x00 */
   \   00001A 725F 5237    CLR       L:0x5237
    168              UART1->CR5 = UART1_CR5_RESET_VALUE;  /* Set UART1_CR5 to reset value 0x00 */
   \   00001E 725F 5238    CLR       L:0x5238
    169          
    170              UART1->GTR = UART1_GTR_RESET_VALUE;
   \   000022 725F 5239    CLR       L:0x5239
    171              UART1->PSCR = UART1_PSCR_RESET_VALUE;
   \   000026 725F 523A    CLR       L:0x523a
    172          }
   \   00002A 81           RET
    173          
    174          /**
    175            * @brief  Initializes the UART1 according to the specified parameters.
    176            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
    177            *         correct I/O Port register according the product package and line
    178            *         configuration
    179            * @param  BaudRate: The baudrate.
    180            * @param  WordLength : This parameter can be any of the 
    181            *         @ref UART1_WordLength_TypeDef enumeration.
    182            * @param  StopBits: This parameter can be any of the 
    183            *         @ref UART1_StopBits_TypeDef enumeration.
    184            * @param  Parity: This parameter can be any of the 
    185            *         @ref UART1_Parity_TypeDef enumeration.
    186            * @param  SyncMode: This parameter can be any of the 
    187            *         @ref UART1_SyncMode_TypeDef values.
    188            * @param  Mode: This parameter can be any of the @ref UART1_Mode_TypeDef values
    189            * @retval None
    190            */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine4:
   \   000000 CA 5234      OR        A, L:0x5234
   \   000003 C7 5234      LD        L:0x5234, A
   \   000006 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine1:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 AE ....      LDW       X, #`?<Constant "C:\\\\SNAP\\\\SNAP_100\\\\GS10...">`
   \   000008 CC ....      JP        L:assert_failed

   \                                 In section .near_func.text, align 1
    191          void UART1_Init(uint32_t BaudRate, UART1_WordLength_TypeDef WordLength, 
    192                          UART1_StopBits_TypeDef StopBits, UART1_Parity_TypeDef Parity, 
    193                          UART1_SyncMode_TypeDef SyncMode, UART1_Mode_TypeDef Mode)
    194          {
   \                     UART1_Init:
   \   000000 CD ....      CALL      L:?push_l2
   \   000003 CD ....      CALL      L:?push_l3
   \   000006 3B ....      PUSH      S:?b6
   \   000009 3B ....      PUSH      S:?b7
   \   00000C CD ....      CALL      L:?mov_l2_l0
   \   00000F B7 ..        LD        S:?b14, A
   \   000011 45 .. ..     MOV       S:?b12, S:?b4
   \   000014 45 .. ..     MOV       S:?b13, S:?b5
    195              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
    196          
    197              /* Check the parameters */
    198              assert_param(IS_UART1_BAUDRATE_OK(BaudRate));
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 A3 0009      CPW       X, #0x9
   \   00001C 26 05        JRNE      L:??UART1_Init_0
   \   00001E BE ..        LDW       X, S:?w5
   \   000020 A3 8969      CPW       X, #0x8969
   \                     ??UART1_Init_0:
   \   000023 25 06        JRC       L:??CrossCallReturnLabel_5
   \   000025 AE 00C6      LDW       X, #0xc6
   \   000028 CD ....      CALL      L:?Subroutine1
    199              assert_param(IS_UART1_WORDLENGTH_OK(WordLength));
   \                     ??CrossCallReturnLabel_5:
   \   00002B 3D ..        TNZ       S:?b14
   \   00002D 27 0C        JREQ      L:??CrossCallReturnLabel_4
   \   00002F B6 ..        LD        A, S:?b14
   \   000031 A1 10        CP        A, #0x10
   \   000033 27 06        JREQ      L:??CrossCallReturnLabel_4
   \   000035 AE 00C7      LDW       X, #0xc7
   \   000038 CD ....      CALL      L:?Subroutine1
    200              assert_param(IS_UART1_STOPBITS_OK(StopBits));
   \                     ??CrossCallReturnLabel_4:
   \   00003B 3D ..        TNZ       S:?b12
   \   00003D 27 14        JREQ      L:??CrossCallReturnLabel_3
   \   00003F B6 ..        LD        A, S:?b12
   \   000041 A1 10        CP        A, #0x10
   \   000043 27 0E        JREQ      L:??CrossCallReturnLabel_3
   \   000045 A1 20        CP        A, #0x20
   \   000047 27 0A        JREQ      L:??CrossCallReturnLabel_3
   \   000049 A1 30        CP        A, #0x30
   \   00004B 27 06        JREQ      L:??CrossCallReturnLabel_3
   \   00004D AE 00C8      LDW       X, #0xc8
   \   000050 CD ....      CALL      L:?Subroutine1
    201              assert_param(IS_UART1_PARITY_OK(Parity));
   \                     ??CrossCallReturnLabel_3:
   \   000053 3D ..        TNZ       S:?b13
   \   000055 27 10        JREQ      L:??CrossCallReturnLabel_2
   \   000057 B6 ..        LD        A, S:?b13
   \   000059 A1 04        CP        A, #0x4
   \   00005B 27 0A        JREQ      L:??CrossCallReturnLabel_2
   \   00005D A1 06        CP        A, #0x6
   \   00005F 27 06        JREQ      L:??CrossCallReturnLabel_2
   \   000061 AE 00C9      LDW       X, #0xc9
   \   000064 CD ....      CALL      L:?Subroutine1
    202              assert_param(IS_UART1_MODE_OK((uint8_t)Mode));
   \                     ??CrossCallReturnLabel_2:
   \   000067 7B 01        LD        A, (0x1,SP)
   \   000069 A1 08        CP        A, #0x8
   \   00006B 27 22        JREQ      L:??CrossCallReturnLabel_1
   \   00006D A1 40        CP        A, #0x40
   \   00006F 27 1E        JREQ      L:??CrossCallReturnLabel_1
   \   000071 A1 04        CP        A, #0x4
   \   000073 27 1A        JREQ      L:??CrossCallReturnLabel_1
   \   000075 A1 80        CP        A, #0x80
   \   000077 27 16        JREQ      L:??CrossCallReturnLabel_1
   \   000079 A1 0C        CP        A, #0xc
   \   00007B 27 12        JREQ      L:??CrossCallReturnLabel_1
   \   00007D A1 44        CP        A, #0x44
   \   00007F 27 0E        JREQ      L:??CrossCallReturnLabel_1
   \   000081 A1 C0        CP        A, #0xc0
   \   000083 27 0A        JREQ      L:??CrossCallReturnLabel_1
   \   000085 A1 88        CP        A, #0x88
   \   000087 27 06        JREQ      L:??CrossCallReturnLabel_1
   \   000089 AE 00CA      LDW       X, #0xca
   \   00008C CD ....      CALL      L:?Subroutine1
    203              assert_param(IS_UART1_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??CrossCallReturnLabel_1:
   \   00008F 7B 02        LD        A, (0x2,SP)
   \   000091 A4 88        AND       A, #0x88
   \   000093 A1 88        CP        A, #0x88
   \   000095 27 18        JREQ      L:??UART1_Init_1
   \   000097 7B 02        LD        A, (0x2,SP)
   \   000099 A4 44        AND       A, #0x44
   \   00009B A1 44        CP        A, #0x44
   \   00009D 27 10        JREQ      L:??UART1_Init_1
   \   00009F 7B 02        LD        A, (0x2,SP)
   \   0000A1 A4 22        AND       A, #0x22
   \   0000A3 A1 22        CP        A, #0x22
   \   0000A5 27 08        JREQ      L:??UART1_Init_1
   \   0000A7 7B 02        LD        A, (0x2,SP)
   \   0000A9 A4 11        AND       A, #0x11
   \   0000AB A1 11        CP        A, #0x11
   \   0000AD 26 06        JRNE      L:??CrossCallReturnLabel_0
   \                     ??UART1_Init_1:
   \   0000AF AE 00CB      LDW       X, #0xcb
   \   0000B2 CD ....      CALL      L:?Subroutine1
    204          
    205              /* Clear the word length bit */
    206              UART1->CR1 &= (uint8_t)(~UART1_CR1_M);  
   \                     ??CrossCallReturnLabel_0:
   \   0000B5 7219 5234    BRES      L:0x5234, #0x4
    207              
    208               /* Set the word length bit according to UART1_WordLength value */
    209              UART1->CR1 |= (uint8_t)WordLength;
   \   0000B9 B6 ..        LD        A, S:?b14
   \   0000BB CD ....      CALL      L:?Subroutine4
    210          
    211              /* Clear the STOP bits */
    212              UART1->CR3 &= (uint8_t)(~UART1_CR3_STOP);  
   \                     ??CrossCallReturnLabel_28:
   \   0000BE C6 5236      LD        A, L:0x5236
   \   0000C1 A4 CF        AND       A, #0xcf
   \   0000C3 C7 5236      LD        L:0x5236, A
    213              /* Set the STOP bits number according to UART1_StopBits value  */
    214              UART1->CR3 |= (uint8_t)StopBits;  
   \   0000C6 B6 ..        LD        A, S:?b12
   \   0000C8 CD ....      CALL      L:?Subroutine5
    215          
    216              /* Clear the Parity Control bit */
    217              UART1->CR1 &= (uint8_t)(~(UART1_CR1_PCEN | UART1_CR1_PS  ));  
   \                     ??CrossCallReturnLabel_30:
   \   0000CB C6 5234      LD        A, L:0x5234
   \   0000CE A4 F9        AND       A, #0xf9
   \   0000D0 C7 5234      LD        L:0x5234, A
    218              /* Set the Parity Control bit to UART1_Parity value */
    219              UART1->CR1 |= (uint8_t)Parity;  
   \   0000D3 B6 ..        LD        A, S:?b13
   \   0000D5 CD ....      CALL      L:?Subroutine4
    220          
    221              /* Clear the LSB mantissa of UART1DIV  */
    222              UART1->BRR1 &= (uint8_t)(~UART1_BRR1_DIVM);  
   \                     ??CrossCallReturnLabel_29:
   \   0000D8 C6 5232      LD        A, L:0x5232
   \   0000DB 725F 5232    CLR       L:0x5232
    223              /* Clear the MSB mantissa of UART1DIV  */
    224              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVM);  
   \   0000DF C6 5233      LD        A, L:0x5233
   \   0000E2 A4 0F        AND       A, #0xf
   \   0000E4 C7 5233      LD        L:0x5233, A
    225              /* Clear the Fraction bits of UART1DIV */
    226              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVF);  
   \   0000E7 C6 5233      LD        A, L:0x5233
   \   0000EA A4 F0        AND       A, #0xf0
   \   0000EC C7 5233      LD        L:0x5233, A
    227          
    228              /* Set the UART1 BaudRates in BRR1 and BRR2 registers according to UART1_BaudRate value */
    229              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   0000EF CD ....      CALL      L:?mov_l0_l2
   \   0000F2 CD ....      CALL      L:?sll32_l0_l0_db
   \   0000F5 04           DC8       0x4
   \   0000F6 CD ....      CALL      L:?mov_l2_l0
   \   0000F9 CD ....      CALL      L:CLK_GetClockFreq
   \   0000FC CD ....      CALL      L:?mov_l1_l2
   \   0000FF CD ....      CALL      L:?udiv32_l0_l0_l1
   \   000102 CD ....      CALL      L:?mov_l3_l0
    230              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
    231              /* Set the fraction of UART1DIV  */
    232              UART1->BRR2 |= (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100)) << 4) / 100) & (uint8_t)0x0F); 
   \   000105 CD ....      CALL      L:?Subroutine6
   \                     ??CrossCallReturnLabel_33:
   \   000108 CD ....      CALL      L:?push_l0
   \   00010B CD ....      CALL      L:CLK_GetClockFreq
   \   00010E CD ....      CALL      L:?Subroutine6
   \                     ??CrossCallReturnLabel_34:
   \   000111 CD ....      CALL      L:?mov_l1_l2
   \   000114 CD ....      CALL      L:?udiv32_l0_l0_l1
   \   000117 CD ....      CALL      L:?pop_l1
   \   00011A CD ....      CALL      L:?sub32_l0_l0_l1
   \   00011D CD ....      CALL      L:?sll32_l0_l0_db
   \   000120 04           DC8       0x4
   \   000121 CD ....      CALL      L:?udiv32_l0_l0_dl
   \   000124 00000064     DC32      0x64
   \   000128 B6 ..        LD        A, S:?b3
   \   00012A A4 0F        AND       A, #0xf
   \   00012C CA 5233      OR        A, L:0x5233
   \   00012F C7 5233      LD        L:0x5233, A
    233              /* Set the MSB mantissa of UART1DIV  */
    234              UART1->BRR2 |= (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0); 
   \   000132 BE ..        LDW       X, S:?w7
   \   000134 CD ....      CALL      L:?srl16_x_x_4
   \   000137 9F           LD        A, XL
   \   000138 A4 F0        AND       A, #0xf0
   \   00013A CA 5233      OR        A, L:0x5233
   \   00013D C7 5233      LD        L:0x5233, A
    235              /* Set the LSB mantissa of UART1DIV  */
    236              UART1->BRR1 |= (uint8_t)BaudRate_Mantissa;           
   \   000140 B6 ..        LD        A, S:?b15
   \   000142 CA 5232      OR        A, L:0x5232
   \   000145 C7 5232      LD        L:0x5232, A
    237          
    238              /* Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */
    239              UART1->CR2 &= (uint8_t)~(UART1_CR2_TEN | UART1_CR2_REN); 
   \   000148 C6 5235      LD        A, L:0x5235
   \   00014B A4 F3        AND       A, #0xf3
   \   00014D C7 5235      LD        L:0x5235, A
    240              /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    241              UART1->CR3 &= (uint8_t)~(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL); 
   \   000150 C6 5236      LD        A, L:0x5236
   \   000153 A4 F8        AND       A, #0xf8
   \   000155 C7 5236      LD        L:0x5236, A
    242              /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    243              UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART1_CR3_CPOL | 
    244                                                        UART1_CR3_CPHA | UART1_CR3_LBCL));  
   \   000158 7B 02        LD        A, (0x2,SP)
   \   00015A A4 07        AND       A, #0x7
   \   00015C CD ....      CALL      L:?Subroutine5
    245          
    246              if ((uint8_t)(Mode & UART1_MODE_TX_ENABLE))
   \                     ??CrossCallReturnLabel_31:
   \   00015F 7B 01        LD        A, (0x1,SP)
   \   000161 A5 04        BCP       A, #0x4
   \   000163 27 06        JREQ      L:??UART1_Init_2
    247              {
    248                  /* Set the Transmitter Enable bit */
    249                  UART1->CR2 |= (uint8_t)UART1_CR2_TEN;  
   \   000165 7216 5235    BSET      L:0x5235, #0x3
   \   000169 20 04        JRA       L:??UART1_Init_3
    250              }
    251              else
    252              {
    253                  /* Clear the Transmitter Disable bit */
    254                  UART1->CR2 &= (uint8_t)(~UART1_CR2_TEN);  
   \                     ??UART1_Init_2:
   \   00016B 7217 5235    BRES      L:0x5235, #0x3
    255              }
    256              if ((uint8_t)(Mode & UART1_MODE_RX_ENABLE))
   \                     ??UART1_Init_3:
   \   00016F 7B 01        LD        A, (0x1,SP)
   \   000171 A5 08        BCP       A, #0x8
   \   000173 27 06        JREQ      L:??UART1_Init_4
    257              {
    258                  /* Set the Receiver Enable bit */
    259                  UART1->CR2 |= (uint8_t)UART1_CR2_REN;  
   \   000175 7214 5235    BSET      L:0x5235, #0x2
   \   000179 20 04        JRA       L:??UART1_Init_5
    260              }
    261              else
    262              {
    263                  /* Clear the Receiver Disable bit */
    264                  UART1->CR2 &= (uint8_t)(~UART1_CR2_REN);  
   \                     ??UART1_Init_4:
   \   00017B 7215 5235    BRES      L:0x5235, #0x2
    265              }
    266              /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    267                     pulse bits according to UART1_Mode value */
    268              if ((uint8_t)(SyncMode & UART1_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART1_Init_5:
   \   00017F 7B 02        LD        A, (0x2,SP)
   \   000181 A5 80        BCP       A, #0x80
   \   000183 27 06        JREQ      L:??UART1_Init_6
    269              {
    270                  /* Clear the Clock Enable bit */
    271                  UART1->CR3 &= (uint8_t)(~UART1_CR3_CKEN); 
   \   000185 7217 5236    BRES      L:0x5236, #0x3
   \   000189 20 07        JRA       L:??CrossCallReturnLabel_32
    272              }
    273              else
    274              {
    275                  UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & UART1_CR3_CKEN);
   \                     ??UART1_Init_6:
   \   00018B 7B 02        LD        A, (0x2,SP)
   \   00018D A4 08        AND       A, #0x8
   \   00018F CD ....      CALL      L:?Subroutine5
    276              }
    277          }
   \                     ??CrossCallReturnLabel_32:
   \   000192 5B 02        ADD       SP, #0x2
   \   000194 CC ....      JP        L:?epilogue_l2_l3

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine6:
   \   000000 CD ....      CALL      L:?mul32_l0_l0_dl
   \   000003 00000064     DC32      0x64
   \   000007 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine5:
   \   000000 CA 5236      OR        A, L:0x5236
   \   000003 C7 5236      LD        L:0x5236, A
   \   000006 81           RET
    278          
    279          /**
    280            * @brief  Enable the UART1 peripheral.
    281            * @param  NewState : The new state of the UART Communication.
    282            *         This parameter can be any of the @ref FunctionalState enumeration.
    283            * @retval None
    284            */

   \                                 In section .near_func.text, align 1
    285          void UART1_Cmd(FunctionalState NewState)
    286          {
    287              if (NewState != DISABLE)
   \                     UART1_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??UART1_Cmd_0
    288              {
    289                  /* UART1 Enable */
    290                  UART1->CR1 &= (uint8_t)(~UART1_CR1_UARTD); 
   \   000003 721B 5234    BRES      L:0x5234, #0x5
   \   000007 81           RET
    291              }
    292              else
    293              {
    294                  /* UART Disable */
    295                  UART1->CR1 |= UART1_CR1_UARTD;  
   \                     ??UART1_Cmd_0:
   \   000008 721A 5234    BSET      L:0x5234, #0x5
    296              }
    297          }
   \   00000C 81           RET
    298          
    299          /**
    300            * @brief  Enables or disables the specified USART interrupts.
    301            * @param  UART1_IT specifies the USART interrupt sources to be enabled or disabled.
    302            *         This parameter can be one of the following values:
    303            *         - UART1_IT_TXE:  Tansmit Data Register empty interrupt
    304            *         - UART1_IT_TC:   Transmission complete interrupt
    305            *         - UART1_IT_RXNE: Receive Data register not empty interrupt
    306            *         - UART1_IT_OR: Overrun error interrupt
    307            *         - UART1_IT_IDLE: Idle line detection interrupt
    308            *         - USRT1_IT_ERR:  Error interrupt
    309            * @param  NewState new state of the specified USART interrupts.
    310            *         This parameter can be: ENABLE or DISABLE.
    311            * @retval None
    312            */

   \                                 In section .near_func.text, align 1
    313          void UART1_ITConfig(UART1_IT_TypeDef UART1_IT, FunctionalState NewState)
    314          {
   \                     UART1_ITConfig:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
   \   000008 B7 ..        LD        S:?b10, A
    315              uint8_t uartreg = 0, itpos = 0x00;
    316              
    317              /* Check the parameters */
    318              assert_param(IS_UART1_CONFIG_IT_OK(UART1_IT));
   \   00000A A3 0100      CPW       X, #0x100
   \   00000D 27 1F        JREQ      L:??CrossCallReturnLabel_7
   \   00000F A3 0277      CPW       X, #0x277
   \   000012 27 1A        JREQ      L:??CrossCallReturnLabel_7
   \   000014 A3 0266      CPW       X, #0x266
   \   000017 27 15        JREQ      L:??CrossCallReturnLabel_7
   \   000019 A3 0205      CPW       X, #0x205
   \   00001C 27 10        JREQ      L:??CrossCallReturnLabel_7
   \   00001E A3 0244      CPW       X, #0x244
   \   000021 27 0B        JREQ      L:??CrossCallReturnLabel_7
   \   000023 A3 0346      CPW       X, #0x346
   \   000026 27 06        JREQ      L:??CrossCallReturnLabel_7
   \   000028 AE 013E      LDW       X, #0x13e
   \   00002B CD ....      CALL      L:?Subroutine1
    319              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_7:
   \   00002E 3D ..        TNZ       S:?b10
   \   000030 27 0C        JREQ      L:??CrossCallReturnLabel_6
   \   000032 B6 ..        LD        A, S:?b10
   \   000034 A1 01        CP        A, #0x1
   \   000036 27 06        JREQ      L:??CrossCallReturnLabel_6
   \   000038 AE 013F      LDW       X, #0x13f
   \   00003B CD ....      CALL      L:?Subroutine1
    320          
    321              /* Get the UART1 register index */
    322              uartreg = (uint8_t)((uint16_t)UART1_IT >> 0x08);
   \                     ??CrossCallReturnLabel_6:
   \   00003E BE ..        LDW       X, S:?w4
   \   000040 4F           CLR       A
   \   000041 01           RRWA      X, A
   \   000042 41           EXG       A, XL
   \   000043 B7 ..        LD        S:?b1, A
   \   000045 41           EXG       A, XL
    323              /* Get the UART1 IT index */
    324              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \   000046 CD ....      CALL      L:?Subroutine2
    325          
    326              if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_23:
   \   000049 3D ..        TNZ       S:?b10
   \   00004B 27 1F        JREQ      L:??UART1_ITConfig_0
    327              {
    328                  /**< Enable the Interrupt bits according to UART1_IT mask */
    329                  if (uartreg == 0x01)
   \   00004D B6 ..        LD        A, S:?b1
   \   00004F A1 01        CP        A, #0x1
   \   000051 26 07        JRNE      L:??UART1_ITConfig_1
    330                  {
    331                      UART1->CR1 |= itpos;
   \   000053 B6 ..        LD        A, S:?b0
   \   000055 CA 5234      OR        A, L:0x5234
   \   000058 20 1F        JRA       L:??UART1_ITConfig_2
    332                  }
    333                  else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_1:
   \   00005A A1 02        CP        A, #0x2
   \   00005C 26 07        JRNE      L:??UART1_ITConfig_3
    334                  {
    335                      UART1->CR2 |= itpos;
   \   00005E B6 ..        LD        A, S:?b0
   \   000060 CA 5235      OR        A, L:0x5235
   \   000063 20 22        JRA       L:??UART1_ITConfig_4
    336                  }
    337                  else
    338                  {
    339                      UART1->CR4 |= itpos;
   \                     ??UART1_ITConfig_3:
   \   000065 B6 ..        LD        A, S:?b0
   \   000067 CA 5237      OR        A, L:0x5237
   \   00006A 20 25        JRA       L:??UART1_ITConfig_5
    340                  }
    341              }
    342              else
    343              {
    344                  /**< Disable the interrupt bits according to UART1_IT mask */
    345                  if (uartreg == 0x01)
   \                     ??UART1_ITConfig_0:
   \   00006C 33 ..        CPL       S:?b0
   \   00006E B6 ..        LD        A, S:?b1
   \   000070 A1 01        CP        A, #0x1
   \   000072 26 0A        JRNE      L:??UART1_ITConfig_6
    346                  {
    347                      UART1->CR1 &= (uint8_t)(~itpos);
   \   000074 B6 ..        LD        A, S:?b0
   \   000076 C4 5234      AND       A, L:0x5234
   \                     ??UART1_ITConfig_2:
   \   000079 C7 5234      LD        L:0x5234, A
   \   00007C 20 16        JRA       L:??UART1_ITConfig_7
    348                  }
    349                  else if (uartreg == 0x02)
   \                     ??UART1_ITConfig_6:
   \   00007E A1 02        CP        A, #0x2
   \   000080 26 0A        JRNE      L:??UART1_ITConfig_8
    350                  {
    351                      UART1->CR2 &= (uint8_t)(~itpos);
   \   000082 B6 ..        LD        A, S:?b0
   \   000084 C4 5235      AND       A, L:0x5235
   \                     ??UART1_ITConfig_4:
   \   000087 C7 5235      LD        L:0x5235, A
   \   00008A 20 08        JRA       L:??UART1_ITConfig_7
    352                  }
    353                  else
    354                  {
    355                      UART1->CR4 &= (uint8_t)(~itpos);
   \                     ??UART1_ITConfig_8:
   \   00008C B6 ..        LD        A, S:?b0
   \   00008E C4 5237      AND       A, L:0x5237
   \                     ??UART1_ITConfig_5:
   \   000091 C7 5237      LD        L:0x5237, A
    356                  }
    357              }
    358          
    359          }
   \                     ??UART1_ITConfig_7:
   \   000094 32 ....      POP       S:?b10
   \   000097 CC ....      JP        L:?epilogue_w4

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine2:
   \   000000 CD ....      CALL      L:?Subroutine7
   \                     ??CrossCallReturnLabel_36:
   \   000003 41           EXG       A, XL
   \   000004 B7 ..        LD        S:?b0, A
   \   000006 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine7:
   \   000000 A4 0F        AND       A, #0xf
   \   000002 5F           CLRW      X
   \   000003 5C           INCW      X
   \   000004 CC ....      JP        L:?sll16_x_x_a
    360          /**
    361            * @brief  Enables or disables the UART’s Half Duplex communication.
    362            * @param  NewState new state of the UART Communication.
    363            *         This parameter can be: ENABLE or DISABLE.
    364            * @retval None
    365            */

   \                                 In section .near_func.text, align 1
    366          void UART1_HalfDuplexCmd(FunctionalState NewState)
    367          {
    368              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_HalfDuplexCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_HalfDuplexCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_8
   \   000007 AE 0170      LDW       X, #0x170
   \   00000A CD ....      CALL      L:?Subroutine1
    369          
    370              if (NewState != DISABLE)
    371              {
    372                  UART1->CR5 |= UART1_CR5_HDSEL;  /**< UART1 Half Duplex Enable  */
   \                     ??CrossCallReturnLabel_8:
   \   00000D 7216 5238    BSET      L:0x5238, #0x3
   \   000011 81           RET
    373              }
    374              else
    375              {
    376                  UART1->CR5 &= (uint8_t)~UART1_CR5_HDSEL; /**< UART1 Half Duplex Disable */
   \                     ??UART1_HalfDuplexCmd_0:
   \   000012 7217 5238    BRES      L:0x5238, #0x3
    377              }
    378          }
   \   000016 81           RET
    379          
    380          /**
    381            * @brief  Configures the UART’s IrDA interface.
    382            * @param  UART1_IrDAMode specifies the IrDA mode.
    383            *         This parameter can be any of the @ref UART1_IrDAMode_TypeDef values.
    384            * @retval None
    385            */

   \                                 In section .near_func.text, align 1
    386          void UART1_IrDAConfig(UART1_IrDAMode_TypeDef UART1_IrDAMode)
    387          {
    388              assert_param(IS_UART1_IRDAMODE_OK(UART1_IrDAMode));
   \                     UART1_IrDAConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 27 09        JREQ      L:??CrossCallReturnLabel_9
   \   000004 4D           TNZ       A
   \   000005 27 0B        JREQ      L:??UART1_IrDAConfig_0
   \   000007 AE 0184      LDW       X, #0x184
   \   00000A CD ....      CALL      L:?Subroutine1
    389          
    390              if (UART1_IrDAMode != UART1_IRDAMODE_NORMAL)
    391              {
    392                  UART1->CR5 |= UART1_CR5_IRLP;
   \                     ??CrossCallReturnLabel_9:
   \   00000D 7214 5238    BSET      L:0x5238, #0x2
   \   000011 81           RET
    393              }
    394              else
    395              {
    396                  UART1->CR5 &= ((uint8_t)~UART1_CR5_IRLP);
   \                     ??UART1_IrDAConfig_0:
   \   000012 7215 5238    BRES      L:0x5238, #0x2
    397              }
    398          }
   \   000016 81           RET
    399          
    400          /**
    401            * @brief  Enables or disables the UART’s IrDA interface.
    402            * @param  NewState new state of the IrDA mode.
    403            *         This parameter can be: ENABLE or DISABLE.
    404            * @retval None
    405            */

   \                                 In section .near_func.text, align 1
    406          void UART1_IrDACmd(FunctionalState NewState)
    407          {
    408          
    409              /* Check parameters */
    410              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_IrDACmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_IrDACmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_10
   \   000007 AE 019A      LDW       X, #0x19a
   \   00000A CD ....      CALL      L:?Subroutine1
    411          
    412              if (NewState != DISABLE)
    413              {
    414                  /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    415                  UART1->CR5 |= UART1_CR5_IREN;
   \                     ??CrossCallReturnLabel_10:
   \   00000D 7212 5238    BSET      L:0x5238, #0x1
   \   000011 81           RET
    416              }
    417              else
    418              {
    419                  /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    420                  UART1->CR5 &= ((uint8_t)~UART1_CR5_IREN);
   \                     ??UART1_IrDACmd_0:
   \   000012 7213 5238    BRES      L:0x5238, #0x1
    421              }
    422          }
   \   000016 81           RET
    423          
    424          /**
    425            * @brief  Sets the UART1 LIN Break detection length.
    426            * @param  UART1_LINBreakDetectionLength specifies the LIN break detection length.
    427            *         This parameter can be any of the
    428            *         @ref UART1_LINBreakDetectionLength_TypeDef values.
    429            * @retval None
    430            */

   \                                 In section .near_func.text, align 1
    431          void UART1_LINBreakDetectionConfig(UART1_LINBreakDetectionLength_TypeDef UART1_LINBreakDetectionLength)
    432          {
    433              assert_param(IS_UART1_LINBREAKDETECTIONLENGTH_OK(UART1_LINBreakDetectionLength));
   \                     UART1_LINBreakDetectionConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_LINBreakDetectionConfig_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_11
   \   000007 AE 01B1      LDW       X, #0x1b1
   \   00000A CD ....      CALL      L:?Subroutine1
    434          
    435              if (UART1_LINBreakDetectionLength != UART1_LINBREAKDETECTIONLENGTH_10BITS)
    436              {
    437                  UART1->CR4 |= UART1_CR4_LBDL;
   \                     ??CrossCallReturnLabel_11:
   \   00000D 721A 5237    BSET      L:0x5237, #0x5
   \   000011 81           RET
    438              }
    439              else
    440              {
    441                  UART1->CR4 &= ((uint8_t)~UART1_CR4_LBDL);
   \                     ??UART1_LINBreakDetectionConfig_0:
   \   000012 721B 5237    BRES      L:0x5237, #0x5
    442              }
    443          }
   \   000016 81           RET
    444          
    445          /**
    446            * @brief  Enables or disables the UART1’s LIN mode.
    447            * @param  NewState is new state of the UART1 LIN mode.
    448            *         This parameter can be: ENABLE or DISABLE.
    449            * @retval None
    450            */

   \                                 In section .near_func.text, align 1
    451          void UART1_LINCmd(FunctionalState NewState)
    452          {
    453              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_LINCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_LINCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_12
   \   000007 AE 01C5      LDW       X, #0x1c5
   \   00000A CD ....      CALL      L:?Subroutine1
    454          
    455              if (NewState != DISABLE)
    456              {
    457                  /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    458                  UART1->CR3 |= UART1_CR3_LINEN;
   \                     ??CrossCallReturnLabel_12:
   \   00000D 721C 5236    BSET      L:0x5236, #0x6
   \   000011 81           RET
    459              }
    460              else
    461              {
    462                  /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    463                  UART1->CR3 &= ((uint8_t)~UART1_CR3_LINEN);
   \                     ??UART1_LINCmd_0:
   \   000012 721D 5236    BRES      L:0x5236, #0x6
    464              }
    465          }
   \   000016 81           RET
    466          /**
    467            * @brief  Enables or disables the UART1 Smart Card mode.
    468            * @param  NewState: new state of the Smart Card mode.
    469            * This parameter can be: ENABLE or DISABLE.
    470            * @retval None
    471            */

   \                                 In section .near_func.text, align 1
    472          void UART1_SmartCardCmd(FunctionalState NewState)
    473          {
    474              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_SmartCardCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_SmartCardCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_13
   \   000007 AE 01DA      LDW       X, #0x1da
   \   00000A CD ....      CALL      L:?Subroutine1
    475          
    476              if (NewState != DISABLE)
    477              {
    478                  /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    479                  UART1->CR5 |= UART1_CR5_SCEN;
   \                     ??CrossCallReturnLabel_13:
   \   00000D 721A 5238    BSET      L:0x5238, #0x5
   \   000011 81           RET
    480              }
    481              else
    482              {
    483                  /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    484                  UART1->CR5 &= ((uint8_t)(~UART1_CR5_SCEN));
   \                     ??UART1_SmartCardCmd_0:
   \   000012 721B 5238    BRES      L:0x5238, #0x5
    485              }
    486          }
   \   000016 81           RET
    487          
    488          /**
    489            * @brief  Enables or disables NACK transmission.
    490            * @note   This function is valid only for UART1 because is related to SmartCard mode.
    491            * @param  NewState: new state of the Smart Card mode.
    492            *         This parameter can be: ENABLE or DISABLE.
    493            * @retval None
    494            */

   \                                 In section .near_func.text, align 1
    495          void UART1_SmartCardNACKCmd(FunctionalState NewState)
    496          {
    497              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_SmartCardNACKCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_SmartCardNACKCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_14
   \   000007 AE 01F1      LDW       X, #0x1f1
   \   00000A CD ....      CALL      L:?Subroutine1
    498          
    499              if (NewState != DISABLE)
    500              {
    501                  /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    502                  UART1->CR5 |= UART1_CR5_NACK;
   \                     ??CrossCallReturnLabel_14:
   \   00000D 7218 5238    BSET      L:0x5238, #0x4
   \   000011 81           RET
    503              }
    504              else
    505              {
    506                  /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    507                  UART1->CR5 &= ((uint8_t)~(UART1_CR5_NACK));
   \                     ??UART1_SmartCardNACKCmd_0:
   \   000012 7219 5238    BRES      L:0x5238, #0x4
    508              }
    509          }
   \   000016 81           RET
    510          
    511          /**
    512            * @brief  Selects the UART1 WakeUp method.
    513            * @param  UART1_WakeUp: specifies the UART1 wakeup method.
    514            *         This parameter can be any of the @ref UART1_WakeUp_TypeDef values.
    515            * @retval None
    516            */

   \                                 In section .near_func.text, align 1
    517          void UART1_WakeUpConfig(UART1_WakeUp_TypeDef UART1_WakeUp)
    518          {
   \                     UART1_WakeUpConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    519              assert_param(IS_UART1_WAKEUP_OK(UART1_WakeUp));
   \   000005 27 0A        JREQ      L:??CrossCallReturnLabel_15
   \   000007 A1 08        CP        A, #0x8
   \   000009 27 06        JREQ      L:??CrossCallReturnLabel_15
   \   00000B AE 0207      LDW       X, #0x207
   \   00000E CD ....      CALL      L:?Subroutine1
    520          
    521              UART1->CR1 &= ((uint8_t)~UART1_CR1_WAKE);
   \                     ??CrossCallReturnLabel_15:
   \   000011 7217 5234    BRES      L:0x5234, #0x3
    522              UART1->CR1 |= (uint8_t)UART1_WakeUp;
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 CD ....      CALL      L:?Subroutine4
    523          }
   \                     ??CrossCallReturnLabel_27:
   \   00001A 32 ....      POP       S:?b8
   \   00001D 81           RET
    524          /**
    525            * @brief  Determines if the UART1 is in mute mode or not.
    526            * @param  NewState: new state of the UART1 mode.
    527            *         This parameter can be: ENABLE or DISABLE.
    528            * @retval None
    529            */

   \                                 In section .near_func.text, align 1
    530          void UART1_ReceiverWakeUpCmd(FunctionalState NewState)
    531          {
    532              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART1_ReceiverWakeUpCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART1_ReceiverWakeUpCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_16
   \   000007 AE 0214      LDW       X, #0x214
   \   00000A CD ....      CALL      L:?Subroutine1
    533          
    534              if (NewState != DISABLE)
    535              {
    536                  /* Enable the mute mode UART1 by setting the RWU bit in the CR2 register */
    537                  UART1->CR2 |= UART1_CR2_RWU;
   \                     ??CrossCallReturnLabel_16:
   \   00000D 7212 5235    BSET      L:0x5235, #0x1
   \   000011 81           RET
    538              }
    539              else
    540              {
    541                  /* Disable the mute mode UART1 by clearing the RWU bit in the CR1 register */
    542                  UART1->CR2 &= ((uint8_t)~UART1_CR2_RWU);
   \                     ??UART1_ReceiverWakeUpCmd_0:
   \   000012 7213 5235    BRES      L:0x5235, #0x1
    543              }
    544          }
   \   000016 81           RET
    545          
    546          /**
    547            * @brief  Returns the most recent received data by the UART1 peripheral.
    548            * @param  None
    549            * @retval The received data.
    550            */

   \                                 In section .near_func.text, align 1
    551          uint8_t UART1_ReceiveData8(void)
    552          {
    553              return ((uint8_t)UART1->DR);
   \                     UART1_ReceiveData8:
   \   000000 C6 5231      LD        A, L:0x5231
   \   000003 81           RET
    554          }
    555          
    556          /**
    557            * @brief  Returns the most recent received data by the UART1 peripheral.
    558            * @param  None
    559            * @retval The received data.
    560            */

   \                                 In section .near_func.text, align 1
    561          uint16_t UART1_ReceiveData9(void)
    562          {
    563            uint16_t temp = 0;
    564            
    565            temp = (uint16_t)(((uint16_t)( (uint16_t)UART1->CR1 & (uint16_t)UART1_CR1_R8)) << 1);
   \                     UART1_ReceiveData9:
   \   000000 C6 5234      LD        A, L:0x5234
    566            return (uint16_t)( (((uint16_t) UART1->DR) | temp ) & ((uint16_t)0x01FF));
   \   000003 5F           CLRW      X
   \   000004 97           LD        XL, A
   \   000005 01           RRWA      X, A
   \   000006 A4 80        AND       A, #0x80
   \   000008 02           RLWA      X, A
   \   000009 58           SLLW      X
   \   00000A C6 5231      LD        A, L:0x5231
   \   00000D 905F         CLRW      Y
   \   00000F 9097         LD        YL, A
   \   000011 BF ..        LDW       S:?w0, X
   \   000013 93           LDW       X, Y
   \   000014 02           RLWA      X, A
   \   000015 BA ..        OR        A, S:?b0
   \   000017 01           RRWA      X, A
   \   000018 81           RET
    567          }
    568          
    569          /**
    570            * @brief  Transmits 8 bit data through the UART1 peripheral.
    571            * @param  Data: The data to transmit.
    572            * @retval None
    573            */

   \                                 In section .near_func.text, align 1
    574          void UART1_SendData8(uint8_t Data)
    575          {
    576              /* Transmit Data */
    577              UART1->DR = Data;
   \                     UART1_SendData8:
   \   000000 C7 5231      LD        L:0x5231, A
    578          }
   \   000003 81           RET
    579          
    580          /**
    581            * @brief  Transmits 9 bit data through the UART peripheral.
    582            * @param  Data : The data to transmit.
    583            *         This parameter should be lower than 0x1FF.
    584            * @retval None
    585            */

   \                                 In section .near_func.text, align 1
    586          void UART1_SendData9(uint16_t Data)
    587          {
   \                     UART1_SendData9:
   \   000000 9093         LDW       Y, X
    588              /**< Clear the transmit data bit 8 [8]  */
    589              UART1->CR1 &= ((uint8_t)~UART1_CR1_T8);
   \   000002 721D 5234    BRES      L:0x5234, #0x6
    590              /**< Write the transmit data bit [8]  */
    591              UART1->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART1_CR1_T8);
   \   000006 54           SRLW      X
   \   000007 54           SRLW      X
   \   000008 9F           LD        A, XL
   \   000009 A4 40        AND       A, #0x40
   \   00000B CD ....      CALL      L:?Subroutine4
    592              /**< Write the transmit data bit [0:7] */
    593              UART1->DR   = (uint8_t)(Data);
   \                     ??CrossCallReturnLabel_26:
   \   00000E 909F         LD        A, YL
   \   000010 C7 5231      LD        L:0x5231, A
    594          }
   \   000013 81           RET
    595          
    596          /**
    597            * @brief  Transmits break characters.
    598            * @param  None
    599            * @retval None
    600            */

   \                                 In section .near_func.text, align 1
    601          void UART1_SendBreak(void)
    602          {
    603              UART1->CR2 |= UART1_CR2_SBK;
   \                     UART1_SendBreak:
   \   000000 7210 5235    BSET      L:0x5235, #0x0
    604          }
   \   000004 81           RET
    605          
    606          /**
    607            * @brief  Sets the address of the UART1 node.
    608            * @param  UART1_Address: Indicates the address of the UART1 node.
    609            * @retval None
    610            */

   \                                 In section .near_func.text, align 1
    611          void UART1_SetAddress(uint8_t UART1_Address)
    612          {
   \                     UART1_SetAddress:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    613              /*assert_param for UART1_Address*/
    614              assert_param(IS_UART1_ADDRESS_OK(UART1_Address));
   \   000005 A1 10        CP        A, #0x10
   \   000007 25 06        JRC       L:??CrossCallReturnLabel_17
   \   000009 AE 0266      LDW       X, #0x266
   \   00000C CD ....      CALL      L:?Subroutine1
    615          
    616              /* Clear the UART1 address */
    617              UART1->CR4 &= ((uint8_t)~UART1_CR4_ADD);
   \                     ??CrossCallReturnLabel_17:
   \   00000F C6 5237      LD        A, L:0x5237
   \   000012 A4 F0        AND       A, #0xf0
   \   000014 C7 5237      LD        L:0x5237, A
    618              /* Set the UART1 address node */
    619              UART1->CR4 |= UART1_Address;
   \   000017 B6 ..        LD        A, S:?b8
   \   000019 CA 5237      OR        A, L:0x5237
   \   00001C C7 5237      LD        L:0x5237, A
    620          }
   \   00001F 32 ....      POP       S:?b8
   \   000022 81           RET
    621          
    622          /**
    623            * @brief  Sets the specified UART guard time.
    624            * @note   SmartCard Mode should be Enabled
    625            * @param  UART1_GuardTime: specifies the guard time.
    626            * @retval None
    627            */

   \                                 In section .near_func.text, align 1
    628          void UART1_SetGuardTime(uint8_t UART1_GuardTime)
    629          {
    630              /* Set the UART1 guard time */
    631              UART1->GTR = UART1_GuardTime;
   \                     UART1_SetGuardTime:
   \   000000 C7 5239      LD        L:0x5239, A
    632          }
   \   000003 81           RET
    633          
    634          /**
    635            * @brief  Sets the system clock prescaler.
    636            * @note   IrDA Low Power mode or smartcard mode should be enabled
    637            * @note   This function is related to SmartCard and IrDa mode.
    638            * @param  UART1_Prescaler: specifies the prescaler clock.
    639            *         This parameter can be one of the following values:
    640            *         @par IrDA Low Power Mode
    641            *         The clock source is divided by the value given in the register (8 bits)
    642            *         - 0000 0000 Reserved
    643            *         - 0000 0001 divides the clock source by 1
    644            *         - 0000 0010 divides the clock source by 2
    645            *         - ...........................................................
    646            *        @par Smart Card Mode
    647            *        The clock source is divided by the value given in the register
    648            *        (5 significant bits) multiplied by 2
    649            *         - 0 0000 Reserved
    650            *         - 0 0001 divides the clock source by 2
    651            *         - 0 0010 divides the clock source by 4
    652            *         - 0 0011 divides the clock source by 6
    653            *         - ...........................................................
    654            * @retval None
    655            */

   \                                 In section .near_func.text, align 1
    656          void UART1_SetPrescaler(uint8_t UART1_Prescaler)
    657          {
    658              /* Load the UART1 prescaler value*/
    659              UART1->PSCR = UART1_Prescaler;
   \                     UART1_SetPrescaler:
   \   000000 C7 523A      LD        L:0x523a, A
    660          }
   \   000003 81           RET
    661          
    662          /**
    663            * @brief  Checks whether the specified UART1 flag is set or not.
    664            * @param  UART1_FLAG specifies the flag to check.
    665            *         This parameter can be any of the @ref UART1_Flag_TypeDef enumeration.
    666            * @retval FlagStatus (SET or RESET)
    667            */

   \                                 In section .near_func.text, align 1
    668          FlagStatus UART1_GetFlagStatus(UART1_Flag_TypeDef UART1_FLAG)
    669          {
   \                     UART1_GetFlagStatus:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
    670              FlagStatus status = RESET;
   \   000008 3F ..        CLR       S:?b10
    671          
    672              /* Check parameters */
    673              assert_param(IS_UART1_FLAG_OK(UART1_FLAG));
   \   00000A A3 0080      CPW       X, #0x80
   \   00000D 27 33        JREQ      L:??CrossCallReturnLabel_18
   \   00000F A3 0040      CPW       X, #0x40
   \   000012 27 2E        JREQ      L:??CrossCallReturnLabel_18
   \   000014 A3 0020      CPW       X, #0x20
   \   000017 27 29        JREQ      L:??CrossCallReturnLabel_18
   \   000019 A3 0010      CPW       X, #0x10
   \   00001C 27 24        JREQ      L:??CrossCallReturnLabel_18
   \   00001E A3 0008      CPW       X, #0x8
   \   000021 27 1F        JREQ      L:??CrossCallReturnLabel_18
   \   000023 A3 0004      CPW       X, #0x4
   \   000026 27 1A        JREQ      L:??CrossCallReturnLabel_18
   \   000028 A3 0002      CPW       X, #0x2
   \   00002B 27 15        JREQ      L:??CrossCallReturnLabel_18
   \   00002D A3 0001      CPW       X, #0x1
   \   000030 27 10        JREQ      L:??CrossCallReturnLabel_18
   \   000032 A3 0101      CPW       X, #0x101
   \   000035 27 25        JREQ      L:??UART1_GetFlagStatus_0
   \   000037 A3 0210      CPW       X, #0x210
   \   00003A 27 19        JREQ      L:??UART1_GetFlagStatus_1
   \   00003C AE 02A1      LDW       X, #0x2a1
   \   00003F CD ....      CALL      L:?Subroutine1
    674          
    675          
    676              /* Check the status of the specified UART1 flag*/
    677              if (UART1_FLAG == UART1_FLAG_LBDF)
    678              {
    679                  if ((UART1->CR4 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
    680                  {
    681                      /* UART1_FLAG is set*/
    682                      status = SET;
    683                  }
    684                  else
    685                  {
    686                      /* UART1_FLAG is reset*/
    687                      status = RESET;
    688                  }
    689              }
    690              else if (UART1_FLAG == UART1_FLAG_SBK)
    691              {
    692                  if ((UART1->CR2 & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
    693                  {
    694                      /* UART1_FLAG is set*/
    695                      status = SET;
    696                  }
    697                  else
    698                  {
    699                      /* UART1_FLAG is reset*/
    700                      status = RESET;
    701                  }
    702              }
    703              else
    704              {
    705                  if ((UART1->SR & (uint8_t)UART1_FLAG) != (uint8_t)0x00)
   \                     ??CrossCallReturnLabel_18:
   \   000042 B6 ..        LD        A, S:?b9
   \   000044 C5 5230      BCP       A, L:0x5230
   \   000047 27 04        JREQ      L:??UART1_GetFlagStatus_2
    706                  {
    707                      /* UART1_FLAG is set*/
    708                      status = SET;
   \                     ??UART1_GetFlagStatus_3:
   \   000049 35 01 ....   MOV       S:?b10, #0x1
    709                  }
    710                  else
    711                  {
    712                      /* UART1_FLAG is reset*/
    713                      status = RESET;
    714                  }
    715              }
    716              /* Return the UART1_FLAG status*/
    717              return status;
   \                     ??UART1_GetFlagStatus_2:
   \   00004D B6 ..        LD        A, S:?b10
   \   00004F 32 ....      POP       S:?b10
   \   000052 CC ....      JP        L:?epilogue_w4
   \                     ??UART1_GetFlagStatus_1:
   \   000055 7208 5237 EF BTJT      L:0x5237, #0x4, L:??UART1_GetFlagStatus_3
   \   00005A 20 F1        JRA       L:??UART1_GetFlagStatus_2
   \                     ??UART1_GetFlagStatus_0:
   \   00005C 7200 5235 E8 BTJT      L:0x5235, #0x0, L:??UART1_GetFlagStatus_3
   \   000061 20 EA        JRA       L:??UART1_GetFlagStatus_2
    718          }
    719          
    720          /**
    721            * @brief  Clears the UART1 flags.
    722            * @param  UART1_FLAG specifies the flag to clear
    723            *         This parameter can be any combination of the following values:
    724            *         - UART1_FLAG_LBDF: LIN Break detection flag.
    725            *         - UART1_FLAG_RXNE: Receive data register not empty flag.
    726            * @note
    727            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    728            *         OR (OverRun error) and IDLE (Idle line detected) flags are 
    729            *         cleared by software sequence: a read operation to UART1_SR register
    730            *         (UART1_GetFlagStatus())followed by a read operation to UART1_DR 
    731            *         register(UART1_ReceiveData8() or UART1_ReceiveData9()).
    732            *           
    733            *         - RXNE flag can be also cleared by a read to the UART1_DR register
    734            *         (UART1_ReceiveData8()or UART1_ReceiveData9()).
    735            *           
    736            *         - TC flag can be also cleared by software sequence: a read operation
    737            *         to UART1_SR register (UART1_GetFlagStatus()) followed by a write 
    738            *         operation to UART1_DR register (UART1_SendData8() or UART1_SendData9()).
    739            *           
    740            *         - TXE flag is cleared only by a write to the UART1_DR register 
    741            *         (UART1_SendData8() or UART1_SendData9()).
    742            *           
    743            *         - SBK flag is cleared during the stop bit of break.
    744            * @retval None
    745            */
    746          

   \                                 In section .near_func.text, align 1
    747          void UART1_ClearFlag(UART1_Flag_TypeDef UART1_FLAG)
    748          {
    749              assert_param(IS_UART1_CLEAR_FLAG_OK(UART1_FLAG));
   \                     UART1_ClearFlag:
   \   000000 A3 0020      CPW       X, #0x20
   \   000003 27 10        JREQ      L:??UART1_ClearFlag_0
   \   000005 A3 0210      CPW       X, #0x210
   \   000008 27 06        JREQ      L:??CrossCallReturnLabel_19
   \   00000A AE 02ED      LDW       X, #0x2ed
   \   00000D CD ....      CALL      L:?Subroutine1
    750          
    751              /* Clear the Receive Register Not Empty flag */
    752              if (UART1_FLAG == UART1_FLAG_RXNE)
    753              {
    754                  UART1->SR = (uint8_t)~(UART1_SR_RXNE);
    755              }
    756              /* Clear the LIN Break Detection flag */
    757              else
    758              {
    759                  UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??CrossCallReturnLabel_19:
   \   000010 7219 5237    BRES      L:0x5237, #0x4
    760              }
    761          }
   \   000014 81           RET
   \                     ??UART1_ClearFlag_0:
   \   000015 35 DF 5230   MOV       L:0x5230, #0xdf
   \   000019 81           RET
    762          
    763          /**
    764            * @brief  Checks whether the specified UART1 interrupt has occurred or not.
    765            * @param  UART1_IT: Specifies the UART1 interrupt pending bit to check.
    766            *         This parameter can be one of the following values:
    767            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    768            *         - UART1_IT_TXE:  Tansmit Data Register empty interrupt
    769            *         - UART1_IT_TC:   Transmission complete interrupt
    770            *         - UART1_IT_RXNE: Receive Data register not empty interrupt
    771            *         - UART1_IT_IDLE: Idle line detection interrupt
    772            *         - UART1_IT_OR:  OverRun Error interrupt
    773            *         - UART1_IT_PE:   Parity Error interrupt
    774            * @retval The new state of UART1_IT (SET or RESET).
    775            */

   \                                 In section .near_func.text, align 1
    776          ITStatus UART1_GetITStatus(UART1_IT_TypeDef UART1_IT)
    777          {
   \                     UART1_GetITStatus:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
    778              ITStatus pendingbitstatus = RESET;
   \   000008 3F ..        CLR       S:?b10
    779              uint8_t itpos = 0;
    780              uint8_t itmask1 = 0;
    781              uint8_t itmask2 = 0;
    782              uint8_t enablestatus = 0;
    783          
    784              /* Check parameters */
    785              assert_param(IS_UART1_GET_IT_OK(UART1_IT));
   \   00000A A3 0277      CPW       X, #0x277
   \   00000D 27 24        JREQ      L:??CrossCallReturnLabel_20
   \   00000F A3 0266      CPW       X, #0x266
   \   000012 27 1F        JREQ      L:??CrossCallReturnLabel_20
   \   000014 A3 0255      CPW       X, #0x255
   \   000017 27 1A        JREQ      L:??CrossCallReturnLabel_20
   \   000019 A3 0244      CPW       X, #0x244
   \   00001C 27 15        JREQ      L:??CrossCallReturnLabel_20
   \   00001E A3 0235      CPW       X, #0x235
   \   000021 27 10        JREQ      L:??CrossCallReturnLabel_20
   \   000023 A3 0346      CPW       X, #0x346
   \   000026 27 0B        JREQ      L:??CrossCallReturnLabel_20
   \   000028 A3 0100      CPW       X, #0x100
   \   00002B 27 06        JREQ      L:??CrossCallReturnLabel_20
   \   00002D AE 0311      LDW       X, #0x311
   \   000030 CD ....      CALL      L:?Subroutine1
    786          
    787              /* Get the UART1 IT index */
    788              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART1_IT & (uint8_t)0x0F));
   \                     ??CrossCallReturnLabel_20:
   \   000033 B6 ..        LD        A, S:?b9
   \   000035 CD ....      CALL      L:?Subroutine2
    789              /* Get the UART1 IT index */
    790              itmask1 = (uint8_t)((uint8_t)UART1_IT >> (uint8_t)4);
    791              /* Set the IT mask*/
    792              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \                     ??CrossCallReturnLabel_22:
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A 4E           SWAP      A
   \   00003B CD ....      CALL      L:?Subroutine7
   \                     ??CrossCallReturnLabel_35:
   \   00003E 9F           LD        A, XL
    793          
    794          
    795              /* Check the status of the specified UART1 pending bit*/
    796              if (UART1_IT == UART1_IT_PE)
   \   00003F BE ..        LDW       X, S:?w4
   \   000041 A3 0100      CPW       X, #0x100
   \   000044 26 0C        JRNE      L:??UART1_GetITStatus_0
    797              {
    798                  /* Get the UART1_IT enable bit status*/
    799                  enablestatus = (uint8_t)((uint8_t)UART1->CR1 & itmask2);
   \   000046 C4 5234      AND       A, L:0x5234
   \   000049 B7 ..        LD        S:?b1, A
    800                  /* Check the status of the specified UART1 interrupt*/
    801          
    802                  if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   00004B B6 ..        LD        A, S:?b0
   \   00004D C4 5230      AND       A, L:0x5230
   \   000050 20 0F        JRA       L:??UART1_GetITStatus_1
    803                  {
    804                      /* Interrupt occurred*/
    805                      pendingbitstatus = SET;
    806                  }
    807                  else
    808                  {
    809                      /* Interrupt not occurred*/
    810                      pendingbitstatus = RESET;
    811                  }
    812              }
    813          
    814              else if (UART1_IT == UART1_IT_LBDF)
   \                     ??UART1_GetITStatus_0:
   \   000052 A3 0346      CPW       X, #0x346
   \   000055 26 10        JRNE      L:??UART1_GetITStatus_2
    815              {
    816                  /* Get the UART1_IT enable bit status*/
    817                  enablestatus = (uint8_t)((uint8_t)UART1->CR4 & itmask2);
   \   000057 C4 5237      AND       A, L:0x5237
   \   00005A B7 ..        LD        S:?b1, A
    818                  /* Check the status of the specified UART1 interrupt*/
    819                  if (((UART1->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
   \   00005C B6 ..        LD        A, S:?b0
   \   00005E C4 5237      AND       A, L:0x5237
   \                     ??UART1_GetITStatus_1:
   \   000061 A1 00        CP        A, #0x0
   \   000063 26 0E        JRNE      L:??UART1_GetITStatus_3
   \   000065 20 14        JRA       L:??UART1_GetITStatus_4
    820                  {
    821                      /* Interrupt occurred*/
    822                      pendingbitstatus = SET;
    823                  }
    824                  else
    825                  {
    826                      /* Interrupt not occurred*/
    827                      pendingbitstatus = RESET;
    828                  }
    829              }
    830              else
    831              {
    832                  /* Get the UART1_IT enable bit status*/
    833                  enablestatus = (uint8_t)((uint8_t)UART1->CR2 & itmask2);
   \                     ??UART1_GetITStatus_2:
   \   000067 C4 5235      AND       A, L:0x5235
   \   00006A B7 ..        LD        S:?b1, A
    834                  /* Check the status of the specified UART1 interrupt*/
    835                  if (((UART1->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   00006C B6 ..        LD        A, S:?b0
   \   00006E C5 5230      BCP       A, L:0x5230
   \   000071 27 08        JREQ      L:??UART1_GetITStatus_4
   \                     ??UART1_GetITStatus_3:
   \   000073 3D ..        TNZ       S:?b1
   \   000075 27 04        JREQ      L:??UART1_GetITStatus_4
    836                  {
    837                      /* Interrupt occurred*/
    838                      pendingbitstatus = SET;
   \   000077 35 01 ....   MOV       S:?b10, #0x1
    839                  }
    840                  else
    841                  {
    842                      /* Interrupt not occurred*/
    843                      pendingbitstatus = RESET;
    844                  }
    845              }
    846          
    847              /* Return the UART1_IT status*/
    848              return  pendingbitstatus;
   \                     ??UART1_GetITStatus_4:
   \   00007B B6 ..        LD        A, S:?b10
   \   00007D 32 ....      POP       S:?b10
   \   000080 CC ....      JP        L:?epilogue_w4
    849          }
    850          
    851          /**
    852            * @brief  Clears the UART1 pending flags.
    853            * @param  UART1_IT specifies the pending bit to clear
    854            *         This parameter can be one of the following values:
    855            *         - UART1_IT_LBDF:  LIN Break detection interrupt
    856            *         - UART1_IT_RXNE: Receive Data register not empty interrupt.
    857            * @note
    858            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    859            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    860            *           cleared by software sequence: a read operation to UART1_SR register
    861            *           (UART1_GetITStatus()) followed by a read operation to UART1_DR register
    862            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    863            *   
    864            *         - RXNE pending bit can be also cleared by a read to the UART1_DR register
    865            *           (UART1_ReceiveData8() or UART1_ReceiveData9()).
    866            * 
    867            *         - TC (Transmit complete) pending bit can be cleared by software 
    868            *           sequence: a read operation to UART1_SR register (UART1_GetITStatus())
    869            *           followed by a write operation to UART1_DR register (UART1_SendData8()
    870            *           or UART1_SendData9()).
    871            *             
    872            *         - TXE pending bit is cleared only by a write to the UART1_DR register
    873            *           (UART1_SendData8() or UART1_SendData9()).
    874            * @retval None
    875            */

   \                                 In section .near_func.text, align 1
    876          void UART1_ClearITPendingBit(UART1_IT_TypeDef UART1_IT)
    877          {
    878              assert_param(IS_UART1_CLEAR_IT_OK(UART1_IT));
   \                     UART1_ClearITPendingBit:
   \   000000 A3 0255      CPW       X, #0x255
   \   000003 27 10        JREQ      L:??UART1_ClearITPendingBit_0
   \   000005 A3 0346      CPW       X, #0x346
   \   000008 27 06        JREQ      L:??CrossCallReturnLabel_21
   \   00000A AE 036E      LDW       X, #0x36e
   \   00000D CD ....      CALL      L:?Subroutine1
    879          
    880              /* Clear the Receive Register Not Empty pending bit */
    881              if (UART1_IT == UART1_IT_RXNE)
    882              {
    883                  UART1->SR = (uint8_t)~(UART1_SR_RXNE);
    884              }
    885              /* Clear the LIN Break Detection pending bit */
    886              else
    887              {
    888                  UART1->CR4 &= (uint8_t)~(UART1_CR4_LBDF);
   \                     ??CrossCallReturnLabel_21:
   \   000010 7219 5237    BRES      L:0x5237, #0x4
    889              }
    890          }
   \   000014 81           RET
   \                     ??UART1_ClearITPendingBit_0:
   \   000015 35 DF 5230   MOV       L:0x5230, #0xdf
   \   000019 81           RET

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\SNAP\\\\SNAP_100\\\\GS10...">`:
   \   000000 43 3A 5C 53  DC8 "C:\\SNAP\\SNAP_100\\GS1011_Serial_Handlers.c"
   \          4E 41 50 5C 
    891          
    892          /**
    893            * @}
    894            */
    895            
    896          /**
    897            * @}
    898            */
    899            
    900          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      42  ?<Constant "C:\\SNAP\\SNAP_100\\GS10...">
      35  ?Subroutine0
      11  ?Subroutine1
       7  ?Subroutine2
      13  ?Subroutine3
       7  ?Subroutine4
       7  ?Subroutine5
       8  ?Subroutine6
       7  ?Subroutine7
       9  ?Subroutine8
       1  GS1011_Received_Data_Handler
       2  GetNetworkStatusFromGS1011
       1  GetResponseFromGS1011
       0  SendUpdateToWebsite
      23  Sending_GS1011_Data_Handler
       2  SetupGS1011Association
      11  Start_GS1011_Send
      26  UART1_ClearFlag
      26  UART1_ClearITPendingBit
      13  UART1_Cmd
      43  UART1_DeInit
      99  UART1_GetFlagStatus
     131  UART1_GetITStatus
      23  UART1_HalfDuplexCmd
     154  UART1_ITConfig
     407  UART1_Init
      23  UART1_IrDACmd
      23  UART1_IrDAConfig
      23  UART1_LINBreakDetectionConfig
      23  UART1_LINCmd
       4  UART1_ReceiveData8
      25  UART1_ReceiveData9
      23  UART1_ReceiverWakeUpCmd
       5  UART1_SendBreak
       4  UART1_SendData8
      20  UART1_SendData9
      35  UART1_SetAddress
       4  UART1_SetGuardTime
       4  UART1_SetPrescaler
      23  UART1_SmartCardCmd
      23  UART1_SmartCardNACKCmd
      30  UART1_WakeUpConfig

 
    42 bytes in section .near.rodata
 1 358 bytes in section .near_func.text
 
 1 358 bytes of CODE  memory
    42 bytes of CONST memory

Errors: none
Warnings: none
