###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             11/Jun/2013  07:36:44 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\SNAP\7896_SNAP\Device_uart3.c                         #
#    Command line =  C:\SNAP\7896_SNAP\Device_uart3.c -e --enable_multibytes  #
#                    -Oh --debug --code_model medium --data_model medium -o   #
#                    C:\SNAP\7896_SNAP\Debug\Obj\ --dlib_config "C:\Program   #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8S007 -lC                #
#                    C:\SNAP\7896_SNAP\Debug\List\ -I .\                      #
#                    --require_prototypes --vregs 16                          #
#    List file    =  C:\SNAP\7896_SNAP\Debug\List\Device_uart3.lst            #
#    Object file  =  C:\SNAP\7896_SNAP\Debug\Obj\Device_uart3.o               #
#                                                                             #
#                                                                             #
###############################################################################

C:\SNAP\7896_SNAP\Device_uart3.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8s_uart3.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the uart3 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_uart3.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          
     34          /* Private functions ---------------------------------------------------------*/
     35          /* Public functions ----------------------------------------------------------*/
     36          
     37          /** @}
     38            * @addtogroup UART3_Public_Functions
     39            * @{
     40            */
     41          
     42          /**
     43            * @brief  Deinitializes the UART peripheral.
     44            * @param  None
     45            * @retval None
     46            */
     47          

   \                                 In section .far_func.text, align 1
     48          void UART3_DeInit(void)
     49          {
     50              /* Clear the Idle Line Detected bit in the status rerister by a read
     51                 to the UART3_SR register followed by a Read to the UART3_DR register */
     52              (void) UART3->SR;
   \                     UART3_DeInit:
   \   000000 C6 5240      LD        A, L:0x5240
     53              (void) UART3->DR;
   \   000003 C6 5241      LD        A, L:0x5241
     54          
     55              UART3->BRR2 = UART3_BRR2_RESET_VALUE; /*Set UART3_BRR2 to reset value 0x00 */
   \   000006 725F 5243    CLR       L:0x5243
     56              UART3->BRR1 = UART3_BRR1_RESET_VALUE; /*Set UART3_BRR1 to reset value 0x00 */
   \   00000A 725F 5242    CLR       L:0x5242
     57          
     58              UART3->CR1 = UART3_CR1_RESET_VALUE;  /*Set UART3_CR1 to reset value 0x00  */
   \   00000E 725F 5244    CLR       L:0x5244
     59              UART3->CR2 = UART3_CR2_RESET_VALUE;  /*Set UART3_CR2 to reset value 0x00  */
   \   000012 725F 5245    CLR       L:0x5245
     60              UART3->CR3 = UART3_CR3_RESET_VALUE;  /*Set UART3_CR3 to reset value 0x00  */
   \   000016 725F 5246    CLR       L:0x5246
     61              UART3->CR4 = UART3_CR4_RESET_VALUE;  /*Set UART3_CR4 to reset value 0x00  */
   \   00001A 725F 5247    CLR       L:0x5247
     62              UART3->CR6 = UART3_CR6_RESET_VALUE;  /*Set UART3_CR6 to reset value 0x00  */
   \   00001E 725F 5249    CLR       L:0x5249
     63          
     64          }
   \   000022 87           RETF
     65          
     66          /**
     67            * @brief  Initializes the UART3 according to the specified parameters.
     68            * @param  BaudRate: The baudrate.
     69            * @param  WordLength : This parameter can be any of 
     70            *         the @ref UART3_WordLength_TypeDef enumeration.
     71            * @param  StopBits: This parameter can be any of the 
     72            *         @ref UART3_StopBits_TypeDef enumeration.
     73            * @param  Parity: This parameter can be any of the 
     74            *         @ref UART3_Parity_TypeDef enumeration.
     75            * @param  Mode: This parameter can be any of the @ref UART3_Mode_TypeDef values
     76            * @retval None
     77            */

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine2:
   \   000000 CA 5244      OR        A, L:0x5244
   \   000003 C7 5244      LD        L:0x5244, A
   \   000006 87           RETF

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine0:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 AE ....      LDW       X, #`?<Constant "C:\\\\SNAP\\\\7896_SNAP\\\\Dev...">`
   \   000008 AC ......    JPF       assert_failed

   \                                 In section .far_func.text, align 1
     78          void UART3_Init(uint32_t BaudRate, UART3_WordLength_TypeDef WordLength, 
     79                          UART3_StopBits_TypeDef StopBits, UART3_Parity_TypeDef Parity, 
     80                          UART3_Mode_TypeDef Mode)
     81          {
   \                     UART3_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 3B ....      PUSH      S:?b6
   \   00000B 8D ......    CALLF     L:?mov_l2_l0
   \   00000F B7 ..        LD        S:?b14, A
   \   000011 45 .. ..     MOV       S:?b13, S:?b4
   \   000014 45 .. ..     MOV       S:?b12, S:?b5
     82              uint8_t BRR2_1 = 0, BRR2_2 = 0;
     83              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
     84          
     85                  /* Check the parameters */
     86              assert_param(IS_UART3_WORDLENGTH_OK(WordLength));
   \   000017 27 0B        JREQ      L:??CrossCallReturnLabel_4
   \   000019 A1 10        CP        A, #0x10
   \   00001B 27 07        JREQ      L:??CrossCallReturnLabel_4
   \   00001D AE 0056      LDW       X, #0x56
   \   000020 8D ......    CALLF     ?Subroutine0
     87              assert_param(IS_UART3_STOPBITS_OK(StopBits));
   \                     ??CrossCallReturnLabel_4:
   \   000024 3D ..        TNZ       S:?b13
   \   000026 27 0D        JREQ      L:??CrossCallReturnLabel_3
   \   000028 B6 ..        LD        A, S:?b13
   \   00002A A1 20        CP        A, #0x20
   \   00002C 27 07        JREQ      L:??CrossCallReturnLabel_3
   \   00002E AE 0057      LDW       X, #0x57
   \   000031 8D ......    CALLF     ?Subroutine0
     88              assert_param(IS_UART3_PARITY_OK(Parity));
   \                     ??CrossCallReturnLabel_3:
   \   000035 3D ..        TNZ       S:?b12
   \   000037 27 11        JREQ      L:??CrossCallReturnLabel_2
   \   000039 B6 ..        LD        A, S:?b12
   \   00003B A1 04        CP        A, #0x4
   \   00003D 27 0B        JREQ      L:??CrossCallReturnLabel_2
   \   00003F A1 06        CP        A, #0x6
   \   000041 27 07        JREQ      L:??CrossCallReturnLabel_2
   \   000043 AE 0058      LDW       X, #0x58
   \   000046 8D ......    CALLF     ?Subroutine0
     89              assert_param(IS_UART3_BAUDRATE_OK(BaudRate));
   \                     ??CrossCallReturnLabel_2:
   \   00004A BE ..        LDW       X, S:?w4
   \   00004C A3 0009      CPW       X, #0x9
   \   00004F 26 05        JRNE      L:??UART3_Init_0
   \   000051 BE ..        LDW       X, S:?w5
   \   000053 A3 8969      CPW       X, #0x8969
   \                     ??UART3_Init_0:
   \   000056 25 07        JRC       L:??CrossCallReturnLabel_1
   \   000058 AE 0059      LDW       X, #0x59
   \   00005B 8D ......    CALLF     ?Subroutine0
     90              assert_param(IS_UART3_MODE_OK((uint8_t)Mode));
   \                     ??CrossCallReturnLabel_1:
   \   00005F 7B 01        LD        A, (0x1,SP)
   \   000061 A1 08        CP        A, #0x8
   \   000063 27 23        JREQ      L:??CrossCallReturnLabel_0
   \   000065 A1 40        CP        A, #0x40
   \   000067 27 1F        JREQ      L:??CrossCallReturnLabel_0
   \   000069 A1 04        CP        A, #0x4
   \   00006B 27 1B        JREQ      L:??CrossCallReturnLabel_0
   \   00006D A1 80        CP        A, #0x80
   \   00006F 27 17        JREQ      L:??CrossCallReturnLabel_0
   \   000071 A1 0C        CP        A, #0xc
   \   000073 27 13        JREQ      L:??CrossCallReturnLabel_0
   \   000075 A1 44        CP        A, #0x44
   \   000077 27 0F        JREQ      L:??CrossCallReturnLabel_0
   \   000079 A1 C0        CP        A, #0xc0
   \   00007B 27 0B        JREQ      L:??CrossCallReturnLabel_0
   \   00007D A1 88        CP        A, #0x88
   \   00007F 27 07        JREQ      L:??CrossCallReturnLabel_0
   \   000081 AE 005A      LDW       X, #0x5a
   \   000084 8D ......    CALLF     ?Subroutine0
     91          
     92              /* Clear the word length bit */
     93              UART3->CR1 &= (uint8_t)(~UART3_CR1_M);     
   \                     ??CrossCallReturnLabel_0:
   \   000088 7219 5244    BRES      L:0x5244, #0x4
     94              /* Set the word length bit according to UART3_WordLength value */
     95              UART3->CR1 |= (uint8_t)WordLength; 
   \   00008C B6 ..        LD        A, S:?b14
   \   00008E 8D ......    CALLF     ?Subroutine2
     96          
     97              /* Clear the STOP bits */
     98              UART3->CR3 &= (uint8_t)(~UART3_CR3_STOP);  
   \                     ??CrossCallReturnLabel_23:
   \   000092 C6 5246      LD        A, L:0x5246
   \   000095 A4 CF        AND       A, #0xcf
   \   000097 C7 5246      LD        L:0x5246, A
     99              /* Set the STOP bits number according to UART3_StopBits value  */
    100              UART3->CR3 |= (uint8_t)StopBits;  
   \   00009A B6 ..        LD        A, S:?b13
   \   00009C CA 5246      OR        A, L:0x5246
   \   00009F C7 5246      LD        L:0x5246, A
    101          
    102              /* Clear the Parity Control bit */
    103              UART3->CR1 &= (uint8_t)(~(UART3_CR1_PCEN | UART3_CR1_PS));  
   \   0000A2 C6 5244      LD        A, L:0x5244
   \   0000A5 A4 F9        AND       A, #0xf9
   \   0000A7 C7 5244      LD        L:0x5244, A
    104              /* Set the Parity Control bit to UART3_Parity value */
    105              UART3->CR1 |= (uint8_t)Parity;     
   \   0000AA B6 ..        LD        A, S:?b12
   \   0000AC 8D ......    CALLF     ?Subroutine2
    106          
    107              /* Clear the LSB mantissa of UART3DIV  */
    108              UART3->BRR1 &= (uint8_t)(~UART3_BRR1_DIVM);  
   \                     ??CrossCallReturnLabel_24:
   \   0000B0 C6 5242      LD        A, L:0x5242
   \   0000B3 725F 5242    CLR       L:0x5242
    109              /* Clear the MSB mantissa of UART3DIV  */
    110              UART3->BRR2 &= (uint8_t)(~UART3_BRR2_DIVM);  
   \   0000B7 C6 5243      LD        A, L:0x5243
   \   0000BA A4 0F        AND       A, #0xf
   \   0000BC C7 5243      LD        L:0x5243, A
    111              /* Clear the Fraction bits of UART3DIV */
    112              UART3->BRR2 &= (uint8_t)(~UART3_BRR2_DIVF);  
   \   0000BF C6 5243      LD        A, L:0x5243
   \   0000C2 A4 F0        AND       A, #0xf0
   \   0000C4 C7 5243      LD        L:0x5243, A
    113          
    114              /* Set the UART3 BaudRates in BRR1 and BRR2 registers according to UART3_BaudRate value */
    115              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   0000C7 8D ......    CALLF     L:?mov_l0_l2
   \   0000CB A6 04        LD        A, #0x4
   \   0000CD 8D ......    CALLF     L:?sll32_l0_l0_a
   \   0000D1 8D ......    CALLF     L:?mov_l2_l0
   \   0000D5 8D ......    CALLF     CLK_GetClockFreq
   \   0000D9 8D ......    CALLF     L:?mov_l1_l2
   \   0000DD 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0000E1 8D ......    CALLF     L:?mov_l3_l0
    116              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
    117              /* The fraction and MSB mantissa should be loaded in one step in the BRR2 register */
    118              /* Set the fraction of UART3DIV  */
    119              BRR2_1 = (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100))
    120                                  << 4) / 100) & (uint8_t)0x0F); 
    121              BRR2_2 = (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0);
    122          
    123              UART3->BRR2 = (uint8_t)(BRR2_1 | BRR2_2);
   \   0000E5 8D ......    CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_25:
   \   0000E9 8D ......    CALLF     L:?push_l0
   \   0000ED 8D ......    CALLF     CLK_GetClockFreq
   \   0000F1 8D ......    CALLF     ?Subroutine3
   \                     ??CrossCallReturnLabel_26:
   \   0000F5 8D ......    CALLF     L:?mov_l1_l2
   \   0000F9 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0000FD 8D ......    CALLF     L:?pop_l1
   \   000101 8D ......    CALLF     L:?sub32_l0_l0_l1
   \   000105 A6 04        LD        A, #0x4
   \   000107 8D ......    CALLF     L:?sll32_l0_l0_a
   \   00010B 8D ......    CALLF     L:?udiv32_l0_l0_dl
   \   00010F 00000064     DC32      0x64
   \   000113 B6 ..        LD        A, S:?b3
   \   000115 A4 0F        AND       A, #0xf
   \   000117 B7 ..        LD        S:?b0, A
   \   000119 BE ..        LDW       X, S:?w7
   \   00011B 54           SRLW      X
   \   00011C 54           SRLW      X
   \   00011D 54           SRLW      X
   \   00011E 54           SRLW      X
   \   00011F 9F           LD        A, XL
   \   000120 A4 F0        AND       A, #0xf0
   \   000122 BA ..        OR        A, S:?b0
   \   000124 C7 5243      LD        L:0x5243, A
    124              /* Set the LSB mantissa of UART3DIV  */
    125              UART3->BRR1 = (uint8_t)BaudRate_Mantissa;           
   \   000127 B6 ..        LD        A, S:?b15
   \   000129 C7 5242      LD        L:0x5242, A
    126          
    127              if ((uint8_t)(Mode & UART3_MODE_TX_ENABLE))
   \   00012C 7B 01        LD        A, (0x1,SP)
   \   00012E A5 04        BCP       A, #0x4
   \   000130 27 06        JREQ      L:??UART3_Init_1
    128              {
    129                  /* Set the Transmitter Enable bit */
    130                  UART3->CR2 |= UART3_CR2_TEN;  
   \   000132 7216 5245    BSET      L:0x5245, #0x3
   \   000136 20 04        JRA       L:??UART3_Init_2
    131              }
    132              else
    133              {
    134                  /* Clear the Transmitter Disable bit */
    135                  UART3->CR2 &= (uint8_t)(~UART3_CR2_TEN);  
   \                     ??UART3_Init_1:
   \   000138 7217 5245    BRES      L:0x5245, #0x3
    136              }
    137              if ((uint8_t)(Mode & UART3_MODE_RX_ENABLE))
   \                     ??UART3_Init_2:
   \   00013C 7B 01        LD        A, (0x1,SP)
   \   00013E A5 08        BCP       A, #0x8
   \   000140 27 06        JREQ      L:??UART3_Init_3
    138              {
    139                  /* Set the Receiver Enable bit */
    140                  UART3->CR2 |= UART3_CR2_REN;  
   \   000142 7214 5245    BSET      L:0x5245, #0x2
   \   000146 20 04        JRA       L:??UART3_Init_4
    141              }
    142              else
    143              {
    144                  /* Clear the Receiver Disable bit */
    145                  UART3->CR2 &= (uint8_t)(~UART3_CR2_REN);  
   \                     ??UART3_Init_3:
   \   000148 7215 5245    BRES      L:0x5245, #0x2
    146              }
    147          }
   \                     ??UART3_Init_4:
   \   00014C 5B 01        ADD       SP, #0x1
   \   00014E AC ......    JPF       L:?epilogue_l2_l3

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine3:
   \   000000 AE 0064      LDW       X, #0x64
   \   000003 BF ..        LDW       S:?w3, X
   \   000005 5F           CLRW      X
   \   000006 BF ..        LDW       S:?w2, X
   \   000008 AC ......    JPF       L:?mul32_l0_l0_l1
    148          
    149          /**
    150            * @brief  Enable the UART1 peripheral.
    151            * @param  NewState : The new state of the UART Communication.
    152            *         This parameter can be any of the @ref FunctionalState enumeration.
    153            * @retval None
    154            */

   \                                 In section .far_func.text, align 1
    155          void UART3_Cmd(FunctionalState NewState)
    156          {
    157          
    158              if (NewState != DISABLE)
   \                     UART3_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??UART3_Cmd_0
    159              {
    160                  /* UART3 Enable */
    161                  UART3->CR1 &= (uint8_t)(~UART3_CR1_UARTD); 
   \   000003 721B 5244    BRES      L:0x5244, #0x5
   \   000007 87           RETF
    162              }
    163              else
    164              {
    165                  /* UART3 Disable */
    166                  UART3->CR1 |= UART3_CR1_UARTD;  
   \                     ??UART3_Cmd_0:
   \   000008 721A 5244    BSET      L:0x5244, #0x5
    167              }
    168          }
   \   00000C 87           RETF
    169          
    170          /**
    171            * @brief  Enables or disables the specified UART3 interrupts.
    172            * @param  UART3_IT specifies the UART3 interrupt sources to be enabled or disabled.
    173            *         This parameter can be one of the following values:
    174            *         - UART3_IT_LBDF:  LIN Break detection interrupt
    175            *         - UART3_IT_LHDF:  LIN Break detection interrupt
    176            *         - UART3_IT_TXE:  Tansmit Data Register empty interrupt
    177            *         - UART3_IT_TC:   Transmission complete interrupt
    178            *         - UART3_IT_RXNE_OR: Receive Data register not empty/Over run error interrupt
    179            *         - UART3_IT_IDLE: Idle line detection interrupt
    180            *         - UART3_IT_PE:   Parity Error interrupt
    181            * @param  NewState new state of the specified UART3 interrupts.
    182            *         This parameter can be: ENABLE or DISABLE.
    183            * @retval None
    184            */

   \                                 In section .far_func.text, align 1
    185          void UART3_ITConfig(UART3_IT_TypeDef UART3_IT, FunctionalState NewState)
    186          {
   \                     UART3_ITConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
   \   000009 B7 ..        LD        S:?b10, A
    187              uint8_t uartreg = 0, itpos = 0x00;
    188              
    189              /* Check the parameters */
    190              assert_param(IS_UART3_CONFIG_IT_OK(UART3_IT));
   \   00000B A3 0100      CPW       X, #0x100
   \   00000E 27 25        JREQ      L:??CrossCallReturnLabel_6
   \   000010 A3 0277      CPW       X, #0x277
   \   000013 27 20        JREQ      L:??CrossCallReturnLabel_6
   \   000015 A3 0266      CPW       X, #0x266
   \   000018 27 1B        JREQ      L:??CrossCallReturnLabel_6
   \   00001A A3 0205      CPW       X, #0x205
   \   00001D 27 16        JREQ      L:??CrossCallReturnLabel_6
   \   00001F A3 0244      CPW       X, #0x244
   \   000022 27 11        JREQ      L:??CrossCallReturnLabel_6
   \   000024 A3 0412      CPW       X, #0x412
   \   000027 27 0C        JREQ      L:??CrossCallReturnLabel_6
   \   000029 A3 0346      CPW       X, #0x346
   \   00002C 27 07        JREQ      L:??CrossCallReturnLabel_6
   \   00002E AE 00BE      LDW       X, #0xbe
   \   000031 8D ......    CALLF     ?Subroutine0
    191              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_6:
   \   000035 3D ..        TNZ       S:?b10
   \   000037 27 0D        JREQ      L:??CrossCallReturnLabel_5
   \   000039 B6 ..        LD        A, S:?b10
   \   00003B A1 01        CP        A, #0x1
   \   00003D 27 07        JREQ      L:??CrossCallReturnLabel_5
   \   00003F AE 00BF      LDW       X, #0xbf
   \   000042 8D ......    CALLF     ?Subroutine0
    192          
    193              /* Get the UART3 register index */
    194              uartreg = (uint8_t)((uint16_t)UART3_IT >> 0x08);
   \                     ??CrossCallReturnLabel_5:
   \   000046 BE ..        LDW       X, S:?w4
   \   000048 4F           CLR       A
   \   000049 01           RRWA      X, A
   \   00004A 41           EXG       A, XL
   \   00004B B7 ..        LD        S:?b1, A
   \   00004D 41           EXG       A, XL
    195          
    196              /* Get the UART3 IT index */
    197              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART3_IT & (uint8_t)0x0F));
   \   00004E 8D ......    CALLF     ?Subroutine1
    198          
    199              if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_20:
   \   000052 3D ..        TNZ       S:?b10
   \   000054 27 2A        JREQ      L:??UART3_ITConfig_0
    200              {
    201                  /* Enable the Interrupt bits according to UART3_IT mask */
    202                  if (uartreg == 0x01)
   \   000056 B6 ..        LD        A, S:?b1
   \   000058 A1 01        CP        A, #0x1
   \   00005A 26 07        JRNE      L:??UART3_ITConfig_1
    203                  {
    204                      UART3->CR1 |= itpos;
   \   00005C B6 ..        LD        A, S:?b0
   \   00005E CA 5244      OR        A, L:0x5244
   \   000061 20 2A        JRA       ??UART3_ITConfig_2
    205                  }
    206                  else if (uartreg == 0x02)
   \                     ??UART3_ITConfig_1:
   \   000063 A1 02        CP        A, #0x2
   \   000065 26 07        JRNE      L:??UART3_ITConfig_3
    207                  {
    208                      UART3->CR2 |= itpos;
   \   000067 B6 ..        LD        A, S:?b0
   \   000069 CA 5245      OR        A, L:0x5245
   \   00006C 20 2D        JRA       ??UART3_ITConfig_4
    209                  }
    210                  else if (uartreg == 0x03)
   \                     ??UART3_ITConfig_3:
   \   00006E A1 03        CP        A, #0x3
   \   000070 26 07        JRNE      L:??UART3_ITConfig_5
    211                  {
    212                      UART3->CR4 |= itpos;
   \   000072 B6 ..        LD        A, S:?b0
   \   000074 CA 5247      OR        A, L:0x5247
   \   000077 20 30        JRA       ??UART3_ITConfig_6
    213                  }
    214                  else
    215                  {
    216                      UART3->CR6 |= itpos;
   \                     ??UART3_ITConfig_5:
   \   000079 B6 ..        LD        A, S:?b0
   \   00007B CA 5249      OR        A, L:0x5249
   \   00007E 20 33        JRA       ??UART3_ITConfig_7
    217                  }
    218              }
    219              else
    220              {
    221                  /* Disable the interrupt bits according to UART3_IT mask */
    222                  if (uartreg == 0x01)
   \                     ??UART3_ITConfig_0:
   \   000080 33 ..        CPL       S:?b0
   \   000082 B6 ..        LD        A, S:?b1
   \   000084 A1 01        CP        A, #0x1
   \   000086 26 0A        JRNE      L:??UART3_ITConfig_8
    223                  {
    224                      UART3->CR1 &= (uint8_t)(~itpos);
   \   000088 B6 ..        LD        A, S:?b0
   \   00008A C4 5244      AND       A, L:0x5244
   \                     ??UART3_ITConfig_2:
   \   00008D C7 5244      LD        L:0x5244, A
   \   000090 20 24        JRA       L:??UART3_ITConfig_9
    225                  }
    226                  else if (uartreg == 0x02)
   \                     ??UART3_ITConfig_8:
   \   000092 A1 02        CP        A, #0x2
   \   000094 26 0A        JRNE      L:??UART3_ITConfig_10
    227                  {
    228                      UART3->CR2 &= (uint8_t)(~itpos);
   \   000096 B6 ..        LD        A, S:?b0
   \   000098 C4 5245      AND       A, L:0x5245
   \                     ??UART3_ITConfig_4:
   \   00009B C7 5245      LD        L:0x5245, A
   \   00009E 20 16        JRA       L:??UART3_ITConfig_9
    229                  }
    230                  else if (uartreg == 0x03)
   \                     ??UART3_ITConfig_10:
   \   0000A0 A1 03        CP        A, #0x3
   \   0000A2 26 0A        JRNE      L:??UART3_ITConfig_11
    231                  {
    232                      UART3->CR4 &= (uint8_t)(~itpos);
   \   0000A4 B6 ..        LD        A, S:?b0
   \   0000A6 C4 5247      AND       A, L:0x5247
   \                     ??UART3_ITConfig_6:
   \   0000A9 C7 5247      LD        L:0x5247, A
   \   0000AC 20 08        JRA       L:??UART3_ITConfig_9
    233                  }
    234                  else
    235                  {
    236                      UART3->CR6 &= (uint8_t)(~itpos);
   \                     ??UART3_ITConfig_11:
   \   0000AE B6 ..        LD        A, S:?b0
   \   0000B0 C4 5249      AND       A, L:0x5249
   \                     ??UART3_ITConfig_7:
   \   0000B3 C7 5249      LD        L:0x5249, A
    237                  }
    238              }
    239          }
   \                     ??UART3_ITConfig_9:
   \   0000B6 32 ....      POP       S:?b10
   \   0000B9 AC ......    JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
   \                     ?Subroutine1:
   \   000000 A4 0F        AND       A, #0xf
   \   000002 5F           CLRW      X
   \   000003 5C           INCW      X
   \   000004 8D ......    CALLF     L:?sll16_x_x_a
   \   000008 41           EXG       A, XL
   \   000009 B7 ..        LD        S:?b0, A
   \   00000B 87           RETF
    240          
    241          /**
    242            * @brief  Sets the UART3 LIN Break detection length.
    243            * @param  UART3_LINBreakDetectionLength specifies the LIN break detection length.
    244            *         This parameter can be any of the 
    245            *         @ref UART3_LINBreakDetectionLength_TypeDef values.
    246            * @retval None
    247            */

   \                                 In section .far_func.text, align 1
    248          void UART3_LINBreakDetectionConfig(UART3_LINBreakDetectionLength_TypeDef UART3_LINBreakDetectionLength)
    249          {
    250              /* Check the parameters */
    251              assert_param(IS_UART3_LINBREAKDETECTIONLENGTH_OK(UART3_LINBreakDetectionLength));
   \                     UART3_LINBreakDetectionConfig:
   \   000000 4D           TNZ       A
   \   000001 27 10        JREQ      L:??UART3_LINBreakDetectionConfig_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 07        JREQ      L:??CrossCallReturnLabel_7
   \   000007 AE 00FB      LDW       X, #0xfb
   \   00000A 8D ......    CALLF     ?Subroutine0
    252          
    253              if (UART3_LINBreakDetectionLength != UART3_LINBREAKDETECTIONLENGTH_10BITS)
    254              {
    255                  UART3->CR4 |= UART3_CR4_LBDL;
   \                     ??CrossCallReturnLabel_7:
   \   00000E 721A 5247    BSET      L:0x5247, #0x5
   \   000012 87           RETF
    256              }
    257              else
    258              {
    259                  UART3->CR4 &= ((uint8_t)~UART3_CR4_LBDL);
   \                     ??UART3_LINBreakDetectionConfig_0:
   \   000013 721B 5247    BRES      L:0x5247, #0x5
    260              }
    261          }
   \   000017 87           RETF
    262          
    263          /**
    264            * @brief  Configure the UART3 peripheral.
    265            * @param  UART3_Mode specifies the LIN mode.
    266            *         This parameter can be any of the @ref UART3_LinMode_TypeDef values.
    267            * @param  UART3_Autosync specifies the LIN automatic resynchronization mode.
    268            *         This parameter can be any of the @ref UART3_LinAutosync_TypeDef values.
    269            * @param  UART3_DivUp specifies the LIN divider update method.
    270            *         This parameter can be any of the @ref UART3_LinDivUp_TypeDef values.
    271            * @retval None
    272            */

   \                                 In section .far_func.text, align 1
    273          void UART3_LINConfig(UART3_LinMode_TypeDef UART3_Mode,
    274                               UART3_LinAutosync_TypeDef UART3_Autosync, 
    275                               UART3_LinDivUp_TypeDef UART3_DivUp)
    276          {
   \                     UART3_LINConfig:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 B7 ..        LD        S:?b8, A
   \   000009 45 .. ..     MOV       S:?b9, S:?b0
   \   00000C 45 .. ..     MOV       S:?b10, S:?b1
    277              /* Check the parameters */
    278              assert_param(IS_UART3_SLAVE_OK(UART3_Mode));
   \   00000F 27 0B        JREQ      L:??CrossCallReturnLabel_10
   \   000011 A1 01        CP        A, #0x1
   \   000013 27 07        JREQ      L:??CrossCallReturnLabel_10
   \   000015 AE 0116      LDW       X, #0x116
   \   000018 8D ......    CALLF     ?Subroutine0
    279              assert_param(IS_UART3_AUTOSYNC_OK(UART3_Autosync));
   \                     ??CrossCallReturnLabel_10:
   \   00001C B6 ..        LD        A, S:?b9
   \   00001E A1 01        CP        A, #0x1
   \   000020 27 0B        JREQ      L:??CrossCallReturnLabel_9
   \   000022 3D ..        TNZ       S:?b9
   \   000024 27 07        JREQ      L:??CrossCallReturnLabel_9
   \   000026 AE 0117      LDW       X, #0x117
   \   000029 8D ......    CALLF     ?Subroutine0
    280              assert_param(IS_UART3_DIVUP_OK(UART3_DivUp));
   \                     ??CrossCallReturnLabel_9:
   \   00002D 3D ..        TNZ       S:?b10
   \   00002F 27 0D        JREQ      L:??CrossCallReturnLabel_8
   \   000031 B6 ..        LD        A, S:?b10
   \   000033 A1 01        CP        A, #0x1
   \   000035 27 07        JREQ      L:??CrossCallReturnLabel_8
   \   000037 AE 0118      LDW       X, #0x118
   \   00003A 8D ......    CALLF     ?Subroutine0
    281          
    282              if (UART3_Mode != UART3_LIN_MODE_MASTER)
   \                     ??CrossCallReturnLabel_8:
   \   00003E 3D ..        TNZ       S:?b8
   \   000040 27 06        JREQ      L:??UART3_LINConfig_0
    283              {
    284                  UART3->CR6 |=  UART3_CR6_LSLV;
   \   000042 721A 5249    BSET      L:0x5249, #0x5
   \   000046 20 04        JRA       L:??UART3_LINConfig_1
    285              }
    286              else
    287              {
    288                  UART3->CR6 &= ((uint8_t)~UART3_CR6_LSLV);
   \                     ??UART3_LINConfig_0:
   \   000048 721B 5249    BRES      L:0x5249, #0x5
    289              }
    290          
    291              if (UART3_Autosync != UART3_LIN_AUTOSYNC_DISABLE)
   \                     ??UART3_LINConfig_1:
   \   00004C 3D ..        TNZ       S:?b9
   \   00004E 27 06        JREQ      L:??UART3_LINConfig_2
    292              {
    293                  UART3->CR6 |=  UART3_CR6_LASE ;
   \   000050 7218 5249    BSET      L:0x5249, #0x4
   \   000054 20 04        JRA       L:??UART3_LINConfig_3
    294              }
    295              else
    296              {
    297                  UART3->CR6 &= ((uint8_t)~ UART3_CR6_LASE );
   \                     ??UART3_LINConfig_2:
   \   000056 7219 5249    BRES      L:0x5249, #0x4
    298              }
    299          
    300              if (UART3_DivUp != UART3_LIN_DIVUP_LBRR1)
   \                     ??UART3_LINConfig_3:
   \   00005A 3D ..        TNZ       S:?b10
   \   00005C 27 06        JREQ      L:??UART3_LINConfig_4
    301              {
    302                  UART3->CR6 |=  UART3_CR6_LDUM;
   \   00005E 721E 5249    BSET      L:0x5249, #0x7
   \   000062 20 04        JRA       L:??UART3_LINConfig_5
    303              }
    304              else
    305              {
    306                  UART3->CR6 &= ((uint8_t)~ UART3_CR6_LDUM);
   \                     ??UART3_LINConfig_4:
   \   000064 721F 5249    BRES      L:0x5249, #0x7
    307              }
    308          }
   \                     ??UART3_LINConfig_5:
   \   000068 32 ....      POP       S:?b10
   \   00006B AC ......    JPF       L:?epilogue_w4
    309          
    310          /**
    311            * @brief  Enables or disables the UART3 LIN mode.
    312            * @param  NewState is new state of the UART3 LIN mode.
    313            *         This parameter can be ENABLE or DISABLE
    314            * @retval None
    315            */

   \                                 In section .far_func.text, align 1
    316          void UART3_LINCmd(FunctionalState NewState)
    317          {
    318              /* Check the parameters */
    319              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART3_LINCmd:
   \   000000 4D           TNZ       A
   \   000001 27 10        JREQ      L:??UART3_LINCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 07        JREQ      L:??CrossCallReturnLabel_11
   \   000007 AE 013F      LDW       X, #0x13f
   \   00000A 8D ......    CALLF     ?Subroutine0
    320          
    321              if (NewState != DISABLE)
    322              {
    323                  /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    324                  UART3->CR3 |= UART3_CR3_LINEN;
   \                     ??CrossCallReturnLabel_11:
   \   00000E 721C 5246    BSET      L:0x5246, #0x6
   \   000012 87           RETF
    325              }
    326              else
    327              {
    328                  /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    329                  UART3->CR3 &= ((uint8_t)~UART3_CR3_LINEN);
   \                     ??UART3_LINCmd_0:
   \   000013 721D 5246    BRES      L:0x5246, #0x6
    330              }
    331          }
   \   000017 87           RETF
    332          
    333          /**
    334            * @brief  Selects the UART3 WakeUp method.
    335            * @param  UART3_WakeUp: specifies the UART3 wakeup method.
    336            *         This parameter can be any of the @ref UART3_WakeUp_TypeDef values.
    337            * @retval None
    338            */

   \                                 In section .far_func.text, align 1
    339          void UART3_WakeUpConfig(UART3_WakeUp_TypeDef UART3_WakeUp)
    340          {
   \                     UART3_WakeUpConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    341              /* Check the parameters */
    342              assert_param(IS_UART3_WAKEUP_OK(UART3_WakeUp));
   \   000005 27 0B        JREQ      L:??CrossCallReturnLabel_12
   \   000007 A1 08        CP        A, #0x8
   \   000009 27 07        JREQ      L:??CrossCallReturnLabel_12
   \   00000B AE 0156      LDW       X, #0x156
   \   00000E 8D ......    CALLF     ?Subroutine0
    343          
    344              UART3->CR1 &= ((uint8_t)~UART3_CR1_WAKE);
   \                     ??CrossCallReturnLabel_12:
   \   000012 7217 5244    BRES      L:0x5244, #0x3
    345              UART3->CR1 |= (uint8_t)UART3_WakeUp;
   \   000016 B6 ..        LD        A, S:?b8
   \   000018 8D ......    CALLF     ?Subroutine2
    346          }
   \                     ??CrossCallReturnLabel_22:
   \   00001C 32 ....      POP       S:?b8
   \   00001F 87           RETF
    347          
    348          /**
    349            * @brief  Determines if the UART3 is in mute mode or not.
    350            * @param  NewState: new state of the UART3 mode.
    351            *         This parameter can be ENABLE or DISABLE
    352            * @retval None
    353            */

   \                                 In section .far_func.text, align 1
    354          void UART3_ReceiverWakeUpCmd(FunctionalState NewState)
    355          {
    356              /* Check the parameters */
    357              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART3_ReceiverWakeUpCmd:
   \   000000 4D           TNZ       A
   \   000001 27 10        JREQ      L:??UART3_ReceiverWakeUpCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 07        JREQ      L:??CrossCallReturnLabel_13
   \   000007 AE 0165      LDW       X, #0x165
   \   00000A 8D ......    CALLF     ?Subroutine0
    358          
    359              if (NewState != DISABLE)
    360              {
    361                  /* Enable the mute mode UART3 by setting the RWU bit in the CR2 register */
    362                  UART3->CR2 |= UART3_CR2_RWU;
   \                     ??CrossCallReturnLabel_13:
   \   00000E 7212 5245    BSET      L:0x5245, #0x1
   \   000012 87           RETF
    363              }
    364              else
    365              {
    366                  /* Disable the mute mode UART3 by clearing the RWU bit in the CR1 register */
    367                  UART3->CR2 &= ((uint8_t)~UART3_CR2_RWU);
   \                     ??UART3_ReceiverWakeUpCmd_0:
   \   000013 7213 5245    BRES      L:0x5245, #0x1
    368              }
    369          }
   \   000017 87           RETF
    370          
    371          /**
    372            * @brief  Returns the most recent received data by the UART3 peripheral.
    373            * @param  None
    374            * @retval Received Data
    375            */

   \                                 In section .far_func.text, align 1
    376          u8 UART3_ReceiveData8(void)
    377          {
    378              return ((u8)UART3->DR);
   \                     UART3_ReceiveData8:
   \   000000 C6 5241      LD        A, L:0x5241
   \   000003 87           RETF
    379          }
    380          
    381          /**
    382            * @brief  Returns the most recent received data by the UART3 peripheral.
    383            * @param  None
    384            * @retval Received Data
    385            */

   \                                 In section .far_func.text, align 1
    386          uint16_t UART3_ReceiveData9(void)
    387          {
    388            uint16_t temp = 0;
    389          
    390           temp = (uint16_t)(((uint16_t)((uint16_t)UART3->CR1 & (uint16_t)UART3_CR1_R8)) << 1);
   \                     UART3_ReceiveData9:
   \   000000 C6 5244      LD        A, L:0x5244
    391            return (uint16_t)((((uint16_t)UART3->DR) | temp) & ((uint16_t)0x01FF));
   \   000003 5F           CLRW      X
   \   000004 97           LD        XL, A
   \   000005 01           RRWA      X, A
   \   000006 A4 80        AND       A, #0x80
   \   000008 02           RLWA      X, A
   \   000009 58           SLLW      X
   \   00000A C6 5241      LD        A, L:0x5241
   \   00000D 905F         CLRW      Y
   \   00000F 9097         LD        YL, A
   \   000011 BF ..        LDW       S:?w0, X
   \   000013 93           LDW       X, Y
   \   000014 02           RLWA      X, A
   \   000015 BA ..        OR        A, S:?b0
   \   000017 01           RRWA      X, A
   \   000018 87           RETF
    392          }
    393          
    394          /**
    395            * @brief  Transmits 8 bit data through the UART3 peripheral.
    396            * @param  Data the data to transmit.
    397            * @retval None
    398            */

   \                                 In section .far_func.text, align 1
    399          void UART3_SendData8(u8 Data)
    400          {
    401              /* Transmit Data */
    402              UART3->DR = Data;
   \                     UART3_SendData8:
   \   000000 C7 5241      LD        L:0x5241, A
    403          }
   \   000003 87           RETF
    404          
    405          /**
    406            * @brief  Transmits 9 bit data through the UART3 peripheral.
    407            * @param   Data: the data to transmit.
    408            * @retval None
    409            */

   \                                 In section .far_func.text, align 1
    410          void UART3_SendData9(uint16_t Data)
    411          {
   \                     UART3_SendData9:
   \   000000 9093         LDW       Y, X
    412              /* Clear the transmit data bit 8 */
    413              UART3->CR1 &= ((uint8_t)~UART3_CR1_T8);                  
   \   000002 721D 5244    BRES      L:0x5244, #0x6
    414              
    415              /* Write the transmit data bit [8] */
    416              UART3->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART3_CR1_T8); 
   \   000006 54           SRLW      X
   \   000007 54           SRLW      X
   \   000008 9F           LD        A, XL
   \   000009 A4 40        AND       A, #0x40
   \   00000B 8D ......    CALLF     ?Subroutine2
    417              
    418              /* Write the transmit data bit [0:7] */
    419              UART3->DR   = (uint8_t)(Data);                    
   \                     ??CrossCallReturnLabel_21:
   \   00000F 909F         LD        A, YL
   \   000011 C7 5241      LD        L:0x5241, A
    420          }
   \   000014 87           RETF
    421          
    422          /**
    423            * @brief  Transmits break characters.
    424            * @param  None
    425            * @retval None
    426            */

   \                                 In section .far_func.text, align 1
    427          void UART3_SendBreak(void)
    428          {
    429              UART3->CR2 |= UART3_CR2_SBK;
   \                     UART3_SendBreak:
   \   000000 7210 5245    BSET      L:0x5245, #0x0
    430          }
   \   000004 87           RETF
    431          
    432          /**
    433            * @brief  Sets the address of the UART3 node.
    434            * @param  UART3_Address: Indicates the address of the UART3 node.
    435            * @retval None
    436            */

   \                                 In section .far_func.text, align 1
    437          void UART3_SetAddress(uint8_t UART3_Address)
    438          {
   \                     UART3_SetAddress:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    439              /* Check the parameters */
    440              assert_param(IS_UART3_ADDRESS_OK(UART3_Address));
   \   000005 A1 10        CP        A, #0x10
   \   000007 25 07        JRC       L:??CrossCallReturnLabel_14
   \   000009 AE 01B8      LDW       X, #0x1b8
   \   00000C 8D ......    CALLF     ?Subroutine0
    441          
    442              /* Clear the UART3 address */
    443              UART3->CR4 &= ((uint8_t)~UART3_CR4_ADD);
   \                     ??CrossCallReturnLabel_14:
   \   000010 C6 5247      LD        A, L:0x5247
   \   000013 A4 F0        AND       A, #0xf0
   \   000015 C7 5247      LD        L:0x5247, A
    444              /* Set the UART3 address node */
    445              UART3->CR4 |= UART3_Address;
   \   000018 B6 ..        LD        A, S:?b8
   \   00001A CA 5247      OR        A, L:0x5247
   \   00001D C7 5247      LD        L:0x5247, A
    446          }
   \   000020 32 ....      POP       S:?b8
   \   000023 87           RETF
    447          
    448          /**
    449            * @brief  Checks whether the specified UART3 flag is set or not.
    450            * @param  UART3_FLAG specifies the flag to check.
    451            *         This parameter can be any of the @ref UART3_Flag_TypeDef enumeration.
    452            * @retval FlagStatus (SET or RESET)
    453            */

   \                                 In section .far_func.text, align 1
    454          FlagStatus UART3_GetFlagStatus(UART3_Flag_TypeDef UART3_FLAG)
    455          {
   \                     UART3_GetFlagStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
    456              FlagStatus status = RESET;
   \   000009 3F ..        CLR       S:?b10
    457          
    458              /* Check parameters */
    459              assert_param(IS_UART3_FLAG_OK(UART3_FLAG));
   \   00000B A3 0080      CPW       X, #0x80
   \   00000E 27 3E        JREQ      L:??CrossCallReturnLabel_15
   \   000010 A3 0040      CPW       X, #0x40
   \   000013 27 39        JREQ      L:??CrossCallReturnLabel_15
   \   000015 A3 0020      CPW       X, #0x20
   \   000018 27 34        JREQ      L:??CrossCallReturnLabel_15
   \   00001A A3 0010      CPW       X, #0x10
   \   00001D 27 2F        JREQ      L:??CrossCallReturnLabel_15
   \   00001F A3 0008      CPW       X, #0x8
   \   000022 27 2A        JREQ      L:??CrossCallReturnLabel_15
   \   000024 A3 0004      CPW       X, #0x4
   \   000027 27 25        JREQ      L:??CrossCallReturnLabel_15
   \   000029 A3 0002      CPW       X, #0x2
   \   00002C 27 20        JREQ      L:??CrossCallReturnLabel_15
   \   00002E A3 0001      CPW       X, #0x1
   \   000031 27 1B        JREQ      L:??CrossCallReturnLabel_15
   \   000033 A3 0101      CPW       X, #0x101
   \   000036 27 31        JREQ      L:??UART3_GetFlagStatus_0
   \   000038 A3 0301      CPW       X, #0x301
   \   00003B 27 33        JREQ      L:??UART3_GetFlagStatus_1
   \   00003D A3 0302      CPW       X, #0x302
   \   000040 27 2E        JREQ      L:??UART3_GetFlagStatus_1
   \   000042 A3 0210      CPW       X, #0x210
   \   000045 27 1B        JREQ      L:??UART3_GetFlagStatus_2
   \   000047 AE 01CB      LDW       X, #0x1cb
   \   00004A 8D ......    CALLF     ?Subroutine0
    460          
    461              /* Check the status of the specified UART3 flag*/
    462              if (UART3_FLAG == UART3_FLAG_LBDF)
    463              {
    464                  if ((UART3->CR4 & (uint8_t)UART3_FLAG) != (uint8_t)0x00)
    465                  {
    466                      /* UART3_FLAG is set*/
    467                      status = SET;
    468                  }
    469                  else
    470                  {
    471                      /* UART3_FLAG is reset*/
    472                      status = RESET;
    473                  }
    474              }
    475              else if (UART3_FLAG == UART3_FLAG_SBK)
    476              {
    477                  if ((UART3->CR2 & (uint8_t)UART3_FLAG) != (uint8_t)0x00)
    478                  {
    479                      /* UART3_FLAG is set*/
    480                      status = SET;
    481                  }
    482                  else
    483                  {
    484                      /* UART3_FLAG is reset*/
    485                      status = RESET;
    486                  }
    487              }
    488              else if ((UART3_FLAG == UART3_FLAG_LHDF) || (UART3_FLAG == UART3_FLAG_LSF))
    489              {
    490                  if ((UART3->CR6 & (uint8_t)UART3_FLAG) != (uint8_t)0x00)
    491                  {
    492                      /* UART3_FLAG is set*/
    493                      status = SET;
    494                  }
    495                  else
    496                  {
    497                      /* UART3_FLAG is reset*/
    498                      status = RESET;
    499                  }
    500              }
    501              else
    502              {
    503                  if ((UART3->SR & (uint8_t)UART3_FLAG) != (uint8_t)0x00)
   \                     ??CrossCallReturnLabel_15:
   \   00004E B6 ..        LD        A, S:?b9
   \   000050 C5 5240      BCP       A, L:0x5240
   \   000053 27 04        JREQ      L:??UART3_GetFlagStatus_3
    504                  {
    505                      /* UART3_FLAG is set*/
    506                      status = SET;
   \                     ??UART3_GetFlagStatus_4:
   \   000055 35 01 ....   MOV       S:?b10, #0x1
    507                  }
    508                  else
    509                  {
    510                      /* UART3_FLAG is reset*/
    511                      status = RESET;
    512                  }
    513              }
    514          
    515              /* Return the UART3_FLAG status*/
    516              return  status;
   \                     ??UART3_GetFlagStatus_3:
   \   000059 B6 ..        LD        A, S:?b10
   \   00005B 32 ....      POP       S:?b10
   \   00005E AC ......    JPF       L:?epilogue_w4
   \                     ??UART3_GetFlagStatus_2:
   \   000062 7208 5247 EE BTJT      L:0x5247, #0x4, L:??UART3_GetFlagStatus_4
   \   000067 20 F0        JRA       L:??UART3_GetFlagStatus_3
   \                     ??UART3_GetFlagStatus_0:
   \   000069 7200 5245 E7 BTJT      L:0x5245, #0x0, L:??UART3_GetFlagStatus_4
   \   00006E 20 E9        JRA       L:??UART3_GetFlagStatus_3
   \                     ??UART3_GetFlagStatus_1:
   \   000070 B6 ..        LD        A, S:?b9
   \   000072 C5 5249      BCP       A, L:0x5249
   \   000075 26 DE        JRNE      L:??UART3_GetFlagStatus_4
   \   000077 20 E0        JRA       L:??UART3_GetFlagStatus_3
    517          }
    518          /**
    519            * @brief  Clears the UART3 flags.
    520            * @param  UART3_FLAG specifies the flag to clear
    521            *         This parameter can be any combination of the following values:
    522            *         - UART3_FLAG_LBDF: LIN Break detection flag.
    523            *         - UART3_FLAG_LHDF: LIN Header detection flag.
    524            *         - UART3_FLAG_LSF: LIN synchrone field flag.
    525            *         - UART3_FLAG_RXNE: Receive data register not empty flag.
    526            * @note
    527            *         - PE (Parity error), FE (Framing error), NF (Noise error), 
    528            *           OR (OverRun error) and IDLE (Idle line detected) flags are cleared
    529            *           by software sequence: a read operation to UART3_SR register 
    530            *           (UART3_GetFlagStatus())followed by a read operation to UART3_DR 
    531            *           register(UART3_ReceiveData8() or UART3_ReceiveData9()).
    532            *             
    533            *         - RXNE flag can be also cleared by a read to the UART3_DR register
    534            *           (UART3_ReceiveData8()or UART3_ReceiveData9()).
    535            *             
    536            *         - TC flag can be also cleared by software sequence: a read operation
    537            *           to UART3_SR register (UART3_GetFlagStatus()) followed by a write 
    538            *           operation to UART3_DR register (UART3_SendData8() or UART3_SendData9()).
    539            *             
    540            *         - TXE flag is cleared only by a write to the UART3_DR register 
    541            *           (UART3_SendData8() or UART3_SendData9()).
    542            *             
    543            *         - SBK flag is cleared during the stop bit of break.
    544            * @retval None
    545            */

   \                                 In section .far_func.text, align 1
    546          void UART3_ClearFlag(UART3_Flag_TypeDef UART3_FLAG)
    547          {
    548              /* Check the parameters */
    549              assert_param(IS_UART3_CLEAR_FLAG_OK(UART3_FLAG));
   \                     UART3_ClearFlag:
   \   000000 A3 0020      CPW       X, #0x20
   \   000003 27 1B        JREQ      L:??UART3_ClearFlag_0
   \   000005 A3 0302      CPW       X, #0x302
   \   000008 27 20        JREQ      L:??UART3_ClearFlag_1
   \   00000A A3 0301      CPW       X, #0x301
   \   00000D 27 0C        JREQ      L:??CrossCallReturnLabel_16
   \   00000F A3 0210      CPW       X, #0x210
   \   000012 27 11        JREQ      L:??UART3_ClearFlag_2
   \   000014 AE 0225      LDW       X, #0x225
   \   000017 8D ......    CALLF     ?Subroutine0
    550          
    551              /*Clear the Receive Register Not Empty flag */
    552              if (UART3_FLAG == UART3_FLAG_RXNE)
    553              {
    554                  UART3->SR = (uint8_t)~(UART3_SR_RXNE);
    555              }
    556              /*Clear the LIN Break Detection flag */
    557              else if (UART3_FLAG == UART3_FLAG_LBDF)
    558              {
    559                  UART3->CR4 &= (uint8_t)(~UART3_CR4_LBDF);
    560              }
    561              /*Clear the LIN Header Detection Flag */
    562              else if (UART3_FLAG == UART3_FLAG_LHDF)
    563              {
    564                  UART3->CR6 &= (uint8_t)(~UART3_CR6_LHDF);
    565              }
    566              /*Clear the LIN Synch Field flag */
    567              else
    568              {
    569                  UART3->CR6 &= (uint8_t)(~UART3_CR6_LSF);
   \                     ??CrossCallReturnLabel_16:
   \   00001B 7211 5249    BRES      L:0x5249, #0x0
    570              }
    571          }
   \   00001F 87           RETF
   \                     ??UART3_ClearFlag_0:
   \   000020 35 DF 5240   MOV       L:0x5240, #0xdf
   \   000024 87           RETF
   \                     ??UART3_ClearFlag_2:
   \   000025 7219 5247    BRES      L:0x5247, #0x4
   \   000029 87           RETF
   \                     ??UART3_ClearFlag_1:
   \   00002A 7213 5249    BRES      L:0x5249, #0x1
   \   00002E 87           RETF
    572          
    573          /**
    574            * @brief  Checks whether the specified UART3 interrupt has occurred or not.
    575            * @param  UART3_IT: Specifies the UART3 interrupt pending bit to check.
    576            *         This parameter can be one of the following values:
    577            *         - UART3_IT_LBDF:  LIN Break detection interrupt
    578            *         - UART3_IT_TXE:  Tansmit Data Register empty interrupt
    579            *         - UART3_IT_TC:   Transmission complete interrupt
    580            *         - UART3_IT_RXNE: Receive Data register not empty interrupt
    581            *         - UART3_IT_IDLE: Idle line detection interrupt
    582            *         - UART3_IT_OR:  OverRun Error interrupt
    583            *         - UART3_IT_PE:   Parity Error interrupt
    584            * @retval The state of UART3_IT (SET or RESET).
    585            */

   \                                 In section .far_func.text, align 1
    586          ITStatus UART3_GetITStatus(UART3_IT_TypeDef UART3_IT)
    587          {
   \                     UART3_GetITStatus:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
   \   000007 BF ..        LDW       S:?w4, X
    588              ITStatus pendingbitstatus = RESET;
   \   000009 3F ..        CLR       S:?b10
    589              uint8_t itpos = 0;
    590              uint8_t itmask1 = 0;
    591              uint8_t itmask2 = 0;
    592              uint8_t enablestatus = 0;
    593          
    594              /* Check parameters */
    595              assert_param(IS_UART3_GET_IT_OK(UART3_IT));
   \   00000B A3 0277      CPW       X, #0x277
   \   00000E 27 2A        JREQ      L:??CrossCallReturnLabel_17
   \   000010 A3 0266      CPW       X, #0x266
   \   000013 27 25        JREQ      L:??CrossCallReturnLabel_17
   \   000015 A3 0255      CPW       X, #0x255
   \   000018 27 20        JREQ      L:??CrossCallReturnLabel_17
   \   00001A A3 0244      CPW       X, #0x244
   \   00001D 27 1B        JREQ      L:??CrossCallReturnLabel_17
   \   00001F A3 0235      CPW       X, #0x235
   \   000022 27 16        JREQ      L:??CrossCallReturnLabel_17
   \   000024 A3 0346      CPW       X, #0x346
   \   000027 27 11        JREQ      L:??CrossCallReturnLabel_17
   \   000029 A3 0412      CPW       X, #0x412
   \   00002C 27 0C        JREQ      L:??CrossCallReturnLabel_17
   \   00002E A3 0100      CPW       X, #0x100
   \   000031 27 07        JREQ      L:??CrossCallReturnLabel_17
   \   000033 AE 0253      LDW       X, #0x253
   \   000036 8D ......    CALLF     ?Subroutine0
    596          
    597              /* Get the UART3 IT index*/
    598              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART3_IT & (uint8_t)0x0F));
   \                     ??CrossCallReturnLabel_17:
   \   00003A B6 ..        LD        A, S:?b9
   \   00003C 8D ......    CALLF     ?Subroutine1
    599              /* Get the UART3 IT index*/
    600              itmask1 = (uint8_t)((uint8_t)UART3_IT >> (uint8_t)4);
    601              /* Set the IT mask*/
    602              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \                     ??CrossCallReturnLabel_19:
   \   000040 B6 ..        LD        A, S:?b9
   \   000042 4E           SWAP      A
   \   000043 A4 0F        AND       A, #0xf
   \   000045 5F           CLRW      X
   \   000046 5C           INCW      X
   \   000047 8D ......    CALLF     L:?sll16_x_x_a
   \   00004B 9F           LD        A, XL
    603          
    604              /* Check the status of the specified UART3 pending bit*/
    605              if (UART3_IT == UART3_IT_PE)
   \   00004C BE ..        LDW       X, S:?w4
   \   00004E A3 0100      CPW       X, #0x100
   \   000051 26 0C        JRNE      L:??UART3_GetITStatus_0
    606              {
    607                  /* Get the UART3_ITPENDINGBIT enable bit status*/
    608                  enablestatus = (uint8_t)((uint8_t)UART3->CR1 & itmask2);
   \   000053 C4 5244      AND       A, L:0x5244
   \   000056 B7 ..        LD        S:?b1, A
    609                  /* Check the status of the specified UART3 interrupt*/
    610          
    611                  if (((UART3->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000058 B6 ..        LD        A, S:?b0
   \   00005A C4 5240      AND       A, L:0x5240
   \   00005D 20 20        JRA       ??UART3_GetITStatus_1
    612                  {
    613                      /* Interrupt occurred*/
    614                      pendingbitstatus = SET;
    615                  }
    616                  else
    617                  {
    618                      /* Interrupt not occurred*/
    619                      pendingbitstatus = RESET;
    620                  }
    621              }
    622              else if (UART3_IT == UART3_IT_LBDF)
   \                     ??UART3_GetITStatus_0:
   \   00005F A3 0346      CPW       X, #0x346
   \   000062 26 0C        JRNE      L:??UART3_GetITStatus_2
    623              {
    624                  /* Get the UART3_IT enable bit status*/
    625                  enablestatus = (uint8_t)((uint8_t)UART3->CR4 & itmask2);
   \   000064 C4 5247      AND       A, L:0x5247
   \   000067 B7 ..        LD        S:?b1, A
    626                  /* Check the status of the specified UART3 interrupt*/
    627                  if (((UART3->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
   \   000069 B6 ..        LD        A, S:?b0
   \   00006B C4 5247      AND       A, L:0x5247
   \   00006E 20 0F        JRA       ??UART3_GetITStatus_1
    628                  {
    629                      /* Interrupt occurred*/
    630                      pendingbitstatus = SET;
    631                  }
    632                  else
    633                  {
    634                      /* Interrupt not occurred*/
    635                      pendingbitstatus = RESET;
    636                  }
    637              }
    638              else if (UART3_IT == UART3_IT_LHDF)
   \                     ??UART3_GetITStatus_2:
   \   000070 A3 0412      CPW       X, #0x412
   \   000073 26 10        JRNE      L:??UART3_GetITStatus_3
    639              {
    640                  /* Get the UART3_IT enable bit status*/
    641                  enablestatus = (uint8_t)((uint8_t)UART3->CR6 & itmask2);
   \   000075 C4 5249      AND       A, L:0x5249
   \   000078 B7 ..        LD        S:?b1, A
    642                  /* Check the status of the specified UART3 interrupt*/
    643                  if (((UART3->CR6 & itpos) != (uint8_t)0x00) && enablestatus)
   \   00007A B6 ..        LD        A, S:?b0
   \   00007C C4 5249      AND       A, L:0x5249
   \                     ??UART3_GetITStatus_1:
   \   00007F A1 00        CP        A, #0x0
   \   000081 26 0E        JRNE      L:??UART3_GetITStatus_4
   \   000083 20 14        JRA       L:??UART3_GetITStatus_5
    644                  {
    645                      /* Interrupt occurred*/
    646                      pendingbitstatus = SET;
    647                  }
    648                  else
    649                  {
    650                      /* Interrupt not occurred*/
    651                      pendingbitstatus = RESET;
    652                  }
    653              }
    654              else
    655              {
    656                  /* Get the UART3_IT enable bit status*/
    657                  enablestatus = (uint8_t)((uint8_t)UART3->CR2 & itmask2);
   \                     ??UART3_GetITStatus_3:
   \   000085 C4 5245      AND       A, L:0x5245
   \   000088 B7 ..        LD        S:?b1, A
    658                  /* Check the status of the specified UART3 interrupt*/
    659                  if (((UART3->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   00008A B6 ..        LD        A, S:?b0
   \   00008C C5 5240      BCP       A, L:0x5240
   \   00008F 27 08        JREQ      L:??UART3_GetITStatus_5
   \                     ??UART3_GetITStatus_4:
   \   000091 3D ..        TNZ       S:?b1
   \   000093 27 04        JREQ      L:??UART3_GetITStatus_5
    660                  {
    661                      /* Interrupt occurred*/
    662                      pendingbitstatus = SET;
   \   000095 35 01 ....   MOV       S:?b10, #0x1
    663                  }
    664                  else
    665                  {
    666                      /* Interrupt not occurred*/
    667                      pendingbitstatus = RESET;
    668                  }
    669              }
    670              /* Return the UART3_IT status*/
    671              return  pendingbitstatus;
   \                     ??UART3_GetITStatus_5:
   \   000099 B6 ..        LD        A, S:?b10
   \   00009B 32 ....      POP       S:?b10
   \   00009E AC ......    JPF       L:?epilogue_w4
    672          }
    673          
    674          /**
    675            * @brief  Clears the UART3 pending flags.
    676            * @param  UART3_IT specifies the pending bit to clear
    677            *         This parameter can be one of the following values:
    678            *         - UART3_IT_LBDF:  LIN Break detection interrupt
    679            *         - UART3_IT_LHDF:  LIN Header detection interrupt
    680            *         - UART3_IT_RXNE: Receive Data register not empty interrupt.
    681            *
    682            * @note
    683            *         - PE (Parity error), FE (Framing error), NF (Noise error), 
    684            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    685            *           cleared by software sequence: a read operation to UART3_SR register
    686            *           (UART3_GetITStatus()) followed by a read operation to UART3_DR register 
    687            *           (UART3_ReceiveData8() or UART3_ReceiveData9()).
    688            *             
    689            *         - RXNE pending bit can be also cleared by a read to the UART3_DR register
    690            *           (UART3_ReceiveData8() or UART3_ReceiveData9() ).
    691            *             
    692            *         - TC (Transmit complete) pending bit can be cleared by software 
    693            *           sequence: a read operation to UART3_SR register (UART3_GetITStatus())
    694            *           followed by a write operation to UART3_DR register 
    695            *           (UART3_SendData8()or UART3_SendData9()).
    696            *             
    697            *         - TXE pending bit is cleared only by a write to the UART3_DR register
    698            *           (UART3_SendData8() or UART3_SendData9()).
    699            * @retval None
    700            */

   \                                 In section .far_func.text, align 1
    701          void UART3_ClearITPendingBit(UART3_IT_TypeDef UART3_IT)
    702          {
    703              /* Check the parameters */
    704              assert_param(IS_UART3_CLEAR_IT_OK(UART3_IT));
   \                     UART3_ClearITPendingBit:
   \   000000 A3 0255      CPW       X, #0x255
   \   000003 27 16        JREQ      L:??UART3_ClearITPendingBit_0
   \   000005 A3 0412      CPW       X, #0x412
   \   000008 27 0C        JREQ      L:??CrossCallReturnLabel_18
   \   00000A A3 0346      CPW       X, #0x346
   \   00000D 27 11        JREQ      L:??UART3_ClearITPendingBit_1
   \   00000F AE 02C0      LDW       X, #0x2c0
   \   000012 8D ......    CALLF     ?Subroutine0
    705          
    706              /*Clear the Receive Register Not Empty pending bit */
    707              if (UART3_IT == UART3_IT_RXNE)
    708              {
    709                  UART3->SR = (uint8_t)~(UART3_SR_RXNE);
    710              }
    711              /*Clear the LIN Break Detection pending bit */
    712              else if (UART3_IT == UART3_IT_LBDF)
    713              {
    714                  UART3->CR4 &= (uint8_t)~(UART3_CR4_LBDF);
    715              }
    716              /*Clear the LIN Header Detection pending bit */
    717              else
    718              {
    719                  UART3->CR6 &= (uint8_t)(~UART3_CR6_LHDF);
   \                     ??CrossCallReturnLabel_18:
   \   000016 7213 5249    BRES      L:0x5249, #0x1
    720              }
    721          }
   \   00001A 87           RETF
   \                     ??UART3_ClearITPendingBit_0:
   \   00001B 35 DF 5240   MOV       L:0x5240, #0xdf
   \   00001F 87           RETF
   \                     ??UART3_ClearITPendingBit_1:
   \   000020 7219 5247    BRES      L:0x5247, #0x4
   \   000024 87           RETF

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\SNAP\\\\7896_SNAP\\\\Dev...">`:
   \   000000 43 3A 5C 53  DC8 "C:\\SNAP\\7896_SNAP\\Device_uart3.c"
   \          4E 41 50 5C 
    722          /**
    723            * @}
    724            */
    725            
    726          /**
    727            * @}
    728            */
    729            
    730          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      33  ?<Constant "C:\\SNAP\\7896_SNAP\\Dev...">
      12  ?Subroutine0
      12  ?Subroutine1
       7  ?Subroutine2
      12  ?Subroutine3
      47  UART3_ClearFlag
      37  UART3_ClearITPendingBit
      13  UART3_Cmd
      35  UART3_DeInit
     121  UART3_GetFlagStatus
     162  UART3_GetITStatus
     189  UART3_ITConfig
     338  UART3_Init
      24  UART3_LINBreakDetectionConfig
      24  UART3_LINCmd
     111  UART3_LINConfig
       4  UART3_ReceiveData8
      25  UART3_ReceiveData9
      24  UART3_ReceiverWakeUpCmd
       5  UART3_SendBreak
       4  UART3_SendData8
      21  UART3_SendData9
      36  UART3_SetAddress
      32  UART3_WakeUpConfig

 
 1 295 bytes in section .far_func.text
    33 bytes in section .near.rodata
 
 1 295 bytes of CODE  memory
    33 bytes of CONST memory

Errors: none
Warnings: none
