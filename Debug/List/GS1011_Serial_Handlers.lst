###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             17/Jul/2013  08:20:54 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\GS1011_Se #
#                    rial_Handlers.c                                          #
#    Command line =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\GS1011_Se #
#                    rial_Handlers.c -e --enable_multibytes -On --no_cse      #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o C:\Users\jurban\Documents\GitHub\ #
#                    7896_SNAP_100\Debug\Obj\ --dlib_config "C:\Program       #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8S007 -lC                #
#                    C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\ -I .\ --no_system_include --require_prototypes        #
#                    --vregs 16                                               #
#    List file    =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\GS1011_Serial_Handlers.lst                             #
#    Object file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Obj #
#                    \GS1011_Serial_Handlers.o                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jurban\Documents\GitHub\7896_SNAP_100\GS1011_Serial_Handlers.c
      1          /**
      2            ******************************************************************************
      3            * UART 1 is the GS1011 UART
      4            * @file    stm8s_uart1.c
      5            * @author  MCD Application Team
      6            * @version V2.1.0
      7            * @date    18-November-2011
      8            * @brief   This file contains all the functions for the UART1 peripheral.
      9            ******************************************************************************
     10              
     11            ******************************************************************************
     12            *                                                                            *
     13            *  This file contains the Initialization, and ISR routines for the GS1011    *
     14            *     The initialization sets the port to:                                   *
     15            *             9600 baud, 8 bits, no parity, 1 stop                           *
     16            *     The RX ISR gets the resposes from the GS1011                           *
     17            *     The TX ISR sends commands and device updates to the GS1011             *
     18            *                                                                            *
     19            *     The update data is formatted after it comes in from the device.        *
     20            *     The ACK message is sent if the status:good is returned from the GS1011 *
     21            *                                                                            *
     22            *                                                                            *
     23            *****************************************************************************/
     24          
     25          /* Includes ------------------------------------------------------------------*/
     26          #include "stm8s_uart1.h"
     27          #include "SNAP_Defines.h"
     28          
     29          /* definitions ---------------------------------------------------------------*/
     30          void InitGS1011UART(void);
     31          void Handle_GS1011_State(void);
     32          /*******************************   state machine handlers ************/
     33          void Get_any_ResponseFromGS1011(char bufr[]);
     34          void Reset_Network_Access(void);
     35          void Send_Website_Update(void);
     36          void Send_DNSLOOKUP_Message(void);
     37          void GS1011_Received_Data_Handler(void);
     38          void Sending_GS1011_Data_Handler(void);
     39          void Start_GS1011_Send(void);
     40          void GetNetworkStatusFromGS1011 (void);
     41          void SetupGS1011Association(void);
     42          void SendUpdateToWebsite (void);
     43          void Send_ConnectionType_CONF11_Message(void);
     44          void Send_Keep_Alive_Message(void);
     45          
     46          void Reset_Network_Access(void);
     47          void Set_FactoryReset(void);
     48          void ResetAdaptor(void);
     49          void DisassociateWeb(void);
     50          void SetupSendInitialIPAddress(void);
     51          
     52          void SendWM_2(void);
     53          void SendWA_Init(void);
     54          void setDHCPSRVR(void);
     55          void SetProvisioning(void);
     56          void SendShutEchoOff(void);
     57          extern void Assemble_Process_Send_Device_Website_Update(void);
     58          
     59          /*******************************  ; state machine handlers end ************/
     60          void Send_ACK_Message(void);
     61          void Send_Request_Message(void);
     62          void Send_Request1_Message(void);
     63          void Send_ConfiguringAdaptor_Message(void);
     64          void Send_AdaptorReady_Message(void);
     65          void Copy_Stock_Send_Message(char strng[]);
     66          void GetResponseFromGS1011(void);
     67          void GetResetResponseFromGS1011(void);
     68          void GetNSTAT_ResponseFromGS1011(void);
     69          void SendYouThereMessageToGS1011(void);
     70          void Are_You_There_with_Response(void);
     71          void InitializeGS1011Buffer(void);
     72          /* external definitions ------------------------------------------------------*/
     73          /* GS1011 DATA */
     74          extern char SNAP_State;
     75          extern char CID_Value;
     76          extern char Send_Update_State;
     77          extern int Found_String_At_Byte;
     78          extern char EEWRTimout;
     79          extern char GS1011_Rcvr_Timeout;
     80          extern char GS1011_State;
     81          extern char GS1011_State_State;
     82          extern u8 GS1011_String_Found;
     83          extern char GS1011_Received_Response_Flag;
     84          extern unsigned char GS1011_Xmit_Char;
     85          extern unsigned char GS1011_Xmit_Char_Count;
     86          extern void Start_GS1011_Send(void);
     87          extern char GS1011_Xmit_Pointer;
     88          extern char GS1011_Xmit_Buffer[];
     89          extern unsigned char GS1011_Xmit_Char_Count;
     90          extern char CopyBuffer (char dest[], char srce[]);
     91          extern void CopyBufferGS1011 (char srce[]);
     92          extern void FillBuffer (char bufr[],char filchr, char cntr);
     93          extern char GS1011_Rcvr_EOM_Timer;
     94          extern char GS1011_Rcvr_Char;
     95          extern u16 GS1011_Rcvr_InPtr;
     96          extern u16 GS1011_Rcvr_OutPtr;
     97          extern u16 GS1011_Rvcr_Count;
     98          extern u16 GS1011_Rcvr_Pointer;
     99          extern char website_IP_Address[];
    100          extern char GS1011_Receiver_Buffer[];
    101          extern char SWReset_Response[];
    102          extern char NWCONN_Response[];
    103          extern char Device_Serial_number[];
    104          
    105          extern char Device_Update_Data_count;
    106          extern char Website_Update_Data_Buffer[];
    107          extern char Dummy_update[];
    108          extern char Cigar_update[];
    109          extern char Good_Response[];
    110          extern char SetSerialNumberasAccessPointHeader[];
    111          extern char SetSerialNumberasAccessPointTail[];
    112          extern char ACKMessage[];
    113          extern char goodmsg[];
    114          extern char updatemsg[];
    115          extern char ACK_message_response_number;
    116          extern char Packet_Data_Buffer[];
    117          extern char PacketCount;
    118          
    119          void Add_String_to_GS1011_Buffer ( char *srce);
    120          void Add_String_to_GS1011_BufferCounted ( char srce[], char cnt);
    121          
    122          void CopyBufferGS1011(char srce[]);
    123          
    124          
    125          /* external stock message definitions ----------------------------------------*/
    126          extern char GetNSTATMessage[];
    127          extern char DNSLOOKUP_Message[];
    128          extern char WSTATECONNECTEDmsg[];
    129          extern char OKAYmsg[];
    130          extern char IPmsg[];
    131          /*  Reset GS1011 messages */
    132          extern char YouThereMessage[];
    133          extern char ForceFactoryResetMessage[];
    134          extern char ClearW0Message[];
    135          extern char ClearW1Message[];
    136          extern char ClearY0Message[];
    137          extern char ResetAdaptorMessage[];
    138          extern char ShutOffEchoMessage[];
    139          extern char DisassociateMessage[];
    140          extern void FindGS1011Chars(char chrstrng[]);
    141          /* setup GS1011 to connect to WIFI */
    142          extern char SetInitialIPAddressMessage[];
    143          extern char SetWM2Message[];
    144          extern char SetNDHCPMessage;
    145          extern char SetDHCPSRVRMessage[];
    146          extern char SetWEBPROVMessage[];
    147          extern char GetProfileMessage;
    148          extern char KeepAlive_CONF3_Message[];
    149          /*  sending update messages  */
    150          extern char ConnectionType_CONF11_message[];
    151          extern char SetConnectionType;
    152          extern char SendKeepAliveMessage;
    153          extern char OpenMarsConnectionHeader;   /*add ip Address*/
    154          extern char SendtoWebsiteHeader[];   /*add CID, and status*/
    155          extern char SendtoWebsiteHeader1[];
    156          extern char HTTPOPEN_FULL_MESSAGE[];
    157          /* sending update state maching*/ 
    158          void Get_Website_IP_address(void);
    159          void Set_Mars_as_Website(void);
    160          void Set_Keep_Alive(void);
    161          void  HTTPOPEN_Get_CID(void);
    162          void  Convert_update_and_Send(void);
    163          void  Get_Website_Response_and_Respond(void);
    164          void Make_Send_Update_to_website(void);
    165          void Send_HTTP_Open_Message(void); 
    166          void GetWebsite_ResponseFromGS1011(void);
    167          /* external functions */
    168          extern void Add_Char_to_GS1011_Buffer(char chr);
    169          extern char CountGS1011Chars(void);
    170          extern char CountChars(char s[]);
    171          extern int Add_Char_to_Buffer (char *bufr,int ptr,char chr);
    172          void copy_buffer_from_offset_to_terminator(char srcebufr[],char destbufr[], int ofst, char trm);
    173          
    174          /*****************************************************************************
    175           ****  SendShutEchoOff - used in GET_WEBSITE_IP_ADDRESS_STATE             ****
    176           ****                                                                     ****
    177           ****  GET_WEBSITE_IP_ADDRESS_STATE checks if there was an error and      ****
    178           ****       resends if necessary                                          ****
    179           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    180          void SendShutEchoOff(void){
    181          Copy_Stock_Send_Message(ShutOffEchoMessage);
   \                     SendShutEchoOff:
   \   000000 AE ....      LDW       X, #ShutOffEchoMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    182          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??SendShutEchoOff_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??SendShutEchoOff_1
    183          {
    184          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??SendShutEchoOff_0
    185          }
    186          }
   \                     ??SendShutEchoOff_1:
   \   000014 87           RETF
    187          /*****************************************************************************
    188           ****   GetNetworkStatusFromGS1011  -  GET_GS1011_NETWORK_STATE           ****
    189           ****                                                                     ****
    190           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    191          void GetNetworkStatusFromGS1011 (void){
    192            if (GS1011_Received_Response_Flag == 0x00){
   \                     GetNetworkStatusFromGS1011:
   \   000000 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   000003 A1 00        CP        A, #0x0
   \   000005 26 19        JRNE      L:??GetNetworkStatusFromGS1011_0
    193              InitializeGS1011Buffer();
   \   000007 8D ......    CALLF     InitializeGS1011Buffer
    194              CopyBufferGS1011(GetNSTATMessage);  
   \   00000B AE ....      LDW       X, #GetNSTATMessage
   \   00000E 8D ......    CALLF     CopyBufferGS1011
    195              Start_GS1011_Send();                                /* kickstart the xmitter*/
   \   000012 8D ......    CALLF     Start_GS1011_Send
    196              GS1011_Received_Response_Flag = 0x01;
   \   000016 35 01 ....   MOV       L:GS1011_Received_Response_Flag, #0x1
    197              GetNSTAT_ResponseFromGS1011();
   \   00001A 8D ......    CALLF     GetNSTAT_ResponseFromGS1011
   \   00001E 20 04        JRA       L:??GetNetworkStatusFromGS1011_1
    198             }
    199            else {
    200              GetNSTAT_ResponseFromGS1011();
   \                     ??GetNetworkStatusFromGS1011_0:
   \   000020 8D ......    CALLF     GetNSTAT_ResponseFromGS1011
    201            }
    202            
    203          }
   \                     ??GetNetworkStatusFromGS1011_1:
   \   000024 87           RETF
    204          /*****************************************************************************
    205           ****   GetNSTAT_ResponseFromGS1011  -  GET_GS1011_NETWORK_STATE           ****
    206           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    207          void GetNSTAT_ResponseFromGS1011(void){
    208            if (GS1011_Rcvr_Timeout == 1) {
   \                     GetNSTAT_ResponseFromGS1011:
   \   000000 C6 ....      LD        A, L:GS1011_Rcvr_Timeout
   \   000003 A1 01        CP        A, #0x1
   \   000005 26 2E        JRNE      L:??GetNSTAT_ResponseFromGS1011_0
    209              FindGS1011Chars(OKAYmsg);
   \   000007 AE ....      LDW       X, #OKAYmsg
   \   00000A 8D ......    CALLF     FindGS1011Chars
    210                
    211              if (GS1011_String_Found == 1){
   \   00000E C6 ....      LD        A, L:GS1011_String_Found
   \   000011 A1 01        CP        A, #0x1
   \   000013 26 20        JRNE      L:??GetNSTAT_ResponseFromGS1011_0
    212                  FindGS1011Chars(WSTATECONNECTEDmsg);
   \   000015 AE ....      LDW       X, #WSTATECONNECTEDmsg
   \   000018 8D ......    CALLF     FindGS1011Chars
    213                  if (GS1011_String_Found == 1){
   \   00001C C6 ....      LD        A, L:GS1011_String_Found
   \   00001F A1 01        CP        A, #0x1
   \   000021 26 0A        JRNE      L:??GetNSTAT_ResponseFromGS1011_1
    214                    Send_AdaptorReady_Message();
   \   000023 8D ......    CALLF     Send_AdaptorReady_Message
    215                    SNAP_State = GET_WEBSITE_IP_ADDRESS_STATE;
   \   000027 35 04 ....   MOV       L:SNAP_State, #0x4
   \   00002B 20 08        JRA       L:??GetNSTAT_ResponseFromGS1011_0
    216                    }
    217                  else {
    218                     Send_ConfiguringAdaptor_Message();
   \                     ??GetNSTAT_ResponseFromGS1011_1:
   \   00002D 8D ......    CALLF     Send_ConfiguringAdaptor_Message
    219                     SNAP_State = RESET_NETWORK_ACCESS_STATE;
   \   000031 35 0A ....   MOV       L:SNAP_State, #0xa
    220                  }
    221              }
    222            }
    223          }
   \                     ??GetNSTAT_ResponseFromGS1011_0:
   \   000035 87           RETF
    224          /*****************************************************************************
    225           ****   Get_Website_IP_address  -  GET_WEBSITE_IP_ADDRESS_STATE                             ****
    226           ****                                                                     ****
    227           ****  gets the website ip address                                        ****
    228           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    229          void Get_Website_IP_address(void){
    230            SendShutEchoOff();
   \                     Get_Website_IP_address:
   \   000000 8D ......    CALLF     SendShutEchoOff
    231            if (GS1011_String_Found != 1){
   \   000004 C6 ....      LD        A, L:GS1011_String_Found
   \   000007 A1 01        CP        A, #0x1
   \   000009 27 04        JREQ      L:??Get_Website_IP_address_0
    232              SendShutEchoOff();
   \   00000B 8D ......    CALLF     SendShutEchoOff
    233            }
    234            Copy_Stock_Send_Message(DNSLOOKUP_Message);
   \                     ??Get_Website_IP_address_0:
   \   00000F AE ....      LDW       X, #DNSLOOKUP_Message
   \   000012 8D ......    CALLF     Copy_Stock_Send_Message
    235          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Get_Website_IP_address_1:
   \   000016 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   000019 A1 01        CP        A, #0x1
   \   00001B 26 09        JRNE      L:??Get_Website_IP_address_2
    236          {
    237          Get_any_ResponseFromGS1011(IPmsg);
   \   00001D AE ....      LDW       X, #IPmsg
   \   000020 8D ......    CALLF     Get_any_ResponseFromGS1011
   \   000024 20 F0        JRA       L:??Get_Website_IP_address_1
    238          }
    239          if (GS1011_String_Found == 1){
   \                     ??Get_Website_IP_address_2:
   \   000026 C6 ....      LD        A, L:GS1011_String_Found
   \   000029 A1 01        CP        A, #0x1
   \   00002B 26 27        JRNE      L:??Get_Website_IP_address_3
    240            FillBuffer(website_IP_Address,0x00,15);
   \   00002D 35 0F ....   MOV       S:?b0, #0xf
   \   000031 4F           CLR       A
   \   000032 AE ....      LDW       X, #website_IP_Address
   \   000035 8D ......    CALLF     FillBuffer
    241            Found_String_At_Byte += 3;
   \   000039 CE ....      LDW       X, L:Found_String_At_Byte
   \   00003C 1C 0003      ADDW      X, #0x3
   \   00003F CF ....      LDW       L:Found_String_At_Byte, X
    242            copy_buffer_from_offset_to_terminator(GS1011_Receiver_Buffer, website_IP_Address, Found_String_At_Byte, CR);
   \   000042 A6 0D        LD        A, #0xd
   \   000044 CE ....      LDW       X, L:Found_String_At_Byte
   \   000047 BF ..        LDW       S:?w0, X
   \   000049 90AE ....    LDW       Y, #website_IP_Address
   \   00004D AE ....      LDW       X, #GS1011_Receiver_Buffer
   \   000050 8D ......    CALLF     copy_buffer_from_offset_to_terminator
    243            }
    244            SNAP_State = SET_MARS_AS_WEBSITE_STATE;
   \                     ??Get_Website_IP_address_3:
   \   000054 35 05 ....   MOV       L:SNAP_State, #0x5
    245          } 
   \   000058 87           RETF
    246            
    247            
    248          /*****************************************************************************
    249           ****   Set_Mars_as_Website  -  SET_MARS_AS_WEBSITE_STATE                             ****
    250           ****                                                                     ****
    251           ****  gets the website ip address                                        ****
    252           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    253          void Set_Mars_as_Website(void){
    254             Copy_Stock_Send_Message(ConnectionType_CONF11_message);
   \                     Set_Mars_as_Website:
   \   000000 AE ....      LDW       X, #ConnectionType_CONF11_message
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    255          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Set_Mars_as_Website_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??Set_Mars_as_Website_1
    256          {
    257          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??Set_Mars_as_Website_0
    258          }
    259          if (GS1011_String_Found == 1){
   \                     ??Set_Mars_as_Website_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??Set_Mars_as_Website_2
    260            SNAP_State = SET_KEEP_ALIVE_STATE;
   \   00001B 35 06 ....   MOV       L:SNAP_State, #0x6
    261            }
    262          }
   \                     ??Set_Mars_as_Website_2:
   \   00001F 87           RETF
    263          /*****************************************************************************
    264           ****   Set_Keep_Alive  -  SET_KEEP_ALIVE_STATE                                ****
    265           ****                                                                     ****
    266           ****  GS1011 responds okay                                               ****
    267           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    268          void Set_Keep_Alive(void){
    269             Copy_Stock_Send_Message(KeepAlive_CONF3_Message);
   \                     Set_Keep_Alive:
   \   000000 AE ....      LDW       X, #KeepAlive_CONF3_Message
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    270          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Set_Keep_Alive_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??Set_Keep_Alive_1
    271          {
    272          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??Set_Keep_Alive_0
    273          }
    274          if (GS1011_String_Found == 1){
   \                     ??Set_Keep_Alive_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??Set_Keep_Alive_2
    275            SNAP_State = HTTPOPEN_GET_CID_STATE;
   \   00001B 35 07 ....   MOV       L:SNAP_State, #0x7
    276            }
    277          }
   \                     ??Set_Keep_Alive_2:
   \   00001F 87           RETF
    278          /*****************************************************************************
    279           ****   Set_Mars_as_Website  -  HTTPOPEN_GET_CID_STATE                               ****
    280           ****                                                                     ****
    281           ****  GS1011 responds okay                                               ****
    282           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    283            void  HTTPOPEN_Get_CID(void){
    284             Copy_Stock_Send_Message(HTTPOPEN_FULL_MESSAGE);
   \                     HTTPOPEN_Get_CID:
   \   000000 AE ....      LDW       X, #HTTPOPEN_FULL_MESSAGE
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    285          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??HTTPOPEN_Get_CID_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??HTTPOPEN_Get_CID_1
    286          {
    287          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??HTTPOPEN_Get_CID_0
    288          }
    289          if (GS1011_String_Found == 1){
   \                     ??HTTPOPEN_Get_CID_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 0A        JRNE      L:??HTTPOPEN_Get_CID_2
    290            CID_Value = GS1011_Receiver_Buffer[2];
   \   00001B C6 ....      LD        A, L:GS1011_Receiver_Buffer + 2
   \   00001E C7 ....      LD        L:CID_Value, A
    291            SNAP_State = CONVERT_DEVICE_DATA_AND_SEND_STATE;
   \   000021 35 08 ....   MOV       L:SNAP_State, #0x8
    292            }
    293          } 
   \                     ??HTTPOPEN_Get_CID_2:
   \   000025 87           RETF
    294          /*****************************************************************************
    295           ****   Convert_update_and_Send  - CONVERT_DEVICE_DATA_AND_SEND_STATE     ****
    296           ****                                                                     ****
    297           ****  GS1011 responds okay                                               ****
    298           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    299          void  Convert_update_and_Send(void){
    300             InitializeGS1011Buffer();
   \                     Convert_update_and_Send:
   \   000000 8D ......    CALLF     InitializeGS1011Buffer
    301             CopyBufferGS1011(SendtoWebsiteHeader);    /* gs1011 httpsend header */
   \   000004 AE ....      LDW       X, #SendtoWebsiteHeader
   \   000007 8D ......    CALLF     CopyBufferGS1011
    302             Add_Char_to_GS1011_Buffer(CID_Value);     /* add the connection ID */
   \   00000B C6 ....      LD        A, L:CID_Value
   \   00000E 8D ......    CALLF     Add_Char_to_GS1011_Buffer
    303             Add_String_to_GS1011_Buffer(SendtoWebsiteHeader1); /* more gs1011 header */
   \   000012 AE ....      LDW       X, #SendtoWebsiteHeader1
   \   000015 8D ......    CALLF     Add_String_to_GS1011_Buffer
    304             Add_String_to_GS1011_BufferCounted(Packet_Data_Buffer,PacketCount); /* update data*/
   \   000019 C6 ....      LD        A, L:PacketCount
   \   00001C AE ....      LDW       X, #Packet_Data_Buffer
   \   00001F 8D ......    CALLF     Add_String_to_GS1011_BufferCounted
    305             Start_GS1011_Send();
   \   000023 8D ......    CALLF     Start_GS1011_Send
    306             GS1011_Received_Response_Flag = 0x01;
   \   000027 35 01 ....   MOV       L:GS1011_Received_Response_Flag, #0x1
    307          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Convert_update_and_Send_0:
   \   00002B C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00002E A1 01        CP        A, #0x1
   \   000030 26 09        JRNE      L:??Convert_update_and_Send_1
    308          {
    309          /*Get_any_ResponseFromGS1011(Good_Response);*/
    310          Get_any_ResponseFromGS1011(OKAYmsg);
   \   000032 AE ....      LDW       X, #OKAYmsg
   \   000035 8D ......    CALLF     Get_any_ResponseFromGS1011
   \   000039 20 F0        JRA       L:??Convert_update_and_Send_0
    311          }
    312          
    313          if (GS1011_String_Found == 1){
   \                     ??Convert_update_and_Send_1:
   \   00003B C6 ....      LD        A, L:GS1011_String_Found
   \   00003E A1 01        CP        A, #0x1
   \   000040 26 2E        JRNE      L:??Convert_update_and_Send_2
    314                FindGS1011Chars(goodmsg);   /* check for status good */
   \   000042 AE ....      LDW       X, #goodmsg
   \   000045 8D ......    CALLF     FindGS1011Chars
    315                if (GS1011_String_Found == 1){ /* if status good send ACK message */
   \   000049 C6 ....      LD        A, L:GS1011_String_Found
   \   00004C A1 01        CP        A, #0x1
   \   00004E 26 0A        JRNE      L:??Convert_update_and_Send_3
    316                  Send_ACK_Message();          
   \   000050 8D ......    CALLF     Send_ACK_Message
    317                  SNAP_State = WAIT_FOR_UPDATE_STATE; }
   \   000054 35 01 ....   MOV       L:SNAP_State, #0x1
   \   000058 20 16        JRA       L:??Convert_update_and_Send_2
    318                else{
    319                  FindGS1011Chars(updatemsg); /* not good, check for status update */
   \                     ??Convert_update_and_Send_3:
   \   00005A AE ....      LDW       X, #updatemsg
   \   00005D 8D ......    CALLF     FindGS1011Chars
    320                  if (GS1011_String_Found == 1)
   \   000061 C6 ....      LD        A, L:GS1011_String_Found
   \   000064 A1 01        CP        A, #0x1
   \   000066 26 04        JRNE      L:??Convert_update_and_Send_4
    321                    Get_Website_Response_and_Respond(); /* get website request and send it to device*/
   \   000068 8D ......    CALLF     Get_Website_Response_and_Respond
    322                    SNAP_State = WAIT_FOR_UPDATE_STATE;
   \                     ??Convert_update_and_Send_4:
   \   00006C 35 01 ....   MOV       L:SNAP_State, #0x1
    323                }
    324             }
    325          }
   \                     ??Convert_update_and_Send_2:
   \   000070 87           RETF
    326          /*****************************************************************************
    327           ****   Get_Website_Response_and_Respond- GET_WEBSITE_RESPONSE_SEND_DEVICE_STATE                            ****
    328           ****                                                                     ****
    329           ****  gets the website ip address                                        ****
    330           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    331           void  Get_Website_Response_and_Respond(void){
   \                     Get_Website_Response_and_Respond:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 3B ....      PUSH      S:?b10
    332           int updteptr;
    333           char webptr;                   /* when the message is found the start of the found is saved*/
    334              updteptr = CountChars(goodmsg);  /* get the good message count */
   \   000007 AE ....      LDW       X, #goodmsg
   \   00000A 8D ......    CALLF     CountChars
   \   00000E 5F           CLRW      X
   \   00000F 97           LD        XL, A
   \   000010 BF ..        LDW       S:?w4, X
    335              updteptr += Found_String_At_Byte; /*add it to the found char point*/
   \   000012 BE ..        LDW       X, S:?w4
   \   000014 72BB ....    ADDW      X, L:Found_String_At_Byte
   \   000018 BF ..        LDW       S:?w4, X
    336              webptr = 0x00;
   \   00001A 4F           CLR       A
   \   00001B B7 ..        LD        S:?b10, A
    337              Website_Update_Data_Buffer[webptr] = 'R';
   \   00001D 5F           CLRW      X
   \   00001E 41           EXG       A, XL
   \   00001F B6 ..        LD        A, S:?b10
   \   000021 41           EXG       A, XL
   \   000022 A6 52        LD        A, #0x52
   \   000024 D7 ....      LD        (L:Website_Update_Data_Buffer,X), A
    338              webptr++;
   \   000027 B6 ..        LD        A, S:?b10
   \   000029 AB 01        ADD       A, #0x1
   \   00002B B7 ..        LD        S:?b10, A
    339              while (GS1011_Receiver_Buffer[updteptr] != '"'){ /*copy the request to a buffer*/
   \                     ??Get_Website_Response_and_Respond_0:
   \   00002D A6 22        LD        A, #0x22
   \   00002F BE ..        LDW       X, S:?w4
   \   000031 D1 ....      CP        A, (L:GS1011_Receiver_Buffer,X)
   \   000034 27 1F        JREQ      L:??Get_Website_Response_and_Respond_1
    340                Website_Update_Data_Buffer[webptr] = GS1011_Receiver_Buffer[updteptr];
   \   000036 BE ..        LDW       X, S:?w4
   \   000038 D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   00003B 5F           CLRW      X
   \   00003C 41           EXG       A, XL
   \   00003D B6 ..        LD        A, S:?b10
   \   00003F 41           EXG       A, XL
   \   000040 D7 ....      LD        (L:Website_Update_Data_Buffer,X), A
    341                Device_Update_Data_count = webptr;
   \   000043 B6 ..        LD        A, S:?b10
   \   000045 C7 ....      LD        L:Device_Update_Data_count, A
    342                webptr++;
   \   000048 B6 ..        LD        A, S:?b10
   \   00004A AB 01        ADD       A, #0x1
   \   00004C B7 ..        LD        S:?b10, A
    343                updteptr++;
   \   00004E BE ..        LDW       X, S:?w4
   \   000050 5C           INCW      X
   \   000051 BF ..        LDW       S:?w4, X
   \   000053 20 D8        JRA       L:??Get_Website_Response_and_Respond_0
    344              }
    345              Assemble_Process_Send_Device_Website_Update(); /*make a response buffer using the found data*/
   \                     ??Get_Website_Response_and_Respond_1:
   \   000055 8D ......    CALLF     Assemble_Process_Send_Device_Website_Update
    346            }
   \   000059 32 ....      POP       S:?b10
   \   00005C AC ......    JPF       L:?epilogue_w4
    347           
    348          /*****************************************************************************
    349           ****   Reset_Network_Access  -  STATE 10 -  18                                 ****
    350           ****                                                                     ****
    351           **** sends an AT\r\n and waits for an OK or ERROR                        ****
    352           ****                                                                     ****
    353           ******************************************************************************/
    354          /*****************************************************************************/
    355          /*  provisioning routines */
    356          /*****************************************************************************/
    357          
    358          /*****************************************************************************
    359           ****   Reset_Network_Access -  RESET_NETWORK_ACCESS_STATE                 ****
    360           ****  prepares for setup                                                  ****
    361           ****  this is done if the nstat response WSTATE = NOT CONNECTED           ****
    362           ****  reset and clear the adaptor before provisioning                     ****
    363           ******************************************************************************/

   \                                 In section .far_func.text, align 1
    364          void Reset_Network_Access(void){
    365             Copy_Stock_Send_Message(ForceFactoryResetMessage);
   \                     Reset_Network_Access:
   \   000000 AE ....      LDW       X, #ForceFactoryResetMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    366          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Reset_Network_Access_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??Reset_Network_Access_1
    367          {
    368          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??Reset_Network_Access_0
    369          }
    370          if (GS1011_String_Found == 1){
   \                     ??Reset_Network_Access_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??Reset_Network_Access_2
    371            SNAP_State = SET_FACTORY_RESET_STATE;
   \   00001B 35 0B ....   MOV       L:SNAP_State, #0xb
    372            }
    373           }
   \                     ??Reset_Network_Access_2:
   \   00001F 87           RETF
    374          /*****************************************************************************
    375           ****   Set_FactoryReset  -  SET_FACTORY_RESET_STATE                      ****
    376           ****  clears all old parameters                                          ****
    377           ****  MUST BE DONE BEFORE THE GS1011 CAN BE CONNECTED TO NEW ACCESS      ****
    378           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    379          void Set_FactoryReset(void){
    380             Copy_Stock_Send_Message(ClearW0Message);
   \                     Set_FactoryReset:
   \   000000 AE ....      LDW       X, #ClearW0Message
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    381          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Set_FactoryReset_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??Set_FactoryReset_1
    382          {
    383          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??Set_FactoryReset_0
    384          }
    385          if (GS1011_String_Found == 1){
    386            }
    387             Copy_Stock_Send_Message(ClearW1Message);
   \                     ??Set_FactoryReset_1:
   \   000014 AE ....      LDW       X, #ClearW1Message
   \   000017 8D ......    CALLF     Copy_Stock_Send_Message
    388          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Set_FactoryReset_2:
   \   00001B C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00001E A1 01        CP        A, #0x1
   \   000020 26 06        JRNE      L:??Set_FactoryReset_3
    389          {
    390          GetResponseFromGS1011();
   \   000022 8D ......    CALLF     GetResponseFromGS1011
   \   000026 20 F3        JRA       L:??Set_FactoryReset_2
    391          }
    392          if (GS1011_String_Found == 1){
    393            }
    394             Copy_Stock_Send_Message(ClearY0Message);
   \                     ??Set_FactoryReset_3:
   \   000028 AE ....      LDW       X, #ClearY0Message
   \   00002B 8D ......    CALLF     Copy_Stock_Send_Message
    395          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??Set_FactoryReset_4:
   \   00002F C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   000032 A1 01        CP        A, #0x1
   \   000034 26 06        JRNE      L:??Set_FactoryReset_5
    396          {
    397          GetResponseFromGS1011();
   \   000036 8D ......    CALLF     GetResponseFromGS1011
   \   00003A 20 F3        JRA       L:??Set_FactoryReset_4
    398          }
    399          if (GS1011_String_Found == 1){
   \                     ??Set_FactoryReset_5:
   \   00003C C6 ....      LD        A, L:GS1011_String_Found
   \   00003F A1 01        CP        A, #0x1
   \   000041 26 04        JRNE      L:??Set_FactoryReset_6
    400            SNAP_State = RESET_GS1011_ADAPTOR_STATE;
   \   000043 35 0C ....   MOV       L:SNAP_State, #0xc
    401            }
    402          }
   \                     ??Set_FactoryReset_6:
   \   000047 87           RETF
    403          /*****************************************************************************
    404           ****   ResetAdaptor  - RESET_GS1011_ADAPTOR_STATE                        ****
    405           ****  clears all old parameters                                          ****
    406           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    407          void ResetAdaptor(void){
    408             Copy_Stock_Send_Message(ResetAdaptorMessage);
   \                     ResetAdaptor:
   \   000000 AE ....      LDW       X, #ResetAdaptorMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    409          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??ResetAdaptor_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??ResetAdaptor_1
    410          {
    411          GetResetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResetResponseFromGS1011
   \   000012 20 F3        JRA       L:??ResetAdaptor_0
    412          }
    413          
    414          if (GS1011_String_Found == 1){
   \                     ??ResetAdaptor_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??ResetAdaptor_2
    415            SNAP_State = DISACSSOCIATE_WEB_ACCESS_STATE;
   \   00001B 35 0D ....   MOV       L:SNAP_State, #0xd
    416            }
    417          }
   \                     ??ResetAdaptor_2:
   \   00001F 87           RETF
    418          /*****************************************************************************
    419           ****   DisassociateWeb  -  DISACSSOCIATE_WEB_ACCESS_STATE                ****
    420           ****  MAKES SURE THE OLD WEB ACCESS POINT IS DISCONNECTED                ****
    421           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    422          void DisassociateWeb(void){
    423             Copy_Stock_Send_Message(DisassociateMessage);
   \                     DisassociateWeb:
   \   000000 AE ....      LDW       X, #DisassociateMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    424          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??DisassociateWeb_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??DisassociateWeb_1
    425          {
    426          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??DisassociateWeb_0
    427          }
    428          if (GS1011_String_Found == 1){
   \                     ??DisassociateWeb_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??DisassociateWeb_2
    429            SNAP_State = SET_INITIAL_IPADDRESS_STATE;
   \   00001B 35 0E ....   MOV       L:SNAP_State, #0xe
    430            }
    431          }
   \                     ??DisassociateWeb_2:
   \   00001F 87           RETF
    432          /*****************************************************************************
    433           ****   SetupSendInitialIPAddress  -  SET_INITIAL_IPADDRESS_STATE         ****
    434           ****  SETS AN IP ADDRESS OF 192.168.1.1 (Will be changed by DHCP command)****
    435           ****        after WEBPROV command                                        ****
    436           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    437          void SetupSendInitialIPAddress(void){
    438             Copy_Stock_Send_Message(SetInitialIPAddressMessage);
   \                     SetupSendInitialIPAddress:
   \   000000 AE ....      LDW       X, #SetInitialIPAddressMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    439          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??SetupSendInitialIPAddress_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??SetupSendInitialIPAddress_1
    440          {
    441          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??SetupSendInitialIPAddress_0
    442          }
    443          if (GS1011_String_Found == 1){
   \                     ??SetupSendInitialIPAddress_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??SetupSendInitialIPAddress_2
    444            SNAP_State = SET_WEB_MODE_TO_LIMITED_STATE;
   \   00001B 35 0F ....   MOV       L:SNAP_State, #0xf
    445            }
    446          }
   \                     ??SetupSendInitialIPAddress_2:
   \   00001F 87           RETF
    447          /*****************************************************************************
    448           ****   SendWM_2  -  SET_WEB_MODE_TO_LIMITED_STATE                        ****
    449           ****  clears all old parameters                                          ****
    450           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    451          void SendWM_2(void){
    452             Copy_Stock_Send_Message(SetWM2Message);
   \                     SendWM_2:
   \   000000 AE ....      LDW       X, #SetWM2Message
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    453          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??SendWM_2_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??SendWM_2_1
    454          {
    455          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??SendWM_2_0
    456          }
    457          if (GS1011_String_Found == 1){
   \                     ??SendWM_2_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??SendWM_2_2
    458            SNAP_State = INIT_WEB_ACCESS_STATE;
   \   00001B 35 10 ....   MOV       L:SNAP_State, #0x10
    459            }
    460          }
   \                     ??SendWM_2_2:
   \   00001F 87           RETF
    461          /*****************************************************************************
    462           ****   SendWA_Init  - INIT_WEB_ACCESS_STATE                              ****
    463           ****  clears all old parameters                                          ****
    464           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    465          void SendWA_Init(void){
    466             InitializeGS1011Buffer();
   \                     SendWA_Init:
   \   000000 8D ......    CALLF     InitializeGS1011Buffer
    467             CopyBufferGS1011(SetSerialNumberasAccessPointHeader);
   \   000004 AE ....      LDW       X, #SetSerialNumberasAccessPointHeader
   \   000007 8D ......    CALLF     CopyBufferGS1011
    468             Add_String_to_GS1011_BufferCounted(Device_Serial_number,15);
   \   00000B A6 0F        LD        A, #0xf
   \   00000D AE ....      LDW       X, #Device_Serial_number
   \   000010 8D ......    CALLF     Add_String_to_GS1011_BufferCounted
    469             Add_String_to_GS1011_Buffer(SetSerialNumberasAccessPointTail);
   \   000014 AE ....      LDW       X, #SetSerialNumberasAccessPointTail
   \   000017 8D ......    CALLF     Add_String_to_GS1011_Buffer
    470             Start_GS1011_Send();
   \   00001B 8D ......    CALLF     Start_GS1011_Send
    471             GS1011_Received_Response_Flag = 0x01;
   \   00001F 35 01 ....   MOV       L:GS1011_Received_Response_Flag, #0x1
    472          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??SendWA_Init_0:
   \   000023 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   000026 A1 01        CP        A, #0x1
   \   000028 26 06        JRNE      L:??SendWA_Init_1
    473          {
    474          GetResponseFromGS1011();
   \   00002A 8D ......    CALLF     GetResponseFromGS1011
   \   00002E 20 F3        JRA       L:??SendWA_Init_0
    475          }
    476          if (GS1011_String_Found == 1){
   \                     ??SendWA_Init_1:
   \   000030 C6 ....      LD        A, L:GS1011_String_Found
   \   000033 A1 01        CP        A, #0x1
   \   000035 26 04        JRNE      L:??SendWA_Init_2
    477            SNAP_State = SET_DHCPSRVR_STATE;
   \   000037 35 11 ....   MOV       L:SNAP_State, #0x11
    478            }
    479          }
   \                     ??SendWA_Init_2:
   \   00003B 87           RETF
    480          /*****************************************************************************
    481           ****   setDHCPSRVR  - SET_DHCPSRVR_STATE                                 ****
    482           ****  clears all old parameters                                          ****
    483           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    484          void setDHCPSRVR(void){
    485             Copy_Stock_Send_Message(SetDHCPSRVRMessage);
   \                     setDHCPSRVR:
   \   000000 AE ....      LDW       X, #SetDHCPSRVRMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    486          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??setDHCPSRVR_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 06        JRNE      L:??setDHCPSRVR_1
    487          {
    488          GetResponseFromGS1011();
   \   00000E 8D ......    CALLF     GetResponseFromGS1011
   \   000012 20 F3        JRA       L:??setDHCPSRVR_0
    489          }
    490          if (GS1011_String_Found == 1){
   \                     ??setDHCPSRVR_1:
   \   000014 C6 ....      LD        A, L:GS1011_String_Found
   \   000017 A1 01        CP        A, #0x1
   \   000019 26 04        JRNE      L:??setDHCPSRVR_2
    491            SNAP_State = SET_PROVISIONING_STATE;
   \   00001B 35 12 ....   MOV       L:SNAP_State, #0x12
    492            }
    493          }
   \                     ??setDHCPSRVR_2:
   \   00001F 87           RETF
    494          /*****************************************************************************
    495           ****   setDHCPSRVR  - SET_PROVISIONING_STATE                             ****
    496           ****  clears all old parameters                                          ****
    497           *****************************************************************************/

   \                                 In section .far_func.text, align 1
    498          void SetProvisioning(void){
    499             Copy_Stock_Send_Message(SetWEBPROVMessage);
   \                     SetProvisioning:
   \   000000 AE ....      LDW       X, #SetWEBPROVMessage
   \   000003 8D ......    CALLF     Copy_Stock_Send_Message
    500          while (GS1011_Received_Response_Flag == 0x01)
   \                     ??SetProvisioning_0:
   \   000007 C6 ....      LD        A, L:GS1011_Received_Response_Flag
   \   00000A A1 01        CP        A, #0x1
   \   00000C 26 09        JRNE      L:??SetProvisioning_1
    501          {
    502            Get_any_ResponseFromGS1011(NWCONN_Response);
   \   00000E AE ....      LDW       X, #NWCONN_Response
   \   000011 8D ......    CALLF     Get_any_ResponseFromGS1011
   \   000015 20 F0        JRA       L:??SetProvisioning_0
    503          }
    504          if (GS1011_String_Found == 1){
   \                     ??SetProvisioning_1:
   \   000017 C6 ....      LD        A, L:GS1011_String_Found
   \   00001A A1 01        CP        A, #0x1
   \   00001C 26 04        JRNE      L:??SetProvisioning_2
    505            SNAP_State = CONVERT_DEVICE_DATA_AND_SEND_STATE;
   \   00001E 35 08 ....   MOV       L:SNAP_State, #0x8
    506            }
    507          }
   \                     ??SetProvisioning_2:
   \   000022 87           RETF
    508          
    509          
    510          /*****************************************************************************/
    511          /*****************************************************************************/
    512          /****                       normal routines                                ***/
    513          /*****************************************************************************/
    514          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    515          void SendYouThereMessageToGS1011(void){
    516          CopyBufferGS1011(YouThereMessage);                                 
   \                     SendYouThereMessageToGS1011:
   \   000000 AE ....      LDW       X, #YouThereMessage
   \   000003 8D ......    CALLF     CopyBufferGS1011
    517          Start_GS1011_Send();                                /* kickstart the xmitter*/
   \   000007 8D ......    CALLF     Start_GS1011_Send
    518          if (GS1011_Rcvr_Timeout == 1)
   \   00000B C6 ....      LD        A, L:GS1011_Rcvr_Timeout
   \   00000E A1 01        CP        A, #0x1
   \   000010 26 04        JRNE      L:??SendYouThereMessageToGS1011_0
    519            GetResponseFromGS1011();
   \   000012 8D ......    CALLF     GetResponseFromGS1011
    520          }
   \                     ??SendYouThereMessageToGS1011_0:
   \   000016 87           RETF
    521          /*****************************************************************************/
    522          /*****************************************************************************/
    523          /****                        ISR routines                                  ***/
    524          /****                 UART DATA HANDLING ROUTINES                          ***/
    525          /*****************************************************************************/
    526          /*****************************************************************************/
    527          
    528          /*****************************************************************************
    529            *   GetResponseFromGS1011                                                  *
    530            *                                                                          *
    531            *   Checks the input from the GS1011 for OK or ERROR                       *                                                  *
    532            *       and returns the status to the calling routine                      *
    533            *****************************************************************************/

   \                                 In section .far_func.text, align 1
    534          void GetResponseFromGS1011(void){
    535            if (GS1011_Rcvr_Timeout == 1){
   \                     GetResponseFromGS1011:
   \   000000 C6 ....      LD        A, L:GS1011_Rcvr_Timeout
   \   000003 A1 01        CP        A, #0x1
   \   000005 26 0B        JRNE      L:??GetResponseFromGS1011_0
    536              GS1011_Received_Response_Flag = 0x00;
   \   000007 35 00 ....   MOV       L:GS1011_Received_Response_Flag, #0x0
    537              FindGS1011Chars(OKAYmsg);
   \   00000B AE ....      LDW       X, #OKAYmsg
   \   00000E 8D ......    CALLF     FindGS1011Chars
    538            }
    539          }
   \                     ??GetResponseFromGS1011_0:
   \   000012 87           RETF

   \                                 In section .far_func.text, align 1
    540          void Get_any_ResponseFromGS1011(char bufr[]){
   \                     Get_any_ResponseFromGS1011:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    541            if (GS1011_Rcvr_Timeout == 1) {
   \   000006 C6 ....      LD        A, L:GS1011_Rcvr_Timeout
   \   000009 A1 01        CP        A, #0x1
   \   00000B 26 18        JRNE      L:??Get_any_ResponseFromGS1011_0
    542              GS1011_Received_Response_Flag = 0x00;
   \   00000D 35 00 ....   MOV       L:GS1011_Received_Response_Flag, #0x0
    543              FindGS1011Chars(OKAYmsg);
   \   000011 AE ....      LDW       X, #OKAYmsg
   \   000014 8D ......    CALLF     FindGS1011Chars
    544                
    545              if (GS1011_String_Found == 1){
   \   000018 C6 ....      LD        A, L:GS1011_String_Found
   \   00001B A1 01        CP        A, #0x1
   \   00001D 26 06        JRNE      L:??Get_any_ResponseFromGS1011_0
    546                  FindGS1011Chars(bufr);
   \   00001F BE ..        LDW       X, S:?w4
   \   000021 8D ......    CALLF     FindGS1011Chars
    547              }
    548            }
    549          }
   \                     ??Get_any_ResponseFromGS1011_0:
   \   000025 AC ......    JPF       L:?epilogue_w4

   \                                 In section .far_func.text, align 1
    550          void GetResetResponseFromGS1011(void){
    551            if (GS1011_Rcvr_Timeout == 1){
   \                     GetResetResponseFromGS1011:
   \   000000 C6 ....      LD        A, L:GS1011_Rcvr_Timeout
   \   000003 A1 01        CP        A, #0x1
   \   000005 26 0B        JRNE      L:??GetResetResponseFromGS1011_0
    552              GS1011_Received_Response_Flag = 0x00;
   \   000007 35 00 ....   MOV       L:GS1011_Received_Response_Flag, #0x0
    553                FindGS1011Chars(SWReset_Response);
   \   00000B AE ....      LDW       X, #SWReset_Response
   \   00000E 8D ......    CALLF     FindGS1011Chars
    554             }
    555          }
   \                     ??GetResetResponseFromGS1011_0:
   \   000012 87           RETF
    556          
    557          /*****************************************************************************
    558            *   Handle_GS1011_Received_Data                                              *
    559            *                                                                            *
    560            *   Get a character from the data register.                                  *
    561            *         Set a timer for x seconds(timer value is dependent upon command.   *
    562            *                                                                            *
    563            *   If the timer expires check if the response matches the command.          *
    564            *                                                                            *
    565            *   If the command was an update, and the response was status:good then      *
    566            *             Send the stock ACK message to the device                       *
    567            *                                                                            *
    568            *****************************************************************************/

   \                                 In section .far_func.text, align 1
    569          void GS1011_Received_Data_Handler(void){
    570           (void)UART1->SR;
   \                     GS1011_Received_Data_Handler:
   \   000000 C6 5230      LD        A, L:0x5230
   \   000003 B7 ..        LD        S:?b0, A
    571           GS1011_Rcvr_Char = UART1->DR;
   \   000005 C6 5231      LD        A, L:0x5231
   \   000008 C7 ....      LD        L:GS1011_Rcvr_Char, A
    572           GS1011_Receiver_Buffer[GS1011_Rcvr_InPtr] = GS1011_Rcvr_Char;
   \   00000B CE ....      LDW       X, L:GS1011_Rcvr_InPtr
   \   00000E C6 ....      LD        A, L:GS1011_Rcvr_Char
   \   000011 D7 ....      LD        (L:GS1011_Receiver_Buffer,X), A
    573           GS1011_Rcvr_InPtr++;
   \   000014 CE ....      LDW       X, L:GS1011_Rcvr_InPtr
   \   000017 5C           INCW      X
   \   000018 CF ....      LDW       L:GS1011_Rcvr_InPtr, X
    574           GS1011_Rvcr_Count++;
   \   00001B CE ....      LDW       X, L:GS1011_Rvcr_Count
   \   00001E 5C           INCW      X
   \   00001F CF ....      LDW       L:GS1011_Rvcr_Count, X
    575           if (GS1011_Rcvr_InPtr == BFRSIZEX2)
   \   000022 CE ....      LDW       X, L:GS1011_Rcvr_InPtr
   \   000025 A3 0200      CPW       X, #0x200
   \   000028 26 04        JRNE      L:??GS1011_Received_Data_Handler_0
    576             GS1011_Rcvr_InPtr =0;
   \   00002A 5F           CLRW      X
   \   00002B CF ....      LDW       L:GS1011_Rcvr_InPtr, X
    577           GS1011_Rcvr_Pointer++;
   \                     ??GS1011_Received_Data_Handler_0:
   \   00002E CE ....      LDW       X, L:GS1011_Rcvr_Pointer
   \   000031 5C           INCW      X
   \   000032 CF ....      LDW       L:GS1011_Rcvr_Pointer, X
    578           GS1011_Rcvr_EOM_Timer = 150;
   \   000035 35 96 ....   MOV       L:GS1011_Rcvr_EOM_Timer, #0x96
    579          }
   \   000039 87           RETF
    580          /******************************************************************************
    581            *   Start_GS1011_Send                                                        *
    582            *                                                                            *
    583            *   Gets the first character and sets the buffer count and pointer.          *
    584            *   It sends the first character then the interupts take over.               *
    585            *                                                                            *
    586            *****************************************************************************/

   \                                 In section .far_func.text, align 1
    587          void Copy_Stock_Send_Message(char strng[]){
   \                     Copy_Stock_Send_Message:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
    588              InitializeGS1011Buffer();
   \   000006 8D ......    CALLF     InitializeGS1011Buffer
    589              CopyBufferGS1011(strng);  
   \   00000A BE ..        LDW       X, S:?w4
   \   00000C 8D ......    CALLF     CopyBufferGS1011
    590              Start_GS1011_Send();                                /* kickstart the xmitter*/
   \   000010 8D ......    CALLF     Start_GS1011_Send
    591              GS1011_Received_Response_Flag = 0x01;
   \   000014 35 01 ....   MOV       L:GS1011_Received_Response_Flag, #0x1
    592          }
   \   000018 AC ......    JPF       L:?epilogue_w4
    593          /******************************************************************************
    594            *   Start_GS1011_Send                                                        *
    595            *                                                                            *
    596            *   Gets the first character and sets the buffer count and pointer.          *
    597            *   It sends the first character then the interupts take over.               *
    598            *                                                                            *
    599            *****************************************************************************/

   \                                 In section .far_func.text, align 1
    600          void Start_GS1011_Send(void){
    601            GS1011_Xmit_Pointer = 0;
   \                     Start_GS1011_Send:
   \   000000 35 00 ....   MOV       L:GS1011_Xmit_Pointer, #0x0
    602            GS1011_Xmit_Char = GS1011_Xmit_Buffer[GS1011_Xmit_Pointer];
   \   000004 C6 ....      LD        A, L:GS1011_Xmit_Pointer
   \   000007 5F           CLRW      X
   \   000008 97           LD        XL, A
   \   000009 D6 ....      LD        A, (L:GS1011_Xmit_Buffer,X)
   \   00000C C7 ....      LD        L:GS1011_Xmit_Char, A
    603           GS1011_Rcvr_Timeout = 0;
   \   00000F 35 00 ....   MOV       L:GS1011_Rcvr_Timeout, #0x0
    604             GS1011_Xmit_Pointer++;
   \   000013 C6 ....      LD        A, L:GS1011_Xmit_Pointer
   \   000016 AB 01        ADD       A, #0x1
   \   000018 C7 ....      LD        L:GS1011_Xmit_Pointer, A
    605            GS1011_Xmit_Char_Count--;
   \   00001B C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00001E AB FF        ADD       A, #0xff
   \   000020 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    606            UART1->DR = GS1011_Xmit_Char;
   \   000023 C6 ....      LD        A, L:GS1011_Xmit_Char
   \   000026 C7 5231      LD        L:0x5231, A
    607            UART1->CR2 |= ((uint8_t)UART1_CR2_TCIEN | UART1_CR2_TCIEN | UART1_CR2_TIEN);
   \   000029 C6 5235      LD        A, L:0x5235
   \   00002C AA C0        OR        A, #0xc0
   \   00002E C7 5235      LD        L:0x5235, A
    608            }
   \   000031 87           RETF
    609             
    610            /*****************************************************************************
    611            *   Handle_Sending_GS1011_Data                                               *
    612            *                                                                            *
    613            *   Send a character to the data register.                                   *
    614            *         Continue till count = 00                                           *
    615            *                                                                            *
    616            *****************************************************************************/

   \                                 In section .far_func.text, align 1
    617          void Sending_GS1011_Data_Handler(void){
    618              if (UART1->SR & UART3_FLAG_TXE){
   \                     Sending_GS1011_Data_Handler:
   \   000000 720F 5230 32 BTJF      L:0x5230, #0x7, L:??Sending_GS1011_Data_Handler_0
    619          
    620            GS1011_Xmit_Char = GS1011_Xmit_Buffer[GS1011_Xmit_Pointer];
   \   000005 C6 ....      LD        A, L:GS1011_Xmit_Pointer
   \   000008 5F           CLRW      X
   \   000009 97           LD        XL, A
   \   00000A D6 ....      LD        A, (L:GS1011_Xmit_Buffer,X)
   \   00000D C7 ....      LD        L:GS1011_Xmit_Char, A
    621            if (GS1011_Xmit_Char_Count!=0){
   \   000010 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000013 A1 00        CP        A, #0x0
   \   000015 27 18        JREQ      L:??Sending_GS1011_Data_Handler_1
    622                UART1->DR= GS1011_Xmit_Char;
   \   000017 C6 ....      LD        A, L:GS1011_Xmit_Char
   \   00001A C7 5231      LD        L:0x5231, A
    623                GS1011_Xmit_Pointer++;
   \   00001D C6 ....      LD        A, L:GS1011_Xmit_Pointer
   \   000020 AB 01        ADD       A, #0x1
   \   000022 C7 ....      LD        L:GS1011_Xmit_Pointer, A
    624                GS1011_Xmit_Char_Count--;}
   \   000025 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000028 AB FF        ADD       A, #0xff
   \   00002A C7 ....      LD        L:GS1011_Xmit_Char_Count, A
   \   00002D 20 08        JRA       L:??Sending_GS1011_Data_Handler_0
    625            else UART1->CR2 &= (uint8_t)~(UART1_CR2_TCIEN | UART1_CR2_TIEN);     
   \                     ??Sending_GS1011_Data_Handler_1:
   \   00002F C6 5235      LD        A, L:0x5235
   \   000032 A4 3F        AND       A, #0x3f
   \   000034 C7 5235      LD        L:0x5235, A
    626           }
    627          }
   \                     ??Sending_GS1011_Data_Handler_0:
   \   000037 87           RETF
    628          /*****************************************************************************/
    629          /*****************************************************************************/
    630          /*****        GS1011 Initialize/DeInit                                   *****/
    631          /*****************************************************************************/
    632          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    633          void InitGS1011UART(void){
    634            UART1_Init(9600,  UART1_WORDLENGTH_8D, UART1_STOPBITS_1,
    635            UART1_PARITY_NO, UART1_SYNCMODE_CLOCK_DISABLE,  UART1_MODE_TXRX_ENABLE);
   \                     InitGS1011UART:
   \   000000 35 0C ....   MOV       S:?b7, #0xc
   \   000004 35 80 ....   MOV       S:?b6, #0x80
   \   000008 3F ..        CLR       S:?b5
   \   00000A 3F ..        CLR       S:?b4
   \   00000C 4F           CLR       A
   \   00000D AE 2580      LDW       X, #0x2580
   \   000010 BF ..        LDW       S:?w1, X
   \   000012 5F           CLRW      X
   \   000013 BF ..        LDW       S:?w0, X
   \   000015 8D ......    CALLF     UART1_Init
    636          }
   \   000019 87           RETF
    637          
    638          /*****************************************************************************/
    639          /*****                          UART1_DeInit                              ****/
    640          /***** Clear the Idle Line Detected bit in the status rerister by a read  ****/
    641          /***** to the UART3_SR register followed by a Read to the UART1_DR register **/
    642          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    643          void UART1_DeInit(void)
    644          {
    645              /* Clear the Idle Line Detected bit in the status rerister by a read
    646                 to the UART1_SR register followed by a Read to the UART1_DR register */
    647              (void)UART1->SR;
   \                     UART1_DeInit:
   \   000000 C6 5230      LD        A, L:0x5230
   \   000003 B7 ..        LD        S:?b0, A
    648              (void)UART1->DR;
   \   000005 C6 5231      LD        A, L:0x5231
    649          
    650              UART1->BRR2 = UART1_BRR2_RESET_VALUE;  /* Set UART1_BRR2 to reset value 0x00 */
   \   000008 35 00 5233   MOV       L:0x5233, #0x0
    651              UART1->BRR1 = UART1_BRR1_RESET_VALUE;  /* Set UART1_BRR1 to reset value 0x00 */
   \   00000C 35 00 5232   MOV       L:0x5232, #0x0
    652          
    653              UART1->CR1 = UART1_CR1_RESET_VALUE;  /* Set UART1_CR1 to reset value 0x00 */
   \   000010 35 00 5234   MOV       L:0x5234, #0x0
    654              UART1->CR2 = UART1_CR2_RESET_VALUE;  /* Set UART1_CR2 to reset value 0x00 */
   \   000014 35 00 5235   MOV       L:0x5235, #0x0
    655              UART1->CR3 = UART1_CR3_RESET_VALUE;  /* Set UART1_CR3 to reset value 0x00 */
   \   000018 35 00 5236   MOV       L:0x5236, #0x0
    656              UART1->CR4 = UART1_CR4_RESET_VALUE;  /* Set UART1_CR4 to reset value 0x00 */
   \   00001C 35 00 5237   MOV       L:0x5237, #0x0
    657              UART1->CR5 = UART1_CR5_RESET_VALUE;  /* Set UART1_CR5 to reset value 0x00 */
   \   000020 35 00 5238   MOV       L:0x5238, #0x0
    658          
    659              UART1->GTR = UART1_GTR_RESET_VALUE;
   \   000024 35 00 5239   MOV       L:0x5239, #0x0
    660              UART1->PSCR = UART1_PSCR_RESET_VALUE;
   \   000028 35 00 523A   MOV       L:0x523a, #0x0
    661          }
   \   00002C 87           RETF
    662          
    663          
    664          /*****************************************************************************/
    665          /*****                          UART1_Init                                ****/
    666          /*****************************************************************************/
    667          /**
    668            * @brief  Initializes the UART1 according to the specified parameters.
    669            * @note   Configure in Push Pull or Open Drain mode the Tx pin by setting the
    670            *         correct I/O Port register according the product package and line
    671            *         configuration
    672            * @param  BaudRate: The baudrate.
    673            * @param  WordLength : This parameter can be any of the 
    674            *         @ref UART1_WordLength_TypeDef enumeration.
    675            * @param  StopBits: This parameter can be any of the 
    676            *         @ref UART1_StopBits_TypeDef enumeration.
    677            * @param  Parity: This parameter can be any of the 
    678            *         @ref UART1_Parity_TypeDef enumeration.
    679            * @param  SyncMode: This parameter can be any of the 
    680            *         @ref UART1_SyncMode_TypeDef values.
    681            * @param  Mode: This parameter can be any of the @ref UART1_Mode_TypeDef values
    682            * @retval None
    683            */

   \                                 In section .far_func.text, align 1
    684          void UART1_Init(uint32_t BaudRate, UART1_WordLength_TypeDef WordLength, 
    685                          UART1_StopBits_TypeDef StopBits, UART1_Parity_TypeDef Parity, 
    686                          UART1_SyncMode_TypeDef SyncMode, UART1_Mode_TypeDef Mode)
    687          {
   \                     UART1_Init:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 8D ......    CALLF     L:?push_l3
   \   000008 88           PUSH      A
   \   000009 3B ....      PUSH      S:?b4
   \   00000C 3B ....      PUSH      S:?b5
   \   00000F 3B ....      PUSH      S:?b6
   \   000012 3B ....      PUSH      S:?b7
   \   000015 52 05        SUB       SP, #0x5
   \   000017 8D ......    CALLF     L:?mov_l2_l0
    688              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
   \   00001B 5F           CLRW      X
   \   00001C BF ..        LDW       S:?w7, X
   \   00001E BF ..        LDW       S:?w6, X
   \   000020 AE 0000      LDW       X, #0x0
   \   000023 1F 02        LDW       (0x2,SP), X
   \   000025 AE 0000      LDW       X, #0x0
   \   000028 1F 04        LDW       (0x4,SP), X
    689          
    690              /* Check the parameters */
    691              assert_param(IS_UART1_BAUDRATE_OK(BaudRate));
   \   00002A BE ..        LDW       X, S:?w4
   \   00002C A3 0009      CPW       X, #0x9
   \   00002F 26 05        JRNE      L:??UART1_Init_0
   \   000031 BE ..        LDW       X, S:?w5
   \   000033 A3 8969      CPW       X, #0x8969
   \                     ??UART1_Init_0:
   \   000036 25 0F        JRC       L:??UART1_Init_1
   \   000038 AE 02B3      LDW       X, #0x2b3
   \   00003B BF ..        LDW       S:?w1, X
   \   00003D 5F           CLRW      X
   \   00003E BF ..        LDW       S:?w0, X
   \   000040 AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   000043 8D ......    CALLF     assert_failed
    692              assert_param(IS_UART1_WORDLENGTH_OK(WordLength));
   \                     ??UART1_Init_1:
   \   000047 0D 0A        TNZ       (0xa,SP)
   \   000049 27 15        JREQ      L:??UART1_Init_2
   \   00004B 7B 0A        LD        A, (0xa,SP)
   \   00004D A1 10        CP        A, #0x10
   \   00004F 27 0F        JREQ      L:??UART1_Init_2
   \   000051 AE 02B4      LDW       X, #0x2b4
   \   000054 BF ..        LDW       S:?w1, X
   \   000056 5F           CLRW      X
   \   000057 BF ..        LDW       S:?w0, X
   \   000059 AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   00005C 8D ......    CALLF     assert_failed
    693              assert_param(IS_UART1_STOPBITS_OK(StopBits));
   \                     ??UART1_Init_2:
   \   000060 0D 09        TNZ       (0x9,SP)
   \   000062 27 21        JREQ      L:??UART1_Init_3
   \   000064 7B 09        LD        A, (0x9,SP)
   \   000066 A1 10        CP        A, #0x10
   \   000068 27 1B        JREQ      L:??UART1_Init_3
   \   00006A 7B 09        LD        A, (0x9,SP)
   \   00006C A1 20        CP        A, #0x20
   \   00006E 27 15        JREQ      L:??UART1_Init_3
   \   000070 7B 09        LD        A, (0x9,SP)
   \   000072 A1 30        CP        A, #0x30
   \   000074 27 0F        JREQ      L:??UART1_Init_3
   \   000076 AE 02B5      LDW       X, #0x2b5
   \   000079 BF ..        LDW       S:?w1, X
   \   00007B 5F           CLRW      X
   \   00007C BF ..        LDW       S:?w0, X
   \   00007E AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   000081 8D ......    CALLF     assert_failed
    694              assert_param(IS_UART1_PARITY_OK(Parity));
   \                     ??UART1_Init_3:
   \   000085 0D 08        TNZ       (0x8,SP)
   \   000087 27 1B        JREQ      L:??UART1_Init_4
   \   000089 7B 08        LD        A, (0x8,SP)
   \   00008B A1 04        CP        A, #0x4
   \   00008D 27 15        JREQ      L:??UART1_Init_4
   \   00008F 7B 08        LD        A, (0x8,SP)
   \   000091 A1 06        CP        A, #0x6
   \   000093 27 0F        JREQ      L:??UART1_Init_4
   \   000095 AE 02B6      LDW       X, #0x2b6
   \   000098 BF ..        LDW       S:?w1, X
   \   00009A 5F           CLRW      X
   \   00009B BF ..        LDW       S:?w0, X
   \   00009D AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   0000A0 8D ......    CALLF     assert_failed
    695              assert_param(IS_UART1_MODE_OK((uint8_t)Mode));
   \                     ??UART1_Init_4:
   \   0000A4 7B 06        LD        A, (0x6,SP)
   \   0000A6 A1 08        CP        A, #0x8
   \   0000A8 27 3F        JREQ      L:??UART1_Init_5
   \   0000AA 7B 06        LD        A, (0x6,SP)
   \   0000AC A1 40        CP        A, #0x40
   \   0000AE 27 39        JREQ      L:??UART1_Init_5
   \   0000B0 7B 06        LD        A, (0x6,SP)
   \   0000B2 A1 04        CP        A, #0x4
   \   0000B4 27 33        JREQ      L:??UART1_Init_5
   \   0000B6 7B 06        LD        A, (0x6,SP)
   \   0000B8 A1 80        CP        A, #0x80
   \   0000BA 27 2D        JREQ      L:??UART1_Init_5
   \   0000BC 7B 06        LD        A, (0x6,SP)
   \   0000BE A1 0C        CP        A, #0xc
   \   0000C0 27 27        JREQ      L:??UART1_Init_5
   \   0000C2 7B 06        LD        A, (0x6,SP)
   \   0000C4 A1 0C        CP        A, #0xc
   \   0000C6 27 21        JREQ      L:??UART1_Init_5
   \   0000C8 7B 06        LD        A, (0x6,SP)
   \   0000CA A1 44        CP        A, #0x44
   \   0000CC 27 1B        JREQ      L:??UART1_Init_5
   \   0000CE 7B 06        LD        A, (0x6,SP)
   \   0000D0 A1 C0        CP        A, #0xc0
   \   0000D2 27 15        JREQ      L:??UART1_Init_5
   \   0000D4 7B 06        LD        A, (0x6,SP)
   \   0000D6 A1 88        CP        A, #0x88
   \   0000D8 27 0F        JREQ      L:??UART1_Init_5
   \   0000DA AE 02B7      LDW       X, #0x2b7
   \   0000DD BF ..        LDW       S:?w1, X
   \   0000DF 5F           CLRW      X
   \   0000E0 BF ..        LDW       S:?w0, X
   \   0000E2 AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   0000E5 8D ......    CALLF     assert_failed
    696              assert_param(IS_UART1_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??UART1_Init_5:
   \   0000E9 7B 07        LD        A, (0x7,SP)
   \   0000EB A4 88        AND       A, #0x88
   \   0000ED A1 88        CP        A, #0x88
   \   0000EF 27 18        JREQ      L:??UART1_Init_6
   \   0000F1 7B 07        LD        A, (0x7,SP)
   \   0000F3 A4 44        AND       A, #0x44
   \   0000F5 A1 44        CP        A, #0x44
   \   0000F7 27 10        JREQ      L:??UART1_Init_6
   \   0000F9 7B 07        LD        A, (0x7,SP)
   \   0000FB A4 22        AND       A, #0x22
   \   0000FD A1 22        CP        A, #0x22
   \   0000FF 27 08        JREQ      L:??UART1_Init_6
   \   000101 7B 07        LD        A, (0x7,SP)
   \   000103 A4 11        AND       A, #0x11
   \   000105 A1 11        CP        A, #0x11
   \   000107 26 0F        JRNE      L:??UART1_Init_7
   \                     ??UART1_Init_6:
   \   000109 AE 02B8      LDW       X, #0x2b8
   \   00010C BF ..        LDW       S:?w1, X
   \   00010E 5F           CLRW      X
   \   00010F BF ..        LDW       S:?w0, X
   \   000111 AE ....      LDW       X, #`?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`
   \   000114 8D ......    CALLF     assert_failed
    697          
    698              /* Clear the word length bit */
    699              UART1->CR1 &= (uint8_t)(~UART1_CR1_M);  
   \                     ??UART1_Init_7:
   \   000118 7219 5234    BRES      L:0x5234, #0x4
    700              
    701               /* Set the word length bit according to UART1_WordLength value */
    702              UART1->CR1 |= (uint8_t)WordLength;
   \   00011C 7B 0A        LD        A, (0xa,SP)
   \   00011E CA 5234      OR        A, L:0x5234
   \   000121 C7 5234      LD        L:0x5234, A
    703          
    704              /* Clear the STOP bits */
    705              UART1->CR3 &= (uint8_t)(~UART1_CR3_STOP);  
   \   000124 C6 5236      LD        A, L:0x5236
   \   000127 A4 CF        AND       A, #0xcf
   \   000129 C7 5236      LD        L:0x5236, A
    706              /* Set the STOP bits number according to UART1_StopBits value  */
    707              UART1->CR3 |= (uint8_t)StopBits;  
   \   00012C 7B 09        LD        A, (0x9,SP)
   \   00012E CA 5236      OR        A, L:0x5236
   \   000131 C7 5236      LD        L:0x5236, A
    708          
    709              /* Clear the Parity Control bit */
    710              UART1->CR1 &= (uint8_t)(~(UART1_CR1_PCEN | UART1_CR1_PS  ));  
   \   000134 C6 5234      LD        A, L:0x5234
   \   000137 A4 F9        AND       A, #0xf9
   \   000139 C7 5234      LD        L:0x5234, A
    711              /* Set the Parity Control bit to UART1_Parity value */
    712              UART1->CR1 |= (uint8_t)Parity;  
   \   00013C 7B 08        LD        A, (0x8,SP)
   \   00013E CA 5234      OR        A, L:0x5234
   \   000141 C7 5234      LD        L:0x5234, A
    713          
    714              /* Clear the LSB mantissa of UART1DIV  */
    715              UART1->BRR1 &= (uint8_t)(~UART1_BRR1_DIVM);  
   \   000144 C6 5232      LD        A, L:0x5232
   \   000147 6B 01        LD        (0x1,SP), A
   \   000149 35 00 5232   MOV       L:0x5232, #0x0
    716              /* Clear the MSB mantissa of UART1DIV  */
    717              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVM);  
   \   00014D C6 5233      LD        A, L:0x5233
   \   000150 A4 0F        AND       A, #0xf
   \   000152 C7 5233      LD        L:0x5233, A
    718              /* Clear the Fraction bits of UART1DIV */
    719              UART1->BRR2 &= (uint8_t)(~UART1_BRR2_DIVF);  
   \   000155 C6 5233      LD        A, L:0x5233
   \   000158 A4 F0        AND       A, #0xf0
   \   00015A C7 5233      LD        L:0x5233, A
    720          
    721              /* Set the UART1 BaudRates in BRR1 and BRR2 registers according to UART1_BaudRate value */
    722              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   00015D 8D ......    CALLF     L:?mov_l0_l2
   \   000161 A6 04        LD        A, #0x4
   \   000163 8D ......    CALLF     L:?sll32_l0_l0_a
   \   000167 8D ......    CALLF     L:?push_l0
   \   00016B 8D ......    CALLF     CLK_GetClockFreq
   \   00016F 8D ......    CALLF     L:?pop_l1
   \   000173 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   000177 8D ......    CALLF     L:?mov_l3_l0
    723              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
   \   00017B 8D ......    CALLF     L:?mov_l0_l2
   \   00017F A6 04        LD        A, #0x4
   \   000181 8D ......    CALLF     L:?sll32_l0_l0_a
   \   000185 8D ......    CALLF     L:?push_l0
   \   000189 8D ......    CALLF     CLK_GetClockFreq
   \   00018D 8D ......    CALLF     L:?mov_l1_l0
   \   000191 AE 0064      LDW       X, #0x64
   \   000194 BF ..        LDW       S:?w1, X
   \   000196 5F           CLRW      X
   \   000197 BF ..        LDW       S:?w0, X
   \   000199 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   00019D 8D ......    CALLF     L:?pop_l1
   \   0001A1 8D ......    CALLF     L:?udiv32_l0_l0_l1
   \   0001A5 AE 0002      LDW       X, #0x2
   \   0001A8 8D ......    CALLF     L:?load32_xsp_l0
    724              /* Set the fraction of UART1DIV  */
    725              UART1->BRR2 |= (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100)) << 4) / 100) & (uint8_t)0x0F); 
   \   0001AC AE 0064      LDW       X, #0x64
   \   0001AF BF ..        LDW       S:?w3, X
   \   0001B1 5F           CLRW      X
   \   0001B2 BF ..        LDW       S:?w2, X
   \   0001B4 8D ......    CALLF     L:?mov_l0_l3
   \   0001B8 8D ......    CALLF     L:?mul32_l0_l0_l1
   \   0001BC 8D ......    CALLF     L:?mov_l1_l0
   \   0001C0 8D ......    CALLF     L:?load32_l0_dbsp
   \   0001C4 02           DC8       0x2
   \   0001C5 8D ......    CALLF     L:?sub32_l0_l0_l1
   \   0001C9 A6 04        LD        A, #0x4
   \   0001CB 8D ......    CALLF     L:?sll32_l0_l0_a
   \   0001CF 8D ......    CALLF     L:?udiv32_l0_l0_dl
   \   0001D3 00000064     DC32      0x64
   \   0001D7 B6 ..        LD        A, S:?b3
   \   0001D9 A4 0F        AND       A, #0xf
   \   0001DB CA 5233      OR        A, L:0x5233
   \   0001DE C7 5233      LD        L:0x5233, A
    726              /* Set the MSB mantissa of UART1DIV  */
    727              UART1->BRR2 |= (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0); 
   \   0001E1 BE ..        LDW       X, S:?w7
   \   0001E3 54           SRLW      X
   \   0001E4 54           SRLW      X
   \   0001E5 54           SRLW      X
   \   0001E6 54           SRLW      X
   \   0001E7 9F           LD        A, XL
   \   0001E8 A4 F0        AND       A, #0xf0
   \   0001EA CA 5233      OR        A, L:0x5233
   \   0001ED C7 5233      LD        L:0x5233, A
    728              /* Set the LSB mantissa of UART1DIV  */
    729              UART1->BRR1 |= (uint8_t)BaudRate_Mantissa;           
   \   0001F0 B6 ..        LD        A, S:?b15
   \   0001F2 CA 5232      OR        A, L:0x5232
   \   0001F5 C7 5232      LD        L:0x5232, A
    730          
    731              /* Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */
    732              UART1->CR2 &= (uint8_t)~(UART1_CR2_TEN | UART1_CR2_REN); 
   \   0001F8 C6 5235      LD        A, L:0x5235
   \   0001FB A4 F3        AND       A, #0xf3
   \   0001FD C7 5235      LD        L:0x5235, A
    733              /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    734              UART1->CR3 &= (uint8_t)~(UART1_CR3_CPOL | UART1_CR3_CPHA | UART1_CR3_LBCL); 
   \   000200 C6 5236      LD        A, L:0x5236
   \   000203 A4 F8        AND       A, #0xf8
   \   000205 C7 5236      LD        L:0x5236, A
    735              /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    736              UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART1_CR3_CPOL | 
    737                                                        UART1_CR3_CPHA | UART1_CR3_LBCL));  
   \   000208 7B 07        LD        A, (0x7,SP)
   \   00020A A4 07        AND       A, #0x7
   \   00020C CA 5236      OR        A, L:0x5236
   \   00020F C7 5236      LD        L:0x5236, A
    738          
    739              if ((uint8_t)(Mode & UART1_MODE_TX_ENABLE))
   \   000212 7B 06        LD        A, (0x6,SP)
   \   000214 A4 04        AND       A, #0x4
   \   000216 A1 00        CP        A, #0x0
   \   000218 27 06        JREQ      L:??UART1_Init_8
    740              {
    741                  /* Set the Transmitter Enable bit */
    742                  UART1->CR2 |= (uint8_t)UART1_CR2_TEN;  
   \   00021A 7216 5235    BSET      L:0x5235, #0x3
   \   00021E 20 04        JRA       L:??UART1_Init_9
    743              }
    744              else
    745              {
    746                  /* Clear the Transmitter Disable bit */
    747                  UART1->CR2 &= (uint8_t)(~UART1_CR2_TEN);  
   \                     ??UART1_Init_8:
   \   000220 7217 5235    BRES      L:0x5235, #0x3
    748              }
    749              if ((uint8_t)(Mode & UART1_MODE_RX_ENABLE))
   \                     ??UART1_Init_9:
   \   000224 7B 06        LD        A, (0x6,SP)
   \   000226 A4 08        AND       A, #0x8
   \   000228 A1 00        CP        A, #0x0
   \   00022A 27 16        JREQ      L:??UART1_Init_10
    750              {
    751                  /* Set the Receiver Enable bit */
    752                  GS1011_Rcvr_Char = UART1->DR;
   \   00022C C6 5231      LD        A, L:0x5231
   \   00022F C7 ....      LD        L:GS1011_Rcvr_Char, A
    753                  GS1011_Rcvr_Char = UART1->DR;
   \   000232 C6 5231      LD        A, L:0x5231
   \   000235 C7 ....      LD        L:GS1011_Rcvr_Char, A
    754                  UART1->CR2 |= ((uint8_t)UART1_CR2_REN | UART1_CR2_RIEN);
   \   000238 C6 5235      LD        A, L:0x5235
   \   00023B AA 24        OR        A, #0x24
   \   00023D C7 5235      LD        L:0x5235, A
   \   000240 20 04        JRA       L:??UART1_Init_11
    755              }
    756              else
    757              {
    758                  /* Clear the Receiver Disable bit */
    759                  UART1->CR2 &= (uint8_t)(~UART1_CR2_REN);  
   \                     ??UART1_Init_10:
   \   000242 7215 5235    BRES      L:0x5235, #0x2
    760              }
    761              /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    762                     pulse bits according to UART1_Mode value */
    763              if ((uint8_t)(SyncMode & UART1_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART1_Init_11:
   \   000246 7B 07        LD        A, (0x7,SP)
   \   000248 A4 80        AND       A, #0x80
   \   00024A A1 00        CP        A, #0x0
   \   00024C 27 06        JREQ      L:??UART1_Init_12
    764              {
    765                  /* Clear the Clock Enable bit */
    766                  UART1->CR3 &= (uint8_t)(~UART1_CR3_CKEN); 
   \   00024E 7217 5236    BRES      L:0x5236, #0x3
   \   000252 20 0A        JRA       L:??UART1_Init_13
    767              }
    768              else
    769              {
    770                  UART1->CR3 |= (uint8_t)((uint8_t)SyncMode & UART1_CR3_CKEN);
   \                     ??UART1_Init_12:
   \   000254 7B 07        LD        A, (0x7,SP)
   \   000256 A4 08        AND       A, #0x8
   \   000258 CA 5236      OR        A, L:0x5236
   \   00025B C7 5236      LD        L:0x5236, A
    771              }
    772          }
   \                     ??UART1_Init_13:
   \   00025E 5B 0A        ADD       SP, #0xa
   \   000260 AC ......    JPF       L:?epilogue_l2_l3

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "C:\\\\Users\\\\jurban\\\\Docum...">`:
   \   000000 43 3A 5C 55  DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \          73 65 72 73 
   \   000008 5C 6A 75 72  DC8 5CH, 6AH, 75H, 72H, 62H, 61H, 6EH, 5CH
   \          62 61 6E 5C 
   \   000010 44 6F 63 75  DC8 44H, 6FH, 63H, 75H, 6DH, 65H, 6EH, 74H
   \          6D 65 6E 74 
   \   000018 73 5C 47 69  DC8 73H, 5CH, 47H, 69H, 74H, 48H, 75H, 62H
   \          74 48 75 62 
   \   000020 5C 37 38 39  DC8 5CH, 37H, 38H, 39H, 36H, 5FH, 53H, 4EH
   \          36 5F 53 4E 
   \   000028 41 50 5F 31  DC8 41H, 50H, 5FH, 31H, 30H, 30H, 5CH, 47H
   \          30 30 5C 47 
   \   000030 53 31 30 31  DC8 53H, 31H, 30H, 31H, 31H, 5FH, 53H, 65H
   \          31 5F 53 65 
   \   000038 72 69 61 6C  DC8 72H, 69H, 61H, 6CH, 5FH, 48H, 61H, 6EH
   \          5F 48 61 6E 
   \   000040 64 6C 65 72  DC8 64H, 6CH, 65H, 72H, 73H, 2EH, 63H, 0
   \          73 2E 63 00 
    773          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      72  ?<Constant "C:\\Users\\jurban\\Docum...">
     113  Convert_update_and_Send
      28  Copy_Stock_Send_Message
      32  DisassociateWeb
      58  GS1011_Received_Data_Handler
      54  GetNSTAT_ResponseFromGS1011
      37  GetNetworkStatusFromGS1011
      19  GetResetResponseFromGS1011
      19  GetResponseFromGS1011
      89  Get_Website_IP_address
      96  Get_Website_Response_and_Respond
      41  Get_any_ResponseFromGS1011
      38  HTTPOPEN_Get_CID
      26  InitGS1011UART
      32  ResetAdaptor
      32  Reset_Network_Access
      21  SendShutEchoOff
      60  SendWA_Init
      32  SendWM_2
      23  SendYouThereMessageToGS1011
      56  Sending_GS1011_Data_Handler
      35  SetProvisioning
      72  Set_FactoryReset
      32  Set_Keep_Alive
      32  Set_Mars_as_Website
      32  SetupSendInitialIPAddress
      50  Start_GS1011_Send
      45  UART1_DeInit
     612  UART1_Init
      32  setDHCPSRVR

 
 1 848 bytes in section .far_func.text
    72 bytes in section .near.rodata
 
 1 848 bytes of CODE  memory
    72 bytes of CONST memory

Errors: none
Warnings: none
