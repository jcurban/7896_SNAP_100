###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             22/May/2013  09:22:37 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  G:\SNAP_100\stm8s_uart2.c                                #
#    Command line =  G:\SNAP_100\stm8s_uart2.c -e --enable_multibytes -Oh     #
#                    --debug --code_model small --data_model small -o         #
#                    G:\SNAP_100\Debug\Obj\ --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8ssn.h" -D STM8S007 -lC                #
#                    G:\SNAP_100\Debug\List\ -I .\ --require_prototypes       #
#                    --vregs 16                                               #
#    List file    =  G:\SNAP_100\Debug\List\stm8s_uart2.lst                   #
#    Object file  =  G:\SNAP_100\Debug\Obj\stm8s_uart2.o                      #
#                                                                             #
#                                                                             #
###############################################################################

G:\SNAP_100\stm8s_uart2.c
      1          /**
      2            ********************************************************************************
      3            * @file    stm8s_uart2.c
      4            * @author  MCD Application Team
      5            * @version V2.1.0
      6            * @date    18-November-2011
      7            * @brief   This file contains all the functions for the UART2 peripheral.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "stm8s_uart2.h"
     24          
     25          /** @addtogroup STM8S_StdPeriph_Driver
     26            * @{
     27            */
     28          /* Private typedef -----------------------------------------------------------*/
     29          /* Private define ------------------------------------------------------------*/
     30          /* Private macro -------------------------------------------------------------*/
     31          /* Private variables ---------------------------------------------------------*/
     32          /* Private function prototypes -----------------------------------------------*/
     33          /* Private functions ---------------------------------------------------------*/
     34          /* Public functions ----------------------------------------------------------*/
     35          
     36          /** @}
     37            * @addtogroup UART2_Public_Functions
     38            * @{
     39            */
     40          
     41          /**
     42            * @brief  Deinitializes the UART peripheral.
     43            * @param  None
     44            * @retval None
     45            */
     46          

   \                                 In section .near_func.text, align 1
     47          void UART2_DeInit(void)
     48          {
     49              /*  Clear the Idle Line Detected bit in the status register by a read
     50                 to the UART2_SR register followed by a Read to the UART2_DR register */
     51              (void) UART2->SR;
   \                     UART2_DeInit:
   \   000000 C6 5240      LD        A, L:0x5240
     52              (void)UART2->DR;
   \   000003 C6 5241      LD        A, L:0x5241
     53          
     54              UART2->BRR2 = UART2_BRR2_RESET_VALUE;  /*  Set UART2_BRR2 to reset value 0x00 */
   \   000006 725F 5243    CLR       L:0x5243
     55              UART2->BRR1 = UART2_BRR1_RESET_VALUE;  /*  Set UART2_BRR1 to reset value 0x00 */
   \   00000A 725F 5242    CLR       L:0x5242
     56          
     57              UART2->CR1 = UART2_CR1_RESET_VALUE; /*  Set UART2_CR1 to reset value 0x00  */
   \   00000E 725F 5244    CLR       L:0x5244
     58              UART2->CR2 = UART2_CR2_RESET_VALUE; /*  Set UART2_CR2 to reset value 0x00  */
   \   000012 725F 5245    CLR       L:0x5245
     59              UART2->CR3 = UART2_CR3_RESET_VALUE; /*  Set UART2_CR3 to reset value 0x00  */
   \   000016 725F 5246    CLR       L:0x5246
     60              UART2->CR4 = UART2_CR4_RESET_VALUE; /*  Set UART2_CR4 to reset value 0x00  */
   \   00001A 725F 5247    CLR       L:0x5247
     61              UART2->CR5 = UART2_CR5_RESET_VALUE; /*  Set UART2_CR5 to reset value 0x00  */
   \   00001E 725F 5248    CLR       L:0x5248
     62              UART2->CR6 = UART2_CR6_RESET_VALUE; /*  Set UART2_CR6 to reset value 0x00  */
   \   000022 725F 5249    CLR       L:0x5249
     63          
     64          }
   \   000026 81           RET
     65          
     66          /**
     67            * @brief  Initializes the UART2 according to the specified parameters.
     68            * @param  BaudRate: The baudrate.
     69            * @param  WordLength : This parameter can be any of the 
     70            *         @ref UART2_WordLength_TypeDef enumeration.
     71            * @param  StopBits: This parameter can be any of the 
     72            *         @ref UART2_StopBits_TypeDef enumeration.
     73            * @param  Parity: This parameter can be any of the 
     74            *         @ref UART2_Parity_TypeDef enumeration.
     75            * @param  SyncMode: This parameter can be any of the 
     76            *         @ref UART2_SyncMode_TypeDef values.
     77            * @param  Mode: This parameter can be any of the @ref UART2_Mode_TypeDef values
     78            * @retval None
     79            */

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine2:
   \   000000 CA 5244      OR        A, L:0x5244
   \   000003 C7 5244      LD        L:0x5244, A
   \   000006 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine0:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 5F           CLRW      X
   \   000003 BF ..        LDW       S:?w0, X
   \   000005 AE ....      LDW       X, #`?<Constant "G:\\\\SNAP_100\\\\stm8s_uar...">`
   \   000008 CC ....      JP        L:assert_failed

   \                                 In section .near_func.text, align 1
     80          void UART2_Init(uint32_t BaudRate, UART2_WordLength_TypeDef WordLength, UART2_StopBits_TypeDef StopBits, UART2_Parity_TypeDef Parity, UART2_SyncMode_TypeDef SyncMode, UART2_Mode_TypeDef Mode)
     81          {
   \                     UART2_Init:
   \   000000 CD ....      CALL      L:?push_l2
   \   000003 CD ....      CALL      L:?push_l3
   \   000006 3B ....      PUSH      S:?b6
   \   000009 3B ....      PUSH      S:?b7
   \   00000C CD ....      CALL      L:?mov_l2_l0
   \   00000F B7 ..        LD        S:?b14, A
   \   000011 45 .. ..     MOV       S:?b12, S:?b4
   \   000014 45 .. ..     MOV       S:?b13, S:?b5
     82              uint8_t BRR2_1 = 0, BRR2_2 = 0;
     83              uint32_t BaudRate_Mantissa = 0, BaudRate_Mantissa100 = 0;
     84          
     85              /* Check the parameters */
     86              assert_param(IS_UART2_BAUDRATE_OK(BaudRate));
   \   000017 BE ..        LDW       X, S:?w4
   \   000019 A3 0009      CPW       X, #0x9
   \   00001C 26 05        JRNE      L:??UART2_Init_0
   \   00001E BE ..        LDW       X, S:?w5
   \   000020 A3 8969      CPW       X, #0x8969
   \                     ??UART2_Init_0:
   \   000023 25 06        JRC       L:??CrossCallReturnLabel_5
   \   000025 AE 0056      LDW       X, #0x56
   \   000028 CD ....      CALL      L:?Subroutine0
     87              assert_param(IS_UART2_WORDLENGTH_OK(WordLength));
   \                     ??CrossCallReturnLabel_5:
   \   00002B 3D ..        TNZ       S:?b14
   \   00002D 27 0C        JREQ      L:??CrossCallReturnLabel_4
   \   00002F B6 ..        LD        A, S:?b14
   \   000031 A1 10        CP        A, #0x10
   \   000033 27 06        JREQ      L:??CrossCallReturnLabel_4
   \   000035 AE 0057      LDW       X, #0x57
   \   000038 CD ....      CALL      L:?Subroutine0
     88              assert_param(IS_UART2_STOPBITS_OK(StopBits));
   \                     ??CrossCallReturnLabel_4:
   \   00003B 3D ..        TNZ       S:?b12
   \   00003D 27 14        JREQ      L:??CrossCallReturnLabel_3
   \   00003F B6 ..        LD        A, S:?b12
   \   000041 A1 10        CP        A, #0x10
   \   000043 27 0E        JREQ      L:??CrossCallReturnLabel_3
   \   000045 A1 20        CP        A, #0x20
   \   000047 27 0A        JREQ      L:??CrossCallReturnLabel_3
   \   000049 A1 30        CP        A, #0x30
   \   00004B 27 06        JREQ      L:??CrossCallReturnLabel_3
   \   00004D AE 0058      LDW       X, #0x58
   \   000050 CD ....      CALL      L:?Subroutine0
     89              assert_param(IS_UART2_PARITY_OK(Parity));
   \                     ??CrossCallReturnLabel_3:
   \   000053 3D ..        TNZ       S:?b13
   \   000055 27 10        JREQ      L:??CrossCallReturnLabel_2
   \   000057 B6 ..        LD        A, S:?b13
   \   000059 A1 04        CP        A, #0x4
   \   00005B 27 0A        JREQ      L:??CrossCallReturnLabel_2
   \   00005D A1 06        CP        A, #0x6
   \   00005F 27 06        JREQ      L:??CrossCallReturnLabel_2
   \   000061 AE 0059      LDW       X, #0x59
   \   000064 CD ....      CALL      L:?Subroutine0
     90              assert_param(IS_UART2_MODE_OK((uint8_t)Mode));
   \                     ??CrossCallReturnLabel_2:
   \   000067 7B 01        LD        A, (0x1,SP)
   \   000069 A1 08        CP        A, #0x8
   \   00006B 27 22        JREQ      L:??CrossCallReturnLabel_1
   \   00006D A1 40        CP        A, #0x40
   \   00006F 27 1E        JREQ      L:??CrossCallReturnLabel_1
   \   000071 A1 04        CP        A, #0x4
   \   000073 27 1A        JREQ      L:??CrossCallReturnLabel_1
   \   000075 A1 80        CP        A, #0x80
   \   000077 27 16        JREQ      L:??CrossCallReturnLabel_1
   \   000079 A1 0C        CP        A, #0xc
   \   00007B 27 12        JREQ      L:??CrossCallReturnLabel_1
   \   00007D A1 44        CP        A, #0x44
   \   00007F 27 0E        JREQ      L:??CrossCallReturnLabel_1
   \   000081 A1 C0        CP        A, #0xc0
   \   000083 27 0A        JREQ      L:??CrossCallReturnLabel_1
   \   000085 A1 88        CP        A, #0x88
   \   000087 27 06        JREQ      L:??CrossCallReturnLabel_1
   \   000089 AE 005A      LDW       X, #0x5a
   \   00008C CD ....      CALL      L:?Subroutine0
     91              assert_param(IS_UART2_SYNCMODE_OK((uint8_t)SyncMode));
   \                     ??CrossCallReturnLabel_1:
   \   00008F 7B 02        LD        A, (0x2,SP)
   \   000091 A4 88        AND       A, #0x88
   \   000093 A1 88        CP        A, #0x88
   \   000095 27 18        JREQ      L:??UART2_Init_1
   \   000097 7B 02        LD        A, (0x2,SP)
   \   000099 A4 44        AND       A, #0x44
   \   00009B A1 44        CP        A, #0x44
   \   00009D 27 10        JREQ      L:??UART2_Init_1
   \   00009F 7B 02        LD        A, (0x2,SP)
   \   0000A1 A4 22        AND       A, #0x22
   \   0000A3 A1 22        CP        A, #0x22
   \   0000A5 27 08        JREQ      L:??UART2_Init_1
   \   0000A7 7B 02        LD        A, (0x2,SP)
   \   0000A9 A4 11        AND       A, #0x11
   \   0000AB A1 11        CP        A, #0x11
   \   0000AD 26 06        JRNE      L:??CrossCallReturnLabel_0
   \                     ??UART2_Init_1:
   \   0000AF AE 005B      LDW       X, #0x5b
   \   0000B2 CD ....      CALL      L:?Subroutine0
     92          
     93               /* Clear the word length bit */
     94              UART2->CR1 &= (uint8_t)(~UART2_CR1_M);
   \                     ??CrossCallReturnLabel_0:
   \   0000B5 7219 5244    BRES      L:0x5244, #0x4
     95              /* Set the word length bit according to UART2_WordLength value */
     96              UART2->CR1 |= (uint8_t)WordLength; 
   \   0000B9 B6 ..        LD        A, S:?b14
   \   0000BB CD ....      CALL      L:?Subroutine2
     97          
     98              /* Clear the STOP bits */
     99              UART2->CR3 &= (uint8_t)(~UART2_CR3_STOP);
   \                     ??CrossCallReturnLabel_28:
   \   0000BE C6 5246      LD        A, L:0x5246
   \   0000C1 A4 CF        AND       A, #0xcf
   \   0000C3 C7 5246      LD        L:0x5246, A
    100              /* Set the STOP bits number according to UART2_StopBits value  */
    101              UART2->CR3 |= (uint8_t)StopBits; 
   \   0000C6 B6 ..        LD        A, S:?b12
   \   0000C8 CD ....      CALL      L:?Subroutine3
    102          
    103              /* Clear the Parity Control bit */
    104              UART2->CR1 &= (uint8_t)(~(UART2_CR1_PCEN | UART2_CR1_PS  ));
   \                     ??CrossCallReturnLabel_30:
   \   0000CB C6 5244      LD        A, L:0x5244
   \   0000CE A4 F9        AND       A, #0xf9
   \   0000D0 C7 5244      LD        L:0x5244, A
    105              /* Set the Parity Control bit to UART2_Parity value */
    106              UART2->CR1 |= (uint8_t)Parity;
   \   0000D3 B6 ..        LD        A, S:?b13
   \   0000D5 CD ....      CALL      L:?Subroutine2
    107          
    108              /* Clear the LSB mantissa of UART2DIV  */
    109              UART2->BRR1 &= (uint8_t)(~UART2_BRR1_DIVM);
   \                     ??CrossCallReturnLabel_29:
   \   0000D8 C6 5242      LD        A, L:0x5242
   \   0000DB 725F 5242    CLR       L:0x5242
    110              /* Clear the MSB mantissa of UART2DIV  */
    111              UART2->BRR2 &= (uint8_t)(~UART2_BRR2_DIVM);
   \   0000DF C6 5243      LD        A, L:0x5243
   \   0000E2 A4 0F        AND       A, #0xf
   \   0000E4 C7 5243      LD        L:0x5243, A
    112              /* Clear the Fraction bits of UART2DIV */
    113              UART2->BRR2 &= (uint8_t)(~UART2_BRR2_DIVF);
   \   0000E7 C6 5243      LD        A, L:0x5243
   \   0000EA A4 F0        AND       A, #0xf0
   \   0000EC C7 5243      LD        L:0x5243, A
    114          
    115              /* Set the UART2 BaudRates in BRR1 and BRR2 registers according to UART2_BaudRate value */
    116              BaudRate_Mantissa    = ((uint32_t)CLK_GetClockFreq() / (BaudRate << 4));
   \   0000EF CD ....      CALL      L:?mov_l0_l2
   \   0000F2 CD ....      CALL      L:?sll32_l0_l0_db
   \   0000F5 04           DC8       0x4
   \   0000F6 CD ....      CALL      L:?mov_l2_l0
   \   0000F9 CD ....      CALL      L:CLK_GetClockFreq
   \   0000FC CD ....      CALL      L:?mov_l1_l2
   \   0000FF CD ....      CALL      L:?udiv32_l0_l0_l1
   \   000102 CD ....      CALL      L:?mov_l3_l0
    117              BaudRate_Mantissa100 = (((uint32_t)CLK_GetClockFreq() * 100) / (BaudRate << 4));
    118              
    119              /* The fraction and MSB mantissa should be loaded in one step in the BRR2 register*/
    120              /* Set the fraction of UARTDIV  */
    121              BRR2_1 = (uint8_t)((uint8_t)(((BaudRate_Mantissa100 - (BaudRate_Mantissa * 100))
    122                                  << 4) / 100) & (uint8_t)0x0F); 
    123              BRR2_2 = (uint8_t)((BaudRate_Mantissa >> 4) & (uint8_t)0xF0);
    124          
    125              UART2->BRR2 = (uint8_t)(BRR2_1 | BRR2_2);
   \   000105 CD ....      CALL      L:?Subroutine4
   \                     ??CrossCallReturnLabel_33:
   \   000108 CD ....      CALL      L:?push_l0
   \   00010B CD ....      CALL      L:CLK_GetClockFreq
   \   00010E CD ....      CALL      L:?Subroutine4
   \                     ??CrossCallReturnLabel_34:
   \   000111 CD ....      CALL      L:?mov_l1_l2
   \   000114 CD ....      CALL      L:?udiv32_l0_l0_l1
   \   000117 CD ....      CALL      L:?pop_l1
   \   00011A CD ....      CALL      L:?sub32_l0_l0_l1
   \   00011D CD ....      CALL      L:?sll32_l0_l0_db
   \   000120 04           DC8       0x4
   \   000121 CD ....      CALL      L:?udiv32_l0_l0_dl
   \   000124 00000064     DC32      0x64
   \   000128 B6 ..        LD        A, S:?b3
   \   00012A A4 0F        AND       A, #0xf
   \   00012C B7 ..        LD        S:?b0, A
   \   00012E BE ..        LDW       X, S:?w7
   \   000130 CD ....      CALL      L:?srl16_x_x_4
   \   000133 9F           LD        A, XL
   \   000134 A4 F0        AND       A, #0xf0
   \   000136 BA ..        OR        A, S:?b0
   \   000138 C7 5243      LD        L:0x5243, A
    126              /* Set the LSB mantissa of UARTDIV  */
    127              UART2->BRR1 = (uint8_t)BaudRate_Mantissa;           
   \   00013B B6 ..        LD        A, S:?b15
   \   00013D C7 5242      LD        L:0x5242, A
    128          
    129              /* Disable the Transmitter and Receiver before seting the LBCL, CPOL and CPHA bits */
    130              UART2->CR2 &= (uint8_t)~(UART2_CR2_TEN | UART2_CR2_REN);
   \   000140 C6 5245      LD        A, L:0x5245
   \   000143 A4 F3        AND       A, #0xf3
   \   000145 C7 5245      LD        L:0x5245, A
    131              /* Clear the Clock Polarity, lock Phase, Last Bit Clock pulse */
    132              UART2->CR3 &= (uint8_t)~(UART2_CR3_CPOL | UART2_CR3_CPHA | UART2_CR3_LBCL);
   \   000148 C6 5246      LD        A, L:0x5246
   \   00014B A4 F8        AND       A, #0xf8
   \   00014D C7 5246      LD        L:0x5246, A
    133              /* Set the Clock Polarity, lock Phase, Last Bit Clock pulse */
    134              UART2->CR3 |= (uint8_t)((uint8_t)SyncMode & (uint8_t)(UART2_CR3_CPOL | \
    135                                                        UART2_CR3_CPHA | UART2_CR3_LBCL));
   \   000150 7B 02        LD        A, (0x2,SP)
   \   000152 A4 07        AND       A, #0x7
   \   000154 CD ....      CALL      L:?Subroutine3
    136          
    137              if ((uint8_t)(Mode & UART2_MODE_TX_ENABLE))
   \                     ??CrossCallReturnLabel_31:
   \   000157 7B 01        LD        A, (0x1,SP)
   \   000159 A5 04        BCP       A, #0x4
   \   00015B 27 06        JREQ      L:??UART2_Init_2
    138              {
    139                  /* Set the Transmitter Enable bit */
    140                  UART2->CR2 |= (uint8_t)UART2_CR2_TEN;
   \   00015D 7216 5245    BSET      L:0x5245, #0x3
   \   000161 20 04        JRA       L:??UART2_Init_3
    141              }
    142              else
    143              {
    144                  /* Clear the Transmitter Disable bit */
    145                  UART2->CR2 &= (uint8_t)(~UART2_CR2_TEN);
   \                     ??UART2_Init_2:
   \   000163 7217 5245    BRES      L:0x5245, #0x3
    146              }
    147              if ((uint8_t)(Mode & UART2_MODE_RX_ENABLE))
   \                     ??UART2_Init_3:
   \   000167 7B 01        LD        A, (0x1,SP)
   \   000169 A5 08        BCP       A, #0x8
   \   00016B 27 06        JREQ      L:??UART2_Init_4
    148              {
    149                  /* Set the Receiver Enable bit */
    150                  UART2->CR2 |= (uint8_t)UART2_CR2_REN;
   \   00016D 7214 5245    BSET      L:0x5245, #0x2
   \   000171 20 04        JRA       L:??UART2_Init_5
    151              }
    152              else
    153              {
    154                  /* Clear the Receiver Disable bit */
    155                  UART2->CR2 &= (uint8_t)(~UART2_CR2_REN);
   \                     ??UART2_Init_4:
   \   000173 7215 5245    BRES      L:0x5245, #0x2
    156              }
    157              /* Set the Clock Enable bit, lock Polarity, lock Phase and Last Bit Clock 
    158                     pulse bits according to UART2_Mode value */
    159              if ((uint8_t)(SyncMode & UART2_SYNCMODE_CLOCK_DISABLE))
   \                     ??UART2_Init_5:
   \   000177 7B 02        LD        A, (0x2,SP)
   \   000179 A5 80        BCP       A, #0x80
   \   00017B 27 06        JREQ      L:??UART2_Init_6
    160              {
    161                  /* Clear the Clock Enable bit */
    162                  UART2->CR3 &= (uint8_t)(~UART2_CR3_CKEN); 
   \   00017D 7217 5246    BRES      L:0x5246, #0x3
   \   000181 20 07        JRA       L:??CrossCallReturnLabel_32
    163              }
    164              else
    165              {
    166                  UART2->CR3 |= (uint8_t)((uint8_t)SyncMode & UART2_CR3_CKEN);
   \                     ??UART2_Init_6:
   \   000183 7B 02        LD        A, (0x2,SP)
   \   000185 A4 08        AND       A, #0x8
   \   000187 CD ....      CALL      L:?Subroutine3
    167              }
    168          }
   \                     ??CrossCallReturnLabel_32:
   \   00018A 5B 02        ADD       SP, #0x2
   \   00018C CC ....      JP        L:?epilogue_l2_l3

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine4:
   \   000000 CD ....      CALL      L:?mul32_l0_l0_dl
   \   000003 00000064     DC32      0x64
   \   000007 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine3:
   \   000000 CA 5246      OR        A, L:0x5246
   \   000003 C7 5246      LD        L:0x5246, A
   \   000006 81           RET
    169          
    170          /**
    171            * @brief  Enable the UART2 peripheral.
    172            * @param  NewState : The new state of the UART Communication.
    173            *         This parameter can be any of the @ref FunctionalState enumeration.
    174            * @retval None
    175            */

   \                                 In section .near_func.text, align 1
    176          void UART2_Cmd(FunctionalState NewState)
    177          {
    178          
    179              if (NewState != DISABLE)
   \                     UART2_Cmd:
   \   000000 4D           TNZ       A
   \   000001 27 05        JREQ      L:??UART2_Cmd_0
    180              {
    181                  /* UART2 Enable */
    182                  UART2->CR1 &= (uint8_t)(~UART2_CR1_UARTD);
   \   000003 721B 5244    BRES      L:0x5244, #0x5
   \   000007 81           RET
    183              }
    184              else
    185              {
    186                  /* UART2 Disable */
    187                  UART2->CR1 |= UART2_CR1_UARTD; 
   \                     ??UART2_Cmd_0:
   \   000008 721A 5244    BSET      L:0x5244, #0x5
    188              }
    189          }
   \   00000C 81           RET
    190          
    191          /**
    192            * @brief  Enables or disables the specified UART2 interrupts.
    193            * @param  UART2_IT specifies the UART2 interrupt sources to be enabled or disabled.
    194            *         This parameter can be one of the following values:
    195            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    196            *         - UART2_IT_LHDF:  LIN Break detection interrupt
    197            *         - UART2_IT_TXE:  Tansmit Data Register empty interrupt
    198            *         - UART2_IT_TC:   Transmission complete interrupt
    199            *         - UART2_IT_RXNE_OR: Receive Data register not empty/Over run error interrupt
    200            *         - UART2_IT_IDLE: Idle line detection interrupt
    201            *         - UART2_IT_PE:   Parity Error interrupt
    202            * @param  NewState new state of the specified UART2 interrupts.
    203            *         This parameter can be: ENABLE or DISABLE.
    204            * @retval None
    205            */

   \                                 In section .near_func.text, align 1
    206          void UART2_ITConfig(UART2_IT_TypeDef UART2_IT, FunctionalState NewState)
    207          {
   \                     UART2_ITConfig:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
   \   000008 B7 ..        LD        S:?b10, A
    208              uint8_t uartreg = 0, itpos = 0x00;
    209              
    210              /* Check the parameters */
    211              assert_param(IS_UART2_CONFIG_IT_OK(UART2_IT));
   \   00000A A3 0100      CPW       X, #0x100
   \   00000D 27 24        JREQ      L:??CrossCallReturnLabel_7
   \   00000F A3 0277      CPW       X, #0x277
   \   000012 27 1F        JREQ      L:??CrossCallReturnLabel_7
   \   000014 A3 0266      CPW       X, #0x266
   \   000017 27 1A        JREQ      L:??CrossCallReturnLabel_7
   \   000019 A3 0205      CPW       X, #0x205
   \   00001C 27 15        JREQ      L:??CrossCallReturnLabel_7
   \   00001E A3 0244      CPW       X, #0x244
   \   000021 27 10        JREQ      L:??CrossCallReturnLabel_7
   \   000023 A3 0412      CPW       X, #0x412
   \   000026 27 0B        JREQ      L:??CrossCallReturnLabel_7
   \   000028 A3 0346      CPW       X, #0x346
   \   00002B 27 06        JREQ      L:??CrossCallReturnLabel_7
   \   00002D AE 00D3      LDW       X, #0xd3
   \   000030 CD ....      CALL      L:?Subroutine0
    212              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     ??CrossCallReturnLabel_7:
   \   000033 3D ..        TNZ       S:?b10
   \   000035 27 0C        JREQ      L:??CrossCallReturnLabel_6
   \   000037 B6 ..        LD        A, S:?b10
   \   000039 A1 01        CP        A, #0x1
   \   00003B 27 06        JREQ      L:??CrossCallReturnLabel_6
   \   00003D AE 00D4      LDW       X, #0xd4
   \   000040 CD ....      CALL      L:?Subroutine0
    213          
    214              /* Get the UART2 register index */
    215              uartreg = (uint8_t)((uint16_t)UART2_IT >> 0x08);
   \                     ??CrossCallReturnLabel_6:
   \   000043 BE ..        LDW       X, S:?w4
   \   000045 4F           CLR       A
   \   000046 01           RRWA      X, A
   \   000047 41           EXG       A, XL
   \   000048 B7 ..        LD        S:?b1, A
   \   00004A 41           EXG       A, XL
    216          
    217              /* Get the UART2 IT index */
    218              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART2_IT & (uint8_t)0x0F));
   \   00004B CD ....      CALL      L:?Subroutine1
    219          
    220              if (NewState != DISABLE)
   \                     ??CrossCallReturnLabel_25:
   \   00004E 3D ..        TNZ       S:?b10
   \   000050 27 2A        JREQ      L:??UART2_ITConfig_0
    221              {
    222                  /* Enable the Interrupt bits according to UART2_IT mask */
    223                  if (uartreg == 0x01)
   \   000052 B6 ..        LD        A, S:?b1
   \   000054 A1 01        CP        A, #0x1
   \   000056 26 07        JRNE      L:??UART2_ITConfig_1
    224                  {
    225                      UART2->CR1 |= itpos;
   \   000058 B6 ..        LD        A, S:?b0
   \   00005A CA 5244      OR        A, L:0x5244
   \   00005D 20 2A        JRA       L:??UART2_ITConfig_2
    226                  }
    227                  else if (uartreg == 0x02)
   \                     ??UART2_ITConfig_1:
   \   00005F A1 02        CP        A, #0x2
   \   000061 26 07        JRNE      L:??UART2_ITConfig_3
    228                  {
    229                      UART2->CR2 |= itpos;
   \   000063 B6 ..        LD        A, S:?b0
   \   000065 CA 5245      OR        A, L:0x5245
   \   000068 20 2D        JRA       L:??UART2_ITConfig_4
    230                  }
    231                  else if (uartreg == 0x03)
   \                     ??UART2_ITConfig_3:
   \   00006A A1 03        CP        A, #0x3
   \   00006C 26 07        JRNE      L:??UART2_ITConfig_5
    232                  {
    233                      UART2->CR4 |= itpos;
   \   00006E B6 ..        LD        A, S:?b0
   \   000070 CA 5247      OR        A, L:0x5247
   \   000073 20 30        JRA       L:??UART2_ITConfig_6
    234                  }
    235                  else
    236                  {
    237                      UART2->CR6 |= itpos;
   \                     ??UART2_ITConfig_5:
   \   000075 B6 ..        LD        A, S:?b0
   \   000077 CA 5249      OR        A, L:0x5249
   \   00007A 20 33        JRA       L:??UART2_ITConfig_7
    238                  }
    239              }
    240              else
    241              {
    242                  /* Disable the interrupt bits according to UART2_IT mask */
    243                  if (uartreg == 0x01)
   \                     ??UART2_ITConfig_0:
   \   00007C 33 ..        CPL       S:?b0
   \   00007E B6 ..        LD        A, S:?b1
   \   000080 A1 01        CP        A, #0x1
   \   000082 26 0A        JRNE      L:??UART2_ITConfig_8
    244                  {
    245                      UART2->CR1 &= (uint8_t)(~itpos);
   \   000084 B6 ..        LD        A, S:?b0
   \   000086 C4 5244      AND       A, L:0x5244
   \                     ??UART2_ITConfig_2:
   \   000089 C7 5244      LD        L:0x5244, A
   \   00008C 20 24        JRA       L:??UART2_ITConfig_9
    246                  }
    247                  else if (uartreg == 0x02)
   \                     ??UART2_ITConfig_8:
   \   00008E A1 02        CP        A, #0x2
   \   000090 26 0A        JRNE      L:??UART2_ITConfig_10
    248                  {
    249                      UART2->CR2 &= (uint8_t)(~itpos);
   \   000092 B6 ..        LD        A, S:?b0
   \   000094 C4 5245      AND       A, L:0x5245
   \                     ??UART2_ITConfig_4:
   \   000097 C7 5245      LD        L:0x5245, A
   \   00009A 20 16        JRA       L:??UART2_ITConfig_9
    250                  }
    251                  else if (uartreg == 0x03)
   \                     ??UART2_ITConfig_10:
   \   00009C A1 03        CP        A, #0x3
   \   00009E 26 0A        JRNE      L:??UART2_ITConfig_11
    252                  {
    253                      UART2->CR4 &= (uint8_t)(~itpos);
   \   0000A0 B6 ..        LD        A, S:?b0
   \   0000A2 C4 5247      AND       A, L:0x5247
   \                     ??UART2_ITConfig_6:
   \   0000A5 C7 5247      LD        L:0x5247, A
   \   0000A8 20 08        JRA       L:??UART2_ITConfig_9
    254                  }
    255                  else
    256                  {
    257                      UART2->CR6 &= (uint8_t)(~itpos);
   \                     ??UART2_ITConfig_11:
   \   0000AA B6 ..        LD        A, S:?b0
   \   0000AC C4 5249      AND       A, L:0x5249
   \                     ??UART2_ITConfig_7:
   \   0000AF C7 5249      LD        L:0x5249, A
    258                  }
    259              }
    260          }
   \                     ??UART2_ITConfig_9:
   \   0000B2 32 ....      POP       S:?b10
   \   0000B5 CC ....      JP        L:?epilogue_w4

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine1:
   \   000000 CD ....      CALL      L:?Subroutine5
   \                     ??CrossCallReturnLabel_36:
   \   000003 41           EXG       A, XL
   \   000004 B7 ..        LD        S:?b0, A
   \   000006 81           RET

   \                                 In section .near_func.text, align 1
   \                     ?Subroutine5:
   \   000000 A4 0F        AND       A, #0xf
   \   000002 5F           CLRW      X
   \   000003 5C           INCW      X
   \   000004 CC ....      JP        L:?sll16_x_x_a
    261          /**
    262            * @brief  Configures the UART2’s IrDA interface.
    263            * @param  UART2_IrDAMode specifies the IrDA mode.
    264            *         This parameter can be any of the @ref UART2_IrDAMode_TypeDef values.
    265            * @retval None
    266            */

   \                                 In section .near_func.text, align 1
    267          void UART2_IrDAConfig(UART2_IrDAMode_TypeDef UART2_IrDAMode)
    268          {
    269              assert_param(IS_UART2_IRDAMODE_OK(UART2_IrDAMode));
   \                     UART2_IrDAConfig:
   \   000000 A1 01        CP        A, #0x1
   \   000002 27 09        JREQ      L:??CrossCallReturnLabel_8
   \   000004 4D           TNZ       A
   \   000005 27 0B        JREQ      L:??UART2_IrDAConfig_0
   \   000007 AE 010D      LDW       X, #0x10d
   \   00000A CD ....      CALL      L:?Subroutine0
    270          
    271              if (UART2_IrDAMode != UART2_IRDAMODE_NORMAL)
    272              {
    273                  UART2->CR5 |= UART2_CR5_IRLP;
   \                     ??CrossCallReturnLabel_8:
   \   00000D 7214 5248    BSET      L:0x5248, #0x2
   \   000011 81           RET
    274              }
    275              else
    276              {
    277                  UART2->CR5 &= ((uint8_t)~UART2_CR5_IRLP);
   \                     ??UART2_IrDAConfig_0:
   \   000012 7215 5248    BRES      L:0x5248, #0x2
    278              }
    279          }
   \   000016 81           RET
    280          
    281          /**
    282            * @brief  Enables or disables the UART2’s IrDA interface.
    283            * @param  NewState new state of the IrDA mode.
    284            *         This parameter can be: ENABLE or DISABLE.
    285            * @retval None
    286            */

   \                                 In section .near_func.text, align 1
    287          void UART2_IrDACmd(FunctionalState NewState)
    288          {
    289              /* Check parameters */
    290              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_IrDACmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_IrDACmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_9
   \   000007 AE 0122      LDW       X, #0x122
   \   00000A CD ....      CALL      L:?Subroutine0
    291          
    292              if (NewState != DISABLE)
    293              {
    294                  /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    295                  UART2->CR5 |= UART2_CR5_IREN;
   \                     ??CrossCallReturnLabel_9:
   \   00000D 7212 5248    BSET      L:0x5248, #0x1
   \   000011 81           RET
    296              }
    297              else
    298              {
    299                  /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    300                  UART2->CR5 &= ((uint8_t)~UART2_CR5_IREN);
   \                     ??UART2_IrDACmd_0:
   \   000012 7213 5248    BRES      L:0x5248, #0x1
    301              }
    302          }
   \   000016 81           RET
    303          
    304          /**
    305            * @brief  Sets the UART2 LIN Break detection length.
    306            * @param  UART2_LINBreakDetectionLength specifies the LIN break detection length.
    307            *         This parameter can be any of the 
    308            *         @ref UART2_LINBreakDetectionLength_TypeDef values.
    309            * @retval None
    310            */

   \                                 In section .near_func.text, align 1
    311          void UART2_LINBreakDetectionConfig(UART2_LINBreakDetectionLength_TypeDef UART2_LINBreakDetectionLength)
    312          {
    313              /* Check parameters */    
    314              assert_param(IS_UART2_LINBREAKDETECTIONLENGTH_OK(UART2_LINBreakDetectionLength));
   \                     UART2_LINBreakDetectionConfig:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_LINBreakDetectionConfig_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_10
   \   000007 AE 013A      LDW       X, #0x13a
   \   00000A CD ....      CALL      L:?Subroutine0
    315          
    316              if (UART2_LINBreakDetectionLength != UART2_LINBREAKDETECTIONLENGTH_10BITS)
    317              {
    318                  UART2->CR4 |= UART2_CR4_LBDL;
   \                     ??CrossCallReturnLabel_10:
   \   00000D 721A 5247    BSET      L:0x5247, #0x5
   \   000011 81           RET
    319              }
    320              else
    321              {
    322                  UART2->CR4 &= ((uint8_t)~UART2_CR4_LBDL);
   \                     ??UART2_LINBreakDetectionConfig_0:
   \   000012 721B 5247    BRES      L:0x5247, #0x5
    323              }
    324          }
   \   000016 81           RET
    325          
    326          /**
    327            * @brief  Configure the UART2 peripheral.
    328            * @param  UART2_Mode specifies the LIN mode.
    329            *         This parameter can be any of the @ref UART2_LinMode_TypeDef values.
    330            * @param  UART2_Autosync specifies the LIN automatic resynchronization mode.
    331            *         This parameter can be any of the @ref UART2_LinAutosync_TypeDef values.
    332            * @param  UART2_DivUp specifies the LIN divider update method.
    333            *         This parameter can be any of the @ref UART2_LinDivUp_TypeDef values.
    334            * @retval None
    335            */

   \                                 In section .near_func.text, align 1
    336          void UART2_LINConfig(UART2_LinMode_TypeDef UART2_Mode, 
    337                               UART2_LinAutosync_TypeDef UART2_Autosync, 
    338                               UART2_LinDivUp_TypeDef UART2_DivUp)
    339          {
   \                     UART2_LINConfig:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 B7 ..        LD        S:?b8, A
   \   000008 45 .. ..     MOV       S:?b9, S:?b0
   \   00000B 45 .. ..     MOV       S:?b10, S:?b1
    340              /* Check parameters */
    341              assert_param(IS_UART2_SLAVE_OK(UART2_Mode));
   \   00000E 27 0A        JREQ      L:??CrossCallReturnLabel_13
   \   000010 A1 01        CP        A, #0x1
   \   000012 27 06        JREQ      L:??CrossCallReturnLabel_13
   \   000014 AE 0155      LDW       X, #0x155
   \   000017 CD ....      CALL      L:?Subroutine0
    342              assert_param(IS_UART2_AUTOSYNC_OK(UART2_Autosync));
   \                     ??CrossCallReturnLabel_13:
   \   00001A B6 ..        LD        A, S:?b9
   \   00001C A1 01        CP        A, #0x1
   \   00001E 27 0A        JREQ      L:??CrossCallReturnLabel_12
   \   000020 3D ..        TNZ       S:?b9
   \   000022 27 06        JREQ      L:??CrossCallReturnLabel_12
   \   000024 AE 0156      LDW       X, #0x156
   \   000027 CD ....      CALL      L:?Subroutine0
    343              assert_param(IS_UART2_DIVUP_OK(UART2_DivUp));
   \                     ??CrossCallReturnLabel_12:
   \   00002A 3D ..        TNZ       S:?b10
   \   00002C 27 0C        JREQ      L:??CrossCallReturnLabel_11
   \   00002E B6 ..        LD        A, S:?b10
   \   000030 A1 01        CP        A, #0x1
   \   000032 27 06        JREQ      L:??CrossCallReturnLabel_11
   \   000034 AE 0157      LDW       X, #0x157
   \   000037 CD ....      CALL      L:?Subroutine0
    344          
    345              if (UART2_Mode != UART2_LIN_MODE_MASTER)
   \                     ??CrossCallReturnLabel_11:
   \   00003A 3D ..        TNZ       S:?b8
   \   00003C 27 06        JREQ      L:??UART2_LINConfig_0
    346              {
    347                  UART2->CR6 |=  UART2_CR6_LSLV;
   \   00003E 721A 5249    BSET      L:0x5249, #0x5
   \   000042 20 04        JRA       L:??UART2_LINConfig_1
    348              }
    349              else
    350              {
    351                  UART2->CR6 &= ((uint8_t)~UART2_CR6_LSLV);
   \                     ??UART2_LINConfig_0:
   \   000044 721B 5249    BRES      L:0x5249, #0x5
    352              }
    353          
    354              if (UART2_Autosync != UART2_LIN_AUTOSYNC_DISABLE)
   \                     ??UART2_LINConfig_1:
   \   000048 3D ..        TNZ       S:?b9
   \   00004A 27 06        JREQ      L:??UART2_LINConfig_2
    355              {
    356                  UART2->CR6 |=  UART2_CR6_LASE ;
   \   00004C 7218 5249    BSET      L:0x5249, #0x4
   \   000050 20 04        JRA       L:??UART2_LINConfig_3
    357              }
    358              else
    359              {
    360                  UART2->CR6 &= ((uint8_t)~ UART2_CR6_LASE );
   \                     ??UART2_LINConfig_2:
   \   000052 7219 5249    BRES      L:0x5249, #0x4
    361              }
    362          
    363              if (UART2_DivUp != UART2_LIN_DIVUP_LBRR1)
   \                     ??UART2_LINConfig_3:
   \   000056 3D ..        TNZ       S:?b10
   \   000058 27 06        JREQ      L:??UART2_LINConfig_4
    364              {
    365                  UART2->CR6 |=  UART2_CR6_LDUM;
   \   00005A 721E 5249    BSET      L:0x5249, #0x7
   \   00005E 20 04        JRA       L:??UART2_LINConfig_5
    366              }
    367              else
    368              {
    369                  UART2->CR6 &= ((uint8_t)~ UART2_CR6_LDUM);
   \                     ??UART2_LINConfig_4:
   \   000060 721F 5249    BRES      L:0x5249, #0x7
    370              }
    371          }
   \                     ??UART2_LINConfig_5:
   \   000064 32 ....      POP       S:?b10
   \   000067 CC ....      JP        L:?epilogue_w4
    372          
    373          /**
    374            * @brief  Enables or disables the UART2 LIN mode.
    375            * @param  NewState is new state of the UART2 LIN mode.
    376            *         This parameter can be ENABLE or DISABLE
    377            * @retval None
    378            */

   \                                 In section .near_func.text, align 1
    379          void UART2_LINCmd(FunctionalState NewState)
    380          {
    381              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_LINCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_LINCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_14
   \   000007 AE 017D      LDW       X, #0x17d
   \   00000A CD ....      CALL      L:?Subroutine0
    382          
    383              if (NewState != DISABLE)
    384              {
    385                  /* Enable the LIN mode by setting the LINE bit in the CR2 register */
    386                  UART2->CR3 |= UART2_CR3_LINEN;
   \                     ??CrossCallReturnLabel_14:
   \   00000D 721C 5246    BSET      L:0x5246, #0x6
   \   000011 81           RET
    387              }
    388              else
    389              {
    390                  /* Disable the LIN mode by clearing the LINE bit in the CR2 register */
    391                  UART2->CR3 &= ((uint8_t)~UART2_CR3_LINEN);
   \                     ??UART2_LINCmd_0:
   \   000012 721D 5246    BRES      L:0x5246, #0x6
    392              }
    393          }
   \   000016 81           RET
    394          /**
    395            * @brief  Enables or disables the UART2 Smart Card mode.
    396            * @param  NewState: new state of the Smart Card mode.
    397            *         This parameter can be: ENABLE or DISABLE.
    398            * @retval None
    399            */

   \                                 In section .near_func.text, align 1
    400          void UART2_SmartCardCmd(FunctionalState NewState)
    401          {
    402              /* Check parameters */
    403              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_SmartCardCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_SmartCardCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_15
   \   000007 AE 0193      LDW       X, #0x193
   \   00000A CD ....      CALL      L:?Subroutine0
    404          
    405              if (NewState != DISABLE)
    406              {
    407                  /* Enable the SC mode by setting the SCEN bit in the CR5 register */
    408                  UART2->CR5 |= UART2_CR5_SCEN;
   \                     ??CrossCallReturnLabel_15:
   \   00000D 721A 5248    BSET      L:0x5248, #0x5
   \   000011 81           RET
    409              }
    410              else
    411              {
    412                  /* Disable the SC mode by clearing the SCEN bit in the CR5 register */
    413                  UART2->CR5 &= ((uint8_t)(~UART2_CR5_SCEN));
   \                     ??UART2_SmartCardCmd_0:
   \   000012 721B 5248    BRES      L:0x5248, #0x5
    414              }
    415          }
   \   000016 81           RET
    416          
    417          /**
    418            * @brief  Enables or disables NACK transmission.
    419            * @param  NewState: new state of the Smart Card mode.
    420            *         This parameter can be: ENABLE or DISABLE.
    421            * @retval None
    422            */

   \                                 In section .near_func.text, align 1
    423          void UART2_SmartCardNACKCmd(FunctionalState NewState)
    424          {
    425              /* Check parameters */
    426              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_SmartCardNACKCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_SmartCardNACKCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_16
   \   000007 AE 01AA      LDW       X, #0x1aa
   \   00000A CD ....      CALL      L:?Subroutine0
    427          
    428              if (NewState != DISABLE)
    429              {
    430                  /* Enable the NACK transmission by setting the NACK bit in the CR5 register */
    431                  UART2->CR5 |= UART2_CR5_NACK;
   \                     ??CrossCallReturnLabel_16:
   \   00000D 7218 5248    BSET      L:0x5248, #0x4
   \   000011 81           RET
    432              }
    433              else
    434              {
    435                  /* Disable the NACK transmission by clearing the NACK bit in the CR5 register */
    436                  UART2->CR5 &= ((uint8_t)~(UART2_CR5_NACK));
   \                     ??UART2_SmartCardNACKCmd_0:
   \   000012 7219 5248    BRES      L:0x5248, #0x4
    437              }
    438          }
   \   000016 81           RET
    439          
    440          /**
    441            * @brief  Selects the UART2 WakeUp method.
    442            * @param  UART2_WakeUp: specifies the UART2 wakeup method.
    443            *         This parameter can be any of the @ref UART2_WakeUp_TypeDef values.
    444            * @retval None
    445            */

   \                                 In section .near_func.text, align 1
    446          void UART2_WakeUpConfig(UART2_WakeUp_TypeDef UART2_WakeUp)
    447          {
   \                     UART2_WakeUpConfig:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    448              assert_param(IS_UART2_WAKEUP_OK(UART2_WakeUp));
   \   000005 27 0A        JREQ      L:??CrossCallReturnLabel_17
   \   000007 A1 08        CP        A, #0x8
   \   000009 27 06        JREQ      L:??CrossCallReturnLabel_17
   \   00000B AE 01C0      LDW       X, #0x1c0
   \   00000E CD ....      CALL      L:?Subroutine0
    449          
    450              UART2->CR1 &= ((uint8_t)~UART2_CR1_WAKE);
   \                     ??CrossCallReturnLabel_17:
   \   000011 7217 5244    BRES      L:0x5244, #0x3
    451              UART2->CR1 |= (uint8_t)UART2_WakeUp;
   \   000015 B6 ..        LD        A, S:?b8
   \   000017 CD ....      CALL      L:?Subroutine2
    452          }
   \                     ??CrossCallReturnLabel_27:
   \   00001A 32 ....      POP       S:?b8
   \   00001D 81           RET
    453          
    454          /**
    455            * @brief  Determines if the UART2 is in mute mode or not.
    456            * @param  NewState: new state of the UART2 mode.
    457            *         This parameter can be ENABLE or DISABLE
    458            * @retval None
    459            */

   \                                 In section .near_func.text, align 1
    460          void UART2_ReceiverWakeUpCmd(FunctionalState NewState)
    461          {
    462              assert_param(IS_FUNCTIONALSTATE_OK(NewState));
   \                     UART2_ReceiverWakeUpCmd:
   \   000000 4D           TNZ       A
   \   000001 27 0F        JREQ      L:??UART2_ReceiverWakeUpCmd_0
   \   000003 A1 01        CP        A, #0x1
   \   000005 27 06        JREQ      L:??CrossCallReturnLabel_18
   \   000007 AE 01CE      LDW       X, #0x1ce
   \   00000A CD ....      CALL      L:?Subroutine0
    463          
    464              if (NewState != DISABLE)
    465              {
    466                  /* Enable the mute mode UART2 by setting the RWU bit in the CR2 register */
    467                  UART2->CR2 |= UART2_CR2_RWU;
   \                     ??CrossCallReturnLabel_18:
   \   00000D 7212 5245    BSET      L:0x5245, #0x1
   \   000011 81           RET
    468              }
    469              else
    470              {
    471                  /* Disable the mute mode UART2 by clearing the RWU bit in the CR1 register */
    472                  UART2->CR2 &= ((uint8_t)~UART2_CR2_RWU);
   \                     ??UART2_ReceiverWakeUpCmd_0:
   \   000012 7213 5245    BRES      L:0x5245, #0x1
    473              }
    474          }
   \   000016 81           RET
    475          
    476          /**
    477            * @brief  Returns the most recent received data by the UART2 peripheral.
    478            * @param  None
    479            * @retval Received Data
    480            */

   \                                 In section .near_func.text, align 1
    481          uint8_t UART2_ReceiveData8(void)
    482          {
    483              return ((uint8_t)UART2->DR);
   \                     UART2_ReceiveData8:
   \   000000 C6 5241      LD        A, L:0x5241
   \   000003 81           RET
    484          }
    485          
    486          /**
    487            * @brief  Returns the most recent received data by the UART2 peripheral.
    488            * @param  None  
    489            * @retval Received Data
    490            */

   \                                 In section .near_func.text, align 1
    491          uint16_t UART2_ReceiveData9(void)
    492          {
    493            uint16_t temp = 0;
    494          
    495            temp = ((uint16_t)(((uint16_t)((uint16_t)UART2->CR1 & (uint16_t)UART2_CR1_R8)) << 1));
   \                     UART2_ReceiveData9:
   \   000000 C6 5244      LD        A, L:0x5244
    496            
    497            return (uint16_t)((((uint16_t)UART2->DR) | temp) & ((uint16_t)0x01FF));
   \   000003 5F           CLRW      X
   \   000004 97           LD        XL, A
   \   000005 01           RRWA      X, A
   \   000006 A4 80        AND       A, #0x80
   \   000008 02           RLWA      X, A
   \   000009 58           SLLW      X
   \   00000A C6 5241      LD        A, L:0x5241
   \   00000D 905F         CLRW      Y
   \   00000F 9097         LD        YL, A
   \   000011 BF ..        LDW       S:?w0, X
   \   000013 93           LDW       X, Y
   \   000014 02           RLWA      X, A
   \   000015 BA ..        OR        A, S:?b0
   \   000017 01           RRWA      X, A
   \   000018 81           RET
    498          }
    499          
    500          /**
    501            * @brief  Transmits 8 bit data through the UART2 peripheral.
    502            * @param  Data: the data to transmit.
    503            * @retval None
    504            */

   \                                 In section .near_func.text, align 1
    505          void UART2_SendData8(uint8_t Data)
    506          {
    507              /* Transmit Data */
    508              UART2->DR = Data;
   \                     UART2_SendData8:
   \   000000 C7 5241      LD        L:0x5241, A
    509          }
   \   000003 81           RET
    510          
    511          /**
    512            * @brief  Transmits 9 bit data through the UART2 peripheral.
    513            * @param  Data: the data to transmit.
    514            * @retval None
    515            */

   \                                 In section .near_func.text, align 1
    516          void UART2_SendData9(uint16_t Data)
    517          {
   \                     UART2_SendData9:
   \   000000 9093         LDW       Y, X
    518              /* Clear the transmit data bit 8 */
    519              UART2->CR1 &= ((uint8_t)~UART2_CR1_T8);                  
   \   000002 721D 5244    BRES      L:0x5244, #0x6
    520              
    521              /* Write the transmit data bit [8] */
    522              UART2->CR1 |= (uint8_t)(((uint8_t)(Data >> 2)) & UART2_CR1_T8); 
   \   000006 54           SRLW      X
   \   000007 54           SRLW      X
   \   000008 9F           LD        A, XL
   \   000009 A4 40        AND       A, #0x40
   \   00000B CD ....      CALL      L:?Subroutine2
    523              
    524              /* Write the transmit data bit [0:7] */
    525              UART2->DR   = (uint8_t)(Data);                    
   \                     ??CrossCallReturnLabel_26:
   \   00000E 909F         LD        A, YL
   \   000010 C7 5241      LD        L:0x5241, A
    526          
    527          }
   \   000013 81           RET
    528          
    529          /**
    530            * @brief  Transmits break characters.
    531            * @param  None
    532            * @retval None
    533            */

   \                                 In section .near_func.text, align 1
    534          void UART2_SendBreak(void)
    535          {
    536              UART2->CR2 |= UART2_CR2_SBK;
   \                     UART2_SendBreak:
   \   000000 7210 5245    BSET      L:0x5245, #0x0
    537          }
   \   000004 81           RET
    538          
    539          /**
    540            * @brief  Sets the address of the UART2 node.
    541            * @param  UART2_Address: Indicates the address of the UART2 node.
    542            * @retval None
    543            */

   \                                 In section .near_func.text, align 1
    544          void UART2_SetAddress(uint8_t UART2_Address)
    545          {
   \                     UART2_SetAddress:
   \   000000 3B ....      PUSH      S:?b8
   \   000003 B7 ..        LD        S:?b8, A
    546              /*assert_param for x UART2_Address*/
    547              assert_param(IS_UART2_ADDRESS_OK(UART2_Address));
   \   000005 A1 10        CP        A, #0x10
   \   000007 25 06        JRC       L:??CrossCallReturnLabel_19
   \   000009 AE 0223      LDW       X, #0x223
   \   00000C CD ....      CALL      L:?Subroutine0
    548          
    549              /* Clear the UART2 address */
    550              UART2->CR4 &= ((uint8_t)~UART2_CR4_ADD);
   \                     ??CrossCallReturnLabel_19:
   \   00000F C6 5247      LD        A, L:0x5247
   \   000012 A4 F0        AND       A, #0xf0
   \   000014 C7 5247      LD        L:0x5247, A
    551              /* Set the UART2 address node */
    552              UART2->CR4 |= UART2_Address;
   \   000017 B6 ..        LD        A, S:?b8
   \   000019 CA 5247      OR        A, L:0x5247
   \   00001C C7 5247      LD        L:0x5247, A
    553          }
   \   00001F 32 ....      POP       S:?b8
   \   000022 81           RET
    554          
    555          /**
    556            * @brief  Sets the specified UART2 guard time.
    557            * @note   SmartCard Mode should be Enabled  
    558            * @param  UART2_GuardTime: specifies the guard time.
    559            * @retval None
    560            */

   \                                 In section .near_func.text, align 1
    561          void UART2_SetGuardTime(uint8_t UART2_GuardTime)
    562          {
    563              /* Set the UART2 guard time */
    564              UART2->GTR = UART2_GuardTime;
   \                     UART2_SetGuardTime:
   \   000000 C7 524A      LD        L:0x524a, A
    565          }
   \   000003 81           RET
    566          
    567          /**
    568            * @brief  Sets the system clock prescaler.
    569            * @note   IrDA Low Power mode or smartcard mode should be enabled
    570            * @note   This function is related to SmartCard and IrDa mode.
    571            * @param  UART2_Prescaler: specifies the prescaler clock.
    572            *         This parameter can be one of the following values:
    573            *         @par IrDA Low Power Mode
    574            *         The clock source is divided by the value given in the register (8 bits)
    575            *         - 0000 0000 Reserved
    576            *         - 0000 0001 divides the clock source by 1
    577            *         - 0000 0010 divides the clock source by 2
    578            *         - ...........................................................
    579            *        @par Smart Card Mode
    580            *        The clock source is divided by the value given in the register
    581            *        (5 significant bits) multiped by 2
    582            *         - 0 0000 Reserved
    583            *         - 0 0001 divides the clock source by 2
    584            *         - 0 0010 divides the clock source by 4
    585            *         - 0 0011 divides the clock source by 6
    586            *         - ...........................................................
    587            * @retval None
    588            */

   \                                 In section .near_func.text, align 1
    589          void UART2_SetPrescaler(uint8_t UART2_Prescaler)
    590          {
    591              /* Load the UART2 prescaler value*/
    592              UART2->PSCR = UART2_Prescaler;
   \                     UART2_SetPrescaler:
   \   000000 C7 524B      LD        L:0x524b, A
    593          }
   \   000003 81           RET
    594          
    595          /**
    596            * @brief  Checks whether the specified UART2 flag is set or not.
    597            * @param  UART2_FLAG specifies the flag to check.
    598            *         This parameter can be any of the @ref UART2_Flag_TypeDef enumeration.
    599            * @retval FlagStatus (SET or RESET)
    600            */

   \                                 In section .near_func.text, align 1
    601          FlagStatus UART2_GetFlagStatus(UART2_Flag_TypeDef UART2_FLAG)
    602          {
   \                     UART2_GetFlagStatus:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
    603              FlagStatus status = RESET;
   \   000008 3F ..        CLR       S:?b10
    604          
    605              /* Check parameters */
    606              assert_param(IS_UART2_FLAG_OK(UART2_FLAG));
   \   00000A A3 0080      CPW       X, #0x80
   \   00000D 27 3D        JREQ      L:??CrossCallReturnLabel_20
   \   00000F A3 0040      CPW       X, #0x40
   \   000012 27 38        JREQ      L:??CrossCallReturnLabel_20
   \   000014 A3 0020      CPW       X, #0x20
   \   000017 27 33        JREQ      L:??CrossCallReturnLabel_20
   \   000019 A3 0010      CPW       X, #0x10
   \   00001C 27 2E        JREQ      L:??CrossCallReturnLabel_20
   \   00001E A3 0008      CPW       X, #0x8
   \   000021 27 29        JREQ      L:??CrossCallReturnLabel_20
   \   000023 A3 0004      CPW       X, #0x4
   \   000026 27 24        JREQ      L:??CrossCallReturnLabel_20
   \   000028 A3 0002      CPW       X, #0x2
   \   00002B 27 1F        JREQ      L:??CrossCallReturnLabel_20
   \   00002D A3 0001      CPW       X, #0x1
   \   000030 27 1A        JREQ      L:??CrossCallReturnLabel_20
   \   000032 A3 0101      CPW       X, #0x101
   \   000035 27 2F        JREQ      L:??UART2_GetFlagStatus_0
   \   000037 A3 0301      CPW       X, #0x301
   \   00003A 27 31        JREQ      L:??UART2_GetFlagStatus_1
   \   00003C A3 0302      CPW       X, #0x302
   \   00003F 27 2C        JREQ      L:??UART2_GetFlagStatus_1
   \   000041 A3 0210      CPW       X, #0x210
   \   000044 27 19        JREQ      L:??UART2_GetFlagStatus_2
   \   000046 AE 025E      LDW       X, #0x25e
   \   000049 CD ....      CALL      L:?Subroutine0
    607          
    608              /* Check the status of the specified UART2 flag*/
    609              if (UART2_FLAG == UART2_FLAG_LBDF)
    610              {
    611                  if ((UART2->CR4 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    612                  {
    613                      /* UART2_FLAG is set*/
    614                      status = SET;
    615                  }
    616                  else
    617                  {
    618                      /* UART2_FLAG is reset*/
    619                      status = RESET;
    620                  }
    621              }
    622              else if (UART2_FLAG == UART2_FLAG_SBK)
    623              {
    624                  if ((UART2->CR2 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    625                  {
    626                      /* UART2_FLAG is set*/
    627                      status = SET;
    628                  }
    629                  else
    630                  {
    631                      /* UART2_FLAG is reset*/
    632                      status = RESET;
    633                  }
    634              }
    635              else if ((UART2_FLAG == UART2_FLAG_LHDF) || (UART2_FLAG == UART2_FLAG_LSF))
    636              {
    637                  if ((UART2->CR6 & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
    638                  {
    639                      /* UART2_FLAG is set*/
    640                      status = SET;
    641                  }
    642                  else
    643                  {
    644                      /* UART2_FLAG is reset*/
    645                      status = RESET;
    646                  }
    647              }
    648              else
    649              {
    650                  if ((UART2->SR & (uint8_t)UART2_FLAG) != (uint8_t)0x00)
   \                     ??CrossCallReturnLabel_20:
   \   00004C B6 ..        LD        A, S:?b9
   \   00004E C5 5240      BCP       A, L:0x5240
   \   000051 27 04        JREQ      L:??UART2_GetFlagStatus_3
    651                  {
    652                      /* UART2_FLAG is set*/
    653                      status = SET;
   \                     ??UART2_GetFlagStatus_4:
   \   000053 35 01 ....   MOV       S:?b10, #0x1
    654                  }
    655                  else
    656                  {
    657                      /* UART2_FLAG is reset*/
    658                      status = RESET;
    659                  }
    660              }
    661          
    662              /* Return the UART2_FLAG status*/
    663              return  status;
   \                     ??UART2_GetFlagStatus_3:
   \   000057 B6 ..        LD        A, S:?b10
   \   000059 32 ....      POP       S:?b10
   \   00005C CC ....      JP        L:?epilogue_w4
   \                     ??UART2_GetFlagStatus_2:
   \   00005F 7208 5247 EF BTJT      L:0x5247, #0x4, L:??UART2_GetFlagStatus_4
   \   000064 20 F1        JRA       L:??UART2_GetFlagStatus_3
   \                     ??UART2_GetFlagStatus_0:
   \   000066 7200 5245 E8 BTJT      L:0x5245, #0x0, L:??UART2_GetFlagStatus_4
   \   00006B 20 EA        JRA       L:??UART2_GetFlagStatus_3
   \                     ??UART2_GetFlagStatus_1:
   \   00006D B6 ..        LD        A, S:?b9
   \   00006F C5 5249      BCP       A, L:0x5249
   \   000072 26 DF        JRNE      L:??UART2_GetFlagStatus_4
   \   000074 20 E1        JRA       L:??UART2_GetFlagStatus_3
    664          }
    665          /**
    666            * @brief  Clears the UART2 flags.
    667            * @param  UART2_FLAG specifies the flag to clear
    668            *         This parameter can be any combination of the following values:
    669            *         - UART2_FLAG_LBDF: LIN Break detection flag.
    670            *         - UART2_FLAG_LHDF: LIN Header detection flag.
    671            *         - UART2_FLAG_LSF: LIN synchrone field flag.
    672            *         - UART2_FLAG_RXNE: Receive data register not empty flag.
    673            * @note:
    674            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    675            *           OR (OverRun error) and IDLE (Idle line detected) flags are cleared
    676            *           by software sequence: a read operation to UART2_SR register 
    677            *           (UART2_GetFlagStatus())followed by a read operation to UART2_DR 
    678            *           register(UART2_ReceiveData8() or UART2_ReceiveData9()).
    679            *        
    680            *         - RXNE flag can be also cleared by a read to the UART2_DR register
    681            *           (UART2_ReceiveData8()or UART2_ReceiveData9()).
    682            *
    683            *         - TC flag can be also cleared by software sequence: a read operation
    684            *           to UART2_SR register (UART2_GetFlagStatus()) followed by a write 
    685            *           operation to UART2_DR register (UART2_SendData8() or UART2_SendData9()).
    686            *             
    687            *         - TXE flag is cleared only by a write to the UART2_DR register 
    688            *           (UART2_SendData8() or UART2_SendData9()).
    689            *             
    690            *         - SBK flag is cleared during the stop bit of break.
    691            * @retval None
    692            */

   \                                 In section .near_func.text, align 1
    693          void UART2_ClearFlag(UART2_Flag_TypeDef UART2_FLAG)
    694          {
    695              assert_param(IS_UART2_CLEAR_FLAG_OK(UART2_FLAG));
   \                     UART2_ClearFlag:
   \   000000 A3 0020      CPW       X, #0x20
   \   000003 27 1A        JREQ      L:??UART2_ClearFlag_0
   \   000005 A3 0302      CPW       X, #0x302
   \   000008 27 1F        JREQ      L:??UART2_ClearFlag_1
   \   00000A A3 0301      CPW       X, #0x301
   \   00000D 27 0B        JREQ      L:??CrossCallReturnLabel_21
   \   00000F A3 0210      CPW       X, #0x210
   \   000012 27 10        JREQ      L:??UART2_ClearFlag_2
   \   000014 AE 02B7      LDW       X, #0x2b7
   \   000017 CD ....      CALL      L:?Subroutine0
    696          
    697              /*  Clear the Receive Register Not Empty flag */
    698              if (UART2_FLAG == UART2_FLAG_RXNE)
    699              {
    700                  UART2->SR = (uint8_t)~(UART2_SR_RXNE);
    701              }
    702              /*  Clear the LIN Break Detection flag */
    703              else if (UART2_FLAG == UART2_FLAG_LBDF)
    704              {
    705                  UART2->CR4 &= (uint8_t)(~UART2_CR4_LBDF);
    706              }
    707              /*  Clear the LIN Header Detection Flag */
    708              else if (UART2_FLAG == UART2_FLAG_LHDF)
    709              {
    710                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LHDF);
    711              }
    712              /*  Clear the LIN Synch Field flag */
    713              else
    714              {
    715                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LSF);
   \                     ??CrossCallReturnLabel_21:
   \   00001A 7211 5249    BRES      L:0x5249, #0x0
    716              }
    717          }
   \   00001E 81           RET
   \                     ??UART2_ClearFlag_0:
   \   00001F 35 DF 5240   MOV       L:0x5240, #0xdf
   \   000023 81           RET
   \                     ??UART2_ClearFlag_2:
   \   000024 7219 5247    BRES      L:0x5247, #0x4
   \   000028 81           RET
   \                     ??UART2_ClearFlag_1:
   \   000029 7213 5249    BRES      L:0x5249, #0x1
   \   00002D 81           RET
    718          
    719          /**
    720            * @brief  Checks whether the specified UART2 interrupt has occurred or not.
    721            * @param  UART2_IT: Specifies the UART2 interrupt pending bit to check.
    722            *         This parameter can be one of the following values:
    723            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    724            *         - UART2_IT_TXE:  Tansmit Data Register empty interrupt
    725            *         - UART2_IT_TC:   Transmission complete interrupt
    726            *         - UART2_IT_RXNE: Receive Data register not empty interrupt
    727            *         - UART2_IT_IDLE: Idle line detection interrupt
    728            *         - UART2_IT_OR:  OverRun Error interrupt
    729            *         - UART2_IT_PE:   Parity Error interrupt
    730            * @retval The state of UART2_IT (SET or RESET).
    731            */

   \                                 In section .near_func.text, align 1
    732          ITStatus UART2_GetITStatus(UART2_IT_TypeDef UART2_IT)
    733          {
   \                     UART2_GetITStatus:
   \   000000 CD ....      CALL      L:?push_w4
   \   000003 3B ....      PUSH      S:?b10
   \   000006 BF ..        LDW       S:?w4, X
    734              ITStatus pendingbitstatus = RESET;
   \   000008 3F ..        CLR       S:?b10
    735              uint8_t itpos = 0;
    736              uint8_t itmask1 = 0;
    737              uint8_t itmask2 = 0;
    738              uint8_t enablestatus = 0;
    739          
    740              /* Check parameters */
    741              assert_param(IS_UART2_GET_IT_OK(UART2_IT));
   \   00000A A3 0277      CPW       X, #0x277
   \   00000D 27 29        JREQ      L:??CrossCallReturnLabel_22
   \   00000F A3 0266      CPW       X, #0x266
   \   000012 27 24        JREQ      L:??CrossCallReturnLabel_22
   \   000014 A3 0255      CPW       X, #0x255
   \   000017 27 1F        JREQ      L:??CrossCallReturnLabel_22
   \   000019 A3 0244      CPW       X, #0x244
   \   00001C 27 1A        JREQ      L:??CrossCallReturnLabel_22
   \   00001E A3 0235      CPW       X, #0x235
   \   000021 27 15        JREQ      L:??CrossCallReturnLabel_22
   \   000023 A3 0346      CPW       X, #0x346
   \   000026 27 10        JREQ      L:??CrossCallReturnLabel_22
   \   000028 A3 0412      CPW       X, #0x412
   \   00002B 27 0B        JREQ      L:??CrossCallReturnLabel_22
   \   00002D A3 0100      CPW       X, #0x100
   \   000030 27 06        JREQ      L:??CrossCallReturnLabel_22
   \   000032 AE 02E5      LDW       X, #0x2e5
   \   000035 CD ....      CALL      L:?Subroutine0
    742          
    743              /* Get the UART2 IT index*/
    744              itpos = (uint8_t)((uint8_t)1 << (uint8_t)((uint8_t)UART2_IT & (uint8_t)0x0F));
   \                     ??CrossCallReturnLabel_22:
   \   000038 B6 ..        LD        A, S:?b9
   \   00003A CD ....      CALL      L:?Subroutine1
    745              /* Get the UART2 IT index*/
    746              itmask1 = (uint8_t)((uint8_t)UART2_IT >> (uint8_t)4);
    747              /* Set the IT mask*/
    748              itmask2 = (uint8_t)((uint8_t)1 << itmask1);
   \                     ??CrossCallReturnLabel_24:
   \   00003D B6 ..        LD        A, S:?b9
   \   00003F 4E           SWAP      A
   \   000040 CD ....      CALL      L:?Subroutine5
   \                     ??CrossCallReturnLabel_35:
   \   000043 9F           LD        A, XL
    749          
    750              /* Check the status of the specified UART2 pending bit*/
    751              if (UART2_IT == UART2_IT_PE)
   \   000044 BE ..        LDW       X, S:?w4
   \   000046 A3 0100      CPW       X, #0x100
   \   000049 26 0C        JRNE      L:??UART2_GetITStatus_0
    752              {
    753                  /* Get the UART2_ITPENDINGBIT enable bit status*/
    754                  enablestatus = (uint8_t)((uint8_t)UART2->CR1 & itmask2);
   \   00004B C4 5244      AND       A, L:0x5244
   \   00004E B7 ..        LD        S:?b1, A
    755                  /* Check the status of the specified UART2 interrupt*/
    756          
    757                  if (((UART2->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000050 B6 ..        LD        A, S:?b0
   \   000052 C4 5240      AND       A, L:0x5240
   \   000055 20 20        JRA       L:??UART2_GetITStatus_1
    758                  {
    759                      /* Interrupt occurred*/
    760                      pendingbitstatus = SET;
    761                  }
    762                  else
    763                  {
    764                      /* Interrupt not occurred*/
    765                      pendingbitstatus = RESET;
    766                  }
    767              }
    768              else if (UART2_IT == UART2_IT_LBDF)
   \                     ??UART2_GetITStatus_0:
   \   000057 A3 0346      CPW       X, #0x346
   \   00005A 26 0C        JRNE      L:??UART2_GetITStatus_2
    769              {
    770                  /* Get the UART2_IT enable bit status*/
    771                  enablestatus = (uint8_t)((uint8_t)UART2->CR4 & itmask2);
   \   00005C C4 5247      AND       A, L:0x5247
   \   00005F B7 ..        LD        S:?b1, A
    772                  /* Check the status of the specified UART2 interrupt*/
    773                  if (((UART2->CR4 & itpos) != (uint8_t)0x00) && enablestatus)
   \   000061 B6 ..        LD        A, S:?b0
   \   000063 C4 5247      AND       A, L:0x5247
   \   000066 20 0F        JRA       L:??UART2_GetITStatus_1
    774                  {
    775                      /* Interrupt occurred*/
    776                      pendingbitstatus = SET;
    777                  }
    778                  else
    779                  {
    780                      /* Interrupt not occurred*/
    781                      pendingbitstatus = RESET;
    782                  }
    783              }
    784              else if (UART2_IT == UART2_IT_LHDF)
   \                     ??UART2_GetITStatus_2:
   \   000068 A3 0412      CPW       X, #0x412
   \   00006B 26 10        JRNE      L:??UART2_GetITStatus_3
    785              {
    786                  /* Get the UART2_IT enable bit status*/
    787                  enablestatus = (uint8_t)((uint8_t)UART2->CR6 & itmask2);
   \   00006D C4 5249      AND       A, L:0x5249
   \   000070 B7 ..        LD        S:?b1, A
    788                  /* Check the status of the specified UART2 interrupt*/
    789                  if (((UART2->CR6 & itpos) != (uint8_t)0x00) && enablestatus)
   \   000072 B6 ..        LD        A, S:?b0
   \   000074 C4 5249      AND       A, L:0x5249
   \                     ??UART2_GetITStatus_1:
   \   000077 A1 00        CP        A, #0x0
   \   000079 26 0E        JRNE      L:??UART2_GetITStatus_4
   \   00007B 20 14        JRA       L:??UART2_GetITStatus_5
    790                  {
    791                      /* Interrupt occurred*/
    792                      pendingbitstatus = SET;
    793                  }
    794                  else
    795                  {
    796                      /* Interrupt not occurred*/
    797                      pendingbitstatus = RESET;
    798                  }
    799              }
    800              else
    801              {
    802                  /* Get the UART2_IT enable bit status*/
    803                  enablestatus = (uint8_t)((uint8_t)UART2->CR2 & itmask2);
   \                     ??UART2_GetITStatus_3:
   \   00007D C4 5245      AND       A, L:0x5245
   \   000080 B7 ..        LD        S:?b1, A
    804                  /* Check the status of the specified UART2 interrupt*/
    805                  if (((UART2->SR & itpos) != (uint8_t)0x00) && enablestatus)
   \   000082 B6 ..        LD        A, S:?b0
   \   000084 C5 5240      BCP       A, L:0x5240
   \   000087 27 08        JREQ      L:??UART2_GetITStatus_5
   \                     ??UART2_GetITStatus_4:
   \   000089 3D ..        TNZ       S:?b1
   \   00008B 27 04        JREQ      L:??UART2_GetITStatus_5
    806                  {
    807                      /* Interrupt occurred*/
    808                      pendingbitstatus = SET;
   \   00008D 35 01 ....   MOV       S:?b10, #0x1
    809                  }
    810                  else
    811                  {
    812                      /* Interrupt not occurred*/
    813                      pendingbitstatus = RESET;
    814                  }
    815              }
    816              /* Return the UART2_IT status*/
    817              return  pendingbitstatus;
   \                     ??UART2_GetITStatus_5:
   \   000091 B6 ..        LD        A, S:?b10
   \   000093 32 ....      POP       S:?b10
   \   000096 CC ....      JP        L:?epilogue_w4
    818          }
    819          
    820          /**
    821            * @brief  Clears the UART2 pending flags.
    822            * @param  UART2_IT specifies the pending bit to clear
    823            *         This parameter can be one of the following values:
    824            *         - UART2_IT_LBDF:  LIN Break detection interrupt
    825            *         - UART2_IT_LHDF:  LIN Header detection interrupt
    826            *         - UART2_IT_RXNE: Receive Data register not empty interrupt.
    827            * @note
    828            *         - PE (Parity error), FE (Framing error), NE (Noise error), 
    829            *           OR (OverRun error) and IDLE (Idle line detected) pending bits are 
    830            *           cleared by software sequence: a read operation to UART2_SR register
    831            *           (UART2_GetITStatus()) followed by a read operation to UART2_DR register
    832            *           (UART2_ReceiveData8() or UART2_ReceiveData9()).
    833            *             
    834            *         - RXNE pending bit can be also cleared by a read to the UART2_DR 
    835            *           register (UART2_ReceiveData8() or UART2_ReceiveData9()).
    836            *              
    837            *         - TC (Transmit complete) pending bit can be cleared by software 
    838            *           sequence: a read operation to UART2_SR register 
    839            *           (UART2_GetITStatus()) followed by a write operation to UART2_DR 
    840            *           register (UART2_SendData8()or UART2_SendData9()).
    841            *               
    842            *         - TXE pending bit is cleared only by a write to the UART2_DR register
    843            *           (UART2_SendData8() or UART2_SendData9()).
    844            * @retval None
    845            */

   \                                 In section .near_func.text, align 1
    846          void UART2_ClearITPendingBit(UART2_IT_TypeDef UART2_IT)
    847          {
    848              assert_param(IS_UART2_CLEAR_IT_OK(UART2_IT));
   \                     UART2_ClearITPendingBit:
   \   000000 A3 0255      CPW       X, #0x255
   \   000003 27 15        JREQ      L:??UART2_ClearITPendingBit_0
   \   000005 A3 0412      CPW       X, #0x412
   \   000008 27 0B        JREQ      L:??CrossCallReturnLabel_23
   \   00000A A3 0346      CPW       X, #0x346
   \   00000D 27 10        JREQ      L:??UART2_ClearITPendingBit_1
   \   00000F AE 0350      LDW       X, #0x350
   \   000012 CD ....      CALL      L:?Subroutine0
    849          
    850              /*  Clear the Receive Register Not Empty pending bit */
    851              if (UART2_IT == UART2_IT_RXNE)
    852              {
    853                  UART2->SR = (uint8_t)~(UART2_SR_RXNE);
    854              }
    855              /*  Clear the LIN Break Detection pending bit */
    856              else if (UART2_IT == UART2_IT_LBDF)
    857              {
    858                  UART2->CR4 &= (uint8_t)~(UART2_CR4_LBDF);
    859              }
    860              /*  Clear the LIN Header Detection pending bit */
    861              else
    862              {
    863                  UART2->CR6 &= (uint8_t)(~UART2_CR6_LHDF);
   \                     ??CrossCallReturnLabel_23:
   \   000015 7213 5249    BRES      L:0x5249, #0x1
    864              }
    865          }
   \   000019 81           RET
   \                     ??UART2_ClearITPendingBit_0:
   \   00001A 35 DF 5240   MOV       L:0x5240, #0xdf
   \   00001E 81           RET
   \                     ??UART2_ClearITPendingBit_1:
   \   00001F 7219 5247    BRES      L:0x5247, #0x4
   \   000023 81           RET

   \                                 In section .near.rodata, align 1
   \                     `?<Constant "G:\\\\SNAP_100\\\\stm8s_uar...">`:
   \   000000 47 3A 5C 53  DC8 "G:\\SNAP_100\\stm8s_uart2.c"
   \          4E 41 50 5F 
    866          /**
    867            * @}
    868            */
    869          
    870          /**
    871            * @}
    872            */
    873          
    874          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      26  ?<Constant "G:\\SNAP_100\\stm8s_uar...">
      11  ?Subroutine0
       7  ?Subroutine1
       7  ?Subroutine2
       7  ?Subroutine3
       8  ?Subroutine4
       7  ?Subroutine5
      46  UART2_ClearFlag
      36  UART2_ClearITPendingBit
      13  UART2_Cmd
      39  UART2_DeInit
     118  UART2_GetFlagStatus
     153  UART2_GetITStatus
     184  UART2_ITConfig
     399  UART2_Init
      23  UART2_IrDACmd
      23  UART2_IrDAConfig
      23  UART2_LINBreakDetectionConfig
      23  UART2_LINCmd
     106  UART2_LINConfig
       4  UART2_ReceiveData8
      25  UART2_ReceiveData9
      23  UART2_ReceiverWakeUpCmd
       5  UART2_SendBreak
       4  UART2_SendData8
      20  UART2_SendData9
      35  UART2_SetAddress
       4  UART2_SetGuardTime
       4  UART2_SetPrescaler
      23  UART2_SmartCardCmd
      23  UART2_SmartCardNACKCmd
      30  UART2_WakeUpConfig

 
    26 bytes in section .near.rodata
 1 433 bytes in section .near_func.text
 
 1 433 bytes of CODE  memory
    26 bytes of CONST memory

Errors: none
Warnings: none
