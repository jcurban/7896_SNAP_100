###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             27/Jun/2013  15:02:54 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\SNAP_101\StringUtilities.c                            #
#    Command line =  C:\SNAP_101\StringUtilities.c -e --enable_multibytes     #
#                    -On --no_cse --no_unroll --no_inline --no_code_motion    #
#                    --no_tbaa --no_cross_call --debug --code_model medium    #
#                    --data_model medium -o C:\SNAP_101\Debug\Obj\            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.5\stm8\LIB\dlstm8mmn.h" -D STM8S007 -lC      #
#                    C:\SNAP_101\Debug\List\ -I .\ --no_system_include        #
#                    --require_prototypes --vregs 16                          #
#    List file    =  C:\SNAP_101\Debug\List\StringUtilities.lst               #
#    Object file  =  C:\SNAP_101\Debug\Obj\StringUtilities.o                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\SNAP_101\StringUtilities.c
      1          #include "stm8s.h"
      2          extern const int BFRSIZE;
      3          extern u8 GS1011_String_Found;
      4          extern char Device_Xmit_Pointer;
      5          extern u8 Device_Xmit_Char_Count;
      6          extern u8 GS1011_Xmit_Char_Count;
      7          extern int GS1011_Xmit_Pointer;
      8          extern char GS1011_Xmit_Buffer[];
      9          extern char Device_Xmit_Buffer[];
     10          extern char GS1011_Receiver_Buffer[];
     11          extern char Device_Receiver_Buffer[];
     12          extern u16 GS1011_Rcvr_InPtr;
     13          extern u16 GS1011_Rcvr_OutPtr;
     14          extern u8 Device_RX_InPtr;
     15          extern u8 Device_RX_OutPtr;
     16          
     17          /*****************************************************************************/
     18          /*****            STRING UTILITY ROUTINES                                 ****/
     19          /*****************************************************************************/
     20          int CountChars(char s[]);
     21          void CountGS1011Chars(void);
     22          char CopyBuffer (char dest[], char srce[]);
     23          void CopyBufferDevice( char srce[]);
     24          void CopyBufferGS1011 (char srce[]);
     25          void CopyBufferCounted (char dest[], char srce[], char cntr);
     26          void FillBuffer (char bufr[],char filchr, char cntr);
     27          
     28          void InitializeDeviceBuffer (void);
     29          void InitializeGS1011Buffer (void);
     30          void Add_Char_to_Buffer (char bufr[], int ptr,char chr);
     31          void Add_Char_to_GS1011_Buffer (char chr);
     32          void Add_Integer_to_Buffer (char bufr[],int ptr, int vint);
     33          int Add_String_to_Buffer (char bufr[],int ptr, char *srce);
     34          void Add_String_to_GS1011_Buffer ( char *srce);
     35          
     36          void FindGS1011Chars(char chrstrng[]);
     37          /*****************************************************************************/
     38          /*****              GENERAL BUFFER HANDLING ROUTINES                      ****/
     39          /*****************************************************************************/
     40          
     41          /*****************************************************************************/
     42          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     43          /*****                  source buffer must terminate with a 0x00.         ****/
     44          /*****          Returns an integer for number of characters in the buffer ****/
     45          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     46          void InitializeDeviceBuffer (void){
     47          int ptr;
     48            for (ptr = 0; ptr < 255; ptr++) 
   \                     InitializeDeviceBuffer:
   \   000000 905F         CLRW      Y
   \   000002 93           LDW       X, Y
   \                     ??InitializeDeviceBuffer_0:
   \   000003 A3 00FF      CPW       X, #0xff
   \   000006 2E 07        JRSGE     L:??InitializeDeviceBuffer_1
     49             Device_Receiver_Buffer[ptr] = 0x00;
   \   000008 4F           CLR       A
   \   000009 D7 ....      LD        (L:Device_Receiver_Buffer,X), A
   \   00000C 5C           INCW      X
   \   00000D 20 F4        JRA       L:??InitializeDeviceBuffer_0
     50          Device_RX_InPtr = 0;
   \                     ??InitializeDeviceBuffer_1:
   \   00000F 35 00 ....   MOV       L:Device_RX_InPtr, #0x0
     51          Device_RX_OutPtr = 0;
   \   000013 35 00 ....   MOV       L:Device_RX_OutPtr, #0x0
     52          }
   \   000017 87           RETF
     53          /*****************************************************************************/
     54          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     55          /*****                  source buffer must terminate with a 0x00.         ****/
     56          /*****          Returns an integer for number of characters in the buffer ****/
     57          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     58          void InitializeGS1011Buffer (void){
     59          int ptr;
     60            for (ptr = 0; ptr < 512; ptr++) 
   \                     InitializeGS1011Buffer:
   \   000000 5F           CLRW      X
   \   000001 9093         LDW       Y, X
   \                     ??InitializeGS1011Buffer_0:
   \   000003 90A3 0200    CPW       Y, #0x200
   \   000007 2E 0B        JRSGE     L:??InitializeGS1011Buffer_1
     61             GS1011_Receiver_Buffer[ptr] = 0x00;
   \   000009 4F           CLR       A
   \   00000A 93           LDW       X, Y
   \   00000B D7 ....      LD        (L:GS1011_Receiver_Buffer,X), A
   \   00000E 93           LDW       X, Y
   \   00000F 5C           INCW      X
   \   000010 9093         LDW       Y, X
   \   000012 20 EF        JRA       L:??InitializeGS1011Buffer_0
     62          GS1011_Rcvr_InPtr = 0;
   \                     ??InitializeGS1011Buffer_1:
   \   000014 5F           CLRW      X
   \   000015 CF ....      LDW       L:GS1011_Rcvr_InPtr, X
     63          GS1011_Rcvr_OutPtr = 0;
   \   000018 5F           CLRW      X
   \   000019 CF ....      LDW       L:GS1011_Rcvr_OutPtr, X
     64          }
   \   00001C 87           RETF
     65          /*****************************************************************************/
     66          /***** Add_Char_to_Buffer (char s)                                 ****/
     67          /*****                 Buffer pointer always contain the next space       ****/
     68          /*****                    available for data storage                      ****/
     69          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     70          void Add_Char_to_Buffer (char *bufr, int ptr, char chr){
   \                     Add_Char_to_Buffer:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 93           LDW       X, Y
     71            bufr[ptr] = chr;
   \   000003 9093         LDW       Y, X
   \   000005 72B9 ....    ADDW      Y, S:?w0
   \   000009 90F7         LD        (Y), A
     72            ptr = ptr + 0x01;
   \   00000B 5C           INCW      X
     73          }
   \   00000C 87           RETF

   \                                 In section .far_func.text, align 1
     74          void Add_Char_to_GS1011_Buffer (char chr){
   \                     Add_Char_to_GS1011_Buffer:
   \   000000 B7 ..        LD        S:?b0, A
     75            GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = chr;
   \   000002 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
     76            GS1011_Xmit_Char_Count++;
   \   00000C C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00000F AB 01        ADD       A, #0x1
   \   000011 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
     77          }
   \   000014 87           RETF
     78          
     79          /*****************************************************************************/
     80          /***** Add_Integer_to_Buffer (int s)                               ****/
     81          /*****                 Device buffers always contain the next space       ****/
     82          /*****                    available for data storage                      ****/
     83          /*****                 as an int in first 2 bytes                         ****/
     84          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     85          void Add_Integer_to_Buffer (char *bufr, int ptr, int vint){
   \                     Add_Integer_to_Buffer:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
   \   000006 90BF ..      LDW       S:?w1, Y
   \   000009 8D ......    CALLF     L:?mov_w3_w0
     86            int high, low;
     87            high = vint / 256;            /* calculate high byte and save */
   \   00000D 90AE 0100    LDW       Y, #0x100
   \   000011 BE ..        LDW       X, S:?w3
   \   000013 8D ......    CALLF     L:?sdiv16_x_x_y
   \   000017 BF ..        LDW       S:?w2, X
     88            low = vint % 256;             /* calculate low byte and save */
   \   000019 90AE 0100    LDW       Y, #0x100
   \   00001D BE ..        LDW       X, S:?w3
   \   00001F 8D ......    CALLF     L:?smod16_y_x_y
   \   000023 90BF ..      LDW       S:?w0, Y
     89            bufr[ptr] = low;
   \   000026 BE ..        LDW       X, S:?w1
   \   000028 72BB ....    ADDW      X, S:?w4
   \   00002C B6 ..        LD        A, S:?b1
   \   00002E F7           LD        (X), A
     90            bufr[ptr+1] = high;
   \   00002F BE ..        LDW       X, S:?w1
   \   000031 72BB ....    ADDW      X, S:?w4
   \   000035 5C           INCW      X
   \   000036 B6 ..        LD        A, S:?b5
   \   000038 F7           LD        (X), A
     91            ptr = ptr + 2;
   \   000039 BE ..        LDW       X, S:?w1
   \   00003B 1C 0002      ADDW      X, #0x2
   \   00003E BF ..        LDW       S:?w1, X
     92          }
   \   000040 AC ......    JPF       L:?epilogue_w4
     93          
     94          /*****************************************************************************/
     95          /***** Add_String_to_Buffer (buffer pointer, source pointer)       ****/
     96          /*****                 buffer & source buffer must terminate with a 0x00. ****/
     97          /*****    overwrites the receiving buffers terminating 0x00               ****/
     98          /*****                  copies source terminating 0x00.                   ****/
     99          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    100          int Add_String_to_Buffer (char *bufr,int ptr, char *srce){
   \                     Add_String_to_Buffer:
   \   000000 BF ..        LDW       S:?w3, X
   \   000002 90BF ..      LDW       S:?w1, Y
   \   000005 8D ......    CALLF     L:?mov_w2_w0
    101           u16 i,j;
    102              i = ptr;
   \   000009 8D ......    CALLF     L:?mov_w0_w1
    103              for (j = 0; j<BFRSIZE; j++)      
   \   00000D 5F           CLRW      X
   \   00000E 9093         LDW       Y, X
   \                     ??Add_String_to_Buffer_0:
   \   000010 90C3 ....    CPW       Y, L:BFRSIZE
   \   000014 24 26        JRNC      L:??Add_String_to_Buffer_1
    104               {
    105                  if (srce[j] == 0x00){
   \   000016 93           LDW       X, Y
   \   000017 72BB ....    ADDW      X, S:?w2
   \   00001B 7D           TNZ       (X)
   \   00001C 26 06        JRNE      L:??Add_String_to_Buffer_2
    106                      ptr = i;
   \   00001E 8D ......    CALLF     L:?mov_w1_w0
    107                      break;
   \   000022 20 18        JRA       L:??Add_String_to_Buffer_1
    108                  }
    109                  else {
    110                        bufr[i] = srce[j];      /* store string into buffer until */
   \                     ??Add_String_to_Buffer_2:
   \   000024 93           LDW       X, Y
   \   000025 72BB ....    ADDW      X, S:?w2
   \   000029 F6           LD        A, (X)
   \   00002A BE ..        LDW       X, S:?w0
   \   00002C 72BB ....    ADDW      X, S:?w3
   \   000030 F7           LD        (X), A
    111                        i++;                    /*   the strings terminating 0x00 */          
   \   000031 BE ..        LDW       X, S:?w0
   \   000033 5C           INCW      X
   \   000034 BF ..        LDW       S:?w0, X
    112                       }
    113               }
   \   000036 93           LDW       X, Y
   \   000037 5C           INCW      X
   \   000038 9093         LDW       Y, X
   \   00003A 20 D4        JRA       L:??Add_String_to_Buffer_0
    114          return i;
   \                     ??Add_String_to_Buffer_1:
   \   00003C BE ..        LDW       X, S:?w0
   \   00003E 87           RETF
    115          }

   \                                 In section .far_func.text, align 1
    116          void Add_String_to_GS1011_Buffer ( char *srce){
   \                     Add_String_to_GS1011_Buffer:
   \   000000 BF ..        LDW       S:?w1, X
    117           u16 j;
    118               for (j = 0; j<BFRSIZE; j++)      
   \   000002 5F           CLRW      X
   \   000003 9093         LDW       Y, X
   \                     ??Add_String_to_GS1011_Buffer_0:
   \   000005 90C3 ....    CPW       Y, L:BFRSIZE
   \   000009 24 28        JRNC      L:??Add_String_to_GS1011_Buffer_1
    119               {
    120                  if (srce[j] == 0x00){
   \   00000B 93           LDW       X, Y
   \   00000C 72BB ....    ADDW      X, S:?w1
   \   000010 7D           TNZ       (X)
   \   000011 26 02        JRNE      L:??Add_String_to_GS1011_Buffer_2
    121                      break;
   \   000013 20 1E        JRA       L:??Add_String_to_GS1011_Buffer_1
    122                  }
    123                  else {
    124                        GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = srce[j];      /* store string into buffer until */
   \                     ??Add_String_to_GS1011_Buffer_2:
   \   000015 93           LDW       X, Y
   \   000016 72BB ....    ADDW      X, S:?w1
   \   00001A F6           LD        A, (X)
   \   00001B B7 ..        LD        S:?b0, A
   \   00001D C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000020 5F           CLRW      X
   \   000021 97           LD        XL, A
   \   000022 B6 ..        LD        A, S:?b0
   \   000024 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    125                        GS1011_Xmit_Char_Count++;                    /*   the strings terminating 0x00 */          
   \   000027 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00002A AB 01        ADD       A, #0x1
   \   00002C C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    126                       }
    127               }
   \   00002F 905C         INCW      Y
   \   000031 20 D2        JRA       L:??Add_String_to_GS1011_Buffer_0
    128          }
   \                     ??Add_String_to_GS1011_Buffer_1:
   \   000033 87           RETF
    129          /*****************************************************************************/
    130          /***** FillBuffer (buffer pointer)                                         ****/
    131          /*****                  source buffer must terminate with a 0x00.         ****/
    132          /*****          Returns an integer for number of characters in the buffer ****/
    133          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    134          void FillBuffer (char bufr[],char filchr, char cntr){
   \                     FillBuffer:
   \   000000 B7 ..        LD        S:?b4, A
    135           u8 i;
    136           for (i = 0; i < cntr; i++) {
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b1, A
   \                     ??FillBuffer_0:
   \   000005 B6 ..        LD        A, S:?b1
   \   000007 B1 ..        CP        A, S:?b0
   \   000009 24 18        JRNC      L:??FillBuffer_1
    137             bufr[i] = filchr;
   \   00000B 905F         CLRW      Y
   \   00000D 61           EXG       A, YL
   \   00000E B6 ..        LD        A, S:?b1
   \   000010 61           EXG       A, YL
   \   000011 BF ..        LDW       S:?w1, X
   \   000013 72B9 ....    ADDW      Y, S:?w1
   \   000017 B6 ..        LD        A, S:?b4
   \   000019 90F7         LD        (Y), A
    138           }
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D AB 01        ADD       A, #0x1
   \   00001F B7 ..        LD        S:?b1, A
   \   000021 20 E2        JRA       L:??FillBuffer_0
    139          }
   \                     ??FillBuffer_1:
   \   000023 87           RETF
    140          /*****************************************************************************/
    141          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    142          /*****                  source buffer must terminate with a 0x00.         ****/
    143          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    144          char CopyBuffer (char dest[], char srce[]){
   \                     CopyBuffer:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
    145           u8 i;
    146           for (i=0; i < BFRSIZE; i++){
   \   000005 4F           CLR       A
   \   000006 B7 ..        LD        S:?b0, A
   \                     ??CopyBuffer_0:
   \   000008 5F           CLRW      X
   \   000009 41           EXG       A, XL
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C 41           EXG       A, XL
   \   00000D C3 ....      CPW       X, L:BFRSIZE
   \   000010 2E 3C        JRSGE     L:??CopyBuffer_1
    147             if (srce[i] != 0)
   \   000012 5F           CLRW      X
   \   000013 41           EXG       A, XL
   \   000014 B6 ..        LD        A, S:?b0
   \   000016 41           EXG       A, XL
   \   000017 72BB ....    ADDW      X, S:?w1
   \   00001B 7D           TNZ       (X)
   \   00001C 27 1C        JREQ      L:??CopyBuffer_2
    148              dest[i] = srce[i];
   \   00001E 5F           CLRW      X
   \   00001F 41           EXG       A, XL
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 41           EXG       A, XL
   \   000023 72BB ....    ADDW      X, S:?w1
   \   000027 F6           LD        A, (X)
   \   000028 5F           CLRW      X
   \   000029 41           EXG       A, XL
   \   00002A B6 ..        LD        A, S:?b0
   \   00002C 41           EXG       A, XL
   \   00002D 72BB ....    ADDW      X, S:?w2
   \   000031 F7           LD        (X), A
   \   000032 B6 ..        LD        A, S:?b0
   \   000034 AB 01        ADD       A, #0x1
   \   000036 B7 ..        LD        S:?b0, A
   \   000038 20 CE        JRA       L:??CopyBuffer_0
    149             else{
    150              dest[i] = srce[i];
   \                     ??CopyBuffer_2:
   \   00003A 5F           CLRW      X
   \   00003B 41           EXG       A, XL
   \   00003C B6 ..        LD        A, S:?b0
   \   00003E 41           EXG       A, XL
   \   00003F 72BB ....    ADDW      X, S:?w1
   \   000043 F6           LD        A, (X)
   \   000044 5F           CLRW      X
   \   000045 41           EXG       A, XL
   \   000046 B6 ..        LD        A, S:?b0
   \   000048 41           EXG       A, XL
   \   000049 72BB ....    ADDW      X, S:?w2
   \   00004D F7           LD        (X), A
    151              break;}
    152            }
    153            return i;
   \                     ??CopyBuffer_1:
   \   00004E B6 ..        LD        A, S:?b0
   \   000050 87           RETF
    154           }
    155          /*****************************************************************************/
    156          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    157          /*****                  source buffer must terminate with a 0x00.         ****/
    158          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    159          void CopyBufferDevice(char srce[]){
   \                     CopyBufferDevice:
   \   000000 BF ..        LDW       S:?w1, X
    160           u8 i;
    161           for (i=0; i < BFRSIZE; i++){
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferDevice_0:
   \   000005 5F           CLRW      X
   \   000006 41           EXG       A, XL
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 41           EXG       A, XL
   \   00000A C3 ....      CPW       X, L:BFRSIZE
   \   00000D 2E 45        JRSGE     L:??CopyBufferDevice_1
    162             if (srce[i] != 0x03)
   \   00000F 5F           CLRW      X
   \   000010 41           EXG       A, XL
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 41           EXG       A, XL
   \   000014 72BB ....    ADDW      X, S:?w1
   \   000018 F6           LD        A, (X)
   \   000019 A1 03        CP        A, #0x3
   \   00001B 27 1A        JREQ      L:??CopyBufferDevice_2
    163              Device_Xmit_Buffer[i] = srce[i];
   \   00001D 5F           CLRW      X
   \   00001E 41           EXG       A, XL
   \   00001F B6 ..        LD        A, S:?b0
   \   000021 41           EXG       A, XL
   \   000022 72BB ....    ADDW      X, S:?w1
   \   000026 F6           LD        A, (X)
   \   000027 5F           CLRW      X
   \   000028 41           EXG       A, XL
   \   000029 B6 ..        LD        A, S:?b0
   \   00002B 41           EXG       A, XL
   \   00002C D7 ....      LD        (L:Device_Xmit_Buffer,X), A
   \   00002F B6 ..        LD        A, S:?b0
   \   000031 AB 01        ADD       A, #0x1
   \   000033 B7 ..        LD        S:?b0, A
   \   000035 20 CE        JRA       L:??CopyBufferDevice_0
    164             else{
    165              Device_Xmit_Buffer[i] = srce[i];
   \                     ??CopyBufferDevice_2:
   \   000037 5F           CLRW      X
   \   000038 41           EXG       A, XL
   \   000039 B6 ..        LD        A, S:?b0
   \   00003B 41           EXG       A, XL
   \   00003C 72BB ....    ADDW      X, S:?w1
   \   000040 F6           LD        A, (X)
   \   000041 5F           CLRW      X
   \   000042 41           EXG       A, XL
   \   000043 B6 ..        LD        A, S:?b0
   \   000045 41           EXG       A, XL
   \   000046 D7 ....      LD        (L:Device_Xmit_Buffer,X), A
    166              i++;
   \   000049 B6 ..        LD        A, S:?b0
   \   00004B AB 01        ADD       A, #0x1
   \   00004D B7 ..        LD        S:?b0, A
    167              Device_Xmit_Char_Count =i;
   \   00004F B6 ..        LD        A, S:?b0
   \   000051 C7 ....      LD        L:Device_Xmit_Char_Count, A
    168              break;}
    169            }
    170          
    171           }
   \                     ??CopyBufferDevice_1:
   \   000054 87           RETF
    172          /*****************************************************************************/
    173          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    174          /*****                  source buffer must terminate with a 0x00.         ****/
    175          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    176          void CopyBufferGS1011 (char srce[]){
   \                     CopyBufferGS1011:
   \   000000 BF ..        LDW       S:?w1, X
    177           u8 i;
    178           for (i=0; i < BFRSIZE; i++){
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferGS1011_0:
   \   000005 5F           CLRW      X
   \   000006 41           EXG       A, XL
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 41           EXG       A, XL
   \   00000A C3 ....      CPW       X, L:BFRSIZE
   \   00000D 2E 3D        JRSGE     L:??CopyBufferGS1011_1
    179             if (srce[i] != 0)
   \   00000F 5F           CLRW      X
   \   000010 41           EXG       A, XL
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 41           EXG       A, XL
   \   000014 72BB ....    ADDW      X, S:?w1
   \   000018 7D           TNZ       (X)
   \   000019 27 1A        JREQ      L:??CopyBufferGS1011_2
    180              GS1011_Xmit_Buffer[i] = srce[i];
   \   00001B 5F           CLRW      X
   \   00001C 41           EXG       A, XL
   \   00001D B6 ..        LD        A, S:?b0
   \   00001F 41           EXG       A, XL
   \   000020 72BB ....    ADDW      X, S:?w1
   \   000024 F6           LD        A, (X)
   \   000025 5F           CLRW      X
   \   000026 41           EXG       A, XL
   \   000027 B6 ..        LD        A, S:?b0
   \   000029 41           EXG       A, XL
   \   00002A D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
   \   00002D B6 ..        LD        A, S:?b0
   \   00002F AB 01        ADD       A, #0x1
   \   000031 B7 ..        LD        S:?b0, A
   \   000033 20 D0        JRA       L:??CopyBufferGS1011_0
    181             else{
    182              GS1011_Xmit_Buffer[i] = srce[i];
   \                     ??CopyBufferGS1011_2:
   \   000035 5F           CLRW      X
   \   000036 41           EXG       A, XL
   \   000037 B6 ..        LD        A, S:?b0
   \   000039 41           EXG       A, XL
   \   00003A 72BB ....    ADDW      X, S:?w1
   \   00003E F6           LD        A, (X)
   \   00003F 5F           CLRW      X
   \   000040 41           EXG       A, XL
   \   000041 B6 ..        LD        A, S:?b0
   \   000043 41           EXG       A, XL
   \   000044 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    183              GS1011_Xmit_Char_Count =i;
   \   000047 B6 ..        LD        A, S:?b0
   \   000049 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    184              break;}
    185            }
    186           }
   \                     ??CopyBufferGS1011_1:
   \   00004C 87           RETF
    187          /*****************************************************************************/
    188          /***** copy buffer count(pointer to destination, pointer to source buffer,****/
    189          /*****                                  number of bytes to copy)          ****/
    190          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    191          void CopyBufferCounted (char dest[], char srce[], char cntr){
   \                     CopyBufferCounted:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
   \   000005 B7 ..        LD        S:?b1, A
    192          u8 i;
    193           
    194          for (i=0; i < cntr; i++){
   \   000007 4F           CLR       A
   \   000008 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferCounted_0:
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C B1 ..        CP        A, S:?b1
   \   00000E 24 1C        JRNC      L:??CopyBufferCounted_1
    195              dest[i] = srce[i];
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 41           EXG       A, XL
   \   000015 72BB ....    ADDW      X, S:?w1
   \   000019 F6           LD        A, (X)
   \   00001A 5F           CLRW      X
   \   00001B 41           EXG       A, XL
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E 41           EXG       A, XL
   \   00001F 72BB ....    ADDW      X, S:?w2
   \   000023 F7           LD        (X), A
    196            }
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 AB 01        ADD       A, #0x1
   \   000028 B7 ..        LD        S:?b0, A
   \   00002A 20 DE        JRA       L:??CopyBufferCounted_0
    197           }
   \                     ??CopyBufferCounted_1:
   \   00002C 87           RETF
    198          /*****************************************************************************/
    199          /***** CountChars (buffer pointer)                                         ****/
    200          /*****                  source buffer must terminate with a 0x00.         ****/
    201          /*****          Returns an integer for number of characters in the buffer ****/
    202          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    203          int CountChars(char *s){
   \                     CountChars:
   \   000000 BF ..        LDW       S:?w0, X
    204          int cntr;
    205            for (cntr=0; cntr < BFRSIZE; cntr++){
   \   000002 905F         CLRW      Y
   \   000004 93           LDW       X, Y
   \                     ??CountChars_0:
   \   000005 C3 ....      CPW       X, L:BFRSIZE
   \   000008 2E 0F        JRSGE     L:??CountChars_1
    206              if  (s[cntr] == 0x00)
   \   00000A 9093         LDW       Y, X
   \   00000C 72B9 ....    ADDW      Y, S:?w0
   \   000010 907D         TNZ       (Y)
   \   000012 26 02        JRNE      L:??CountChars_2
    207                break;
   \   000014 20 03        JRA       L:??CountChars_1
    208            }
   \                     ??CountChars_2:
   \   000016 5C           INCW      X
   \   000017 20 EC        JRA       L:??CountChars_0
    209            
    210            return cntr;
   \                     ??CountChars_1:
   \   000019 87           RETF
    211          }
    212          /*****************************************************************************/
    213          /***** CountChars (buffer pointer)                                         ****/
    214          /*****                  source buffer must terminate with a 0x00.         ****/
    215          /*****          Returns an integer for number of characters in the buffer ****/
    216          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    217          void CountGS1011Chars(void){
    218          char chr;
    219            for (GS1011_Xmit_Char_Count=0; GS1011_Xmit_Char_Count < BFRSIZE; GS1011_Xmit_Char_Count++){
   \                     CountGS1011Chars:
   \   000000 35 00 ....   MOV       L:GS1011_Xmit_Char_Count, #0x0
   \                     ??CountGS1011Chars_0:
   \   000004 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000007 5F           CLRW      X
   \   000008 97           LD        XL, A
   \   000009 C3 ....      CPW       X, L:BFRSIZE
   \   00000C 2E 27        JRSGE     L:??CountGS1011Chars_1
    220              chr = GS1011_Xmit_Buffer[GS1011_Xmit_Pointer];
   \   00000E CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   000011 D6 ....      LD        A, (L:GS1011_Xmit_Buffer,X)
   \   000014 B7 ..        LD        S:?b0, A
    221              if  (chr == 0x00){
   \   000016 3D ..        TNZ       S:?b0
   \   000018 26 0A        JRNE      L:??CountGS1011Chars_2
    222                GS1011_Xmit_Char_Count++;
   \   00001A C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00001D AB 01        ADD       A, #0x1
   \   00001F C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    223                break;}
   \   000022 20 11        JRA       L:??CountGS1011Chars_1
    224              GS1011_Xmit_Pointer++;
   \                     ??CountGS1011Chars_2:
   \   000024 CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   000027 5C           INCW      X
   \   000028 CF ....      LDW       L:GS1011_Xmit_Pointer, X
    225            }
   \   00002B C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00002E AB 01        ADD       A, #0x1
   \   000030 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
   \   000033 20 CF        JRA       L:??CountGS1011Chars_0
    226          }
   \                     ??CountGS1011Chars_1:
   \   000035 87           RETF
    227          
    228          /*****************************************************************************/
    229          /***** Find string ( buffer pointer, sting)                                         ****/
    230          /*****                  source buffer must terminate with a 0x00.         ****/
    231          /*****          Returns an integer for number of characters in the buffer ****/
    232          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    233          void FindGS1011Chars(char chrstrng[]){
   \                     FindGS1011Chars:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 BF ..        LDW       S:?w1, X
    234          int bufptr, strptr,strcnt,i;
    235          char chr,chr1;
    236          
    237          for (i = 0; i< 6; i++){
   \   000006 5F           CLRW      X
   \   000007 9093         LDW       Y, X
   \                     ??FindGS1011Chars_0:
   \   000009 90A3 0006    CPW       Y, #0x6
   \   00000D 2E 13        JRSGE     L:??FindGS1011Chars_1
    238            if (chrstrng[i] == 0x00){
   \   00000F 93           LDW       X, Y
   \   000010 72BB ....    ADDW      X, S:?w1
   \   000014 7D           TNZ       (X)
   \   000015 26 05        JRNE      L:??FindGS1011Chars_2
    239              strcnt = i;
   \   000017 90BF ..      LDW       S:?w3, Y
    240              break;}
   \   00001A 20 06        JRA       L:??FindGS1011Chars_1
    241          }
   \                     ??FindGS1011Chars_2:
   \   00001C 93           LDW       X, Y
   \   00001D 5C           INCW      X
   \   00001E 9093         LDW       Y, X
   \   000020 20 E7        JRA       L:??FindGS1011Chars_0
    242            for (bufptr=0; bufptr < BFRSIZE*2; bufptr++){
   \                     ??FindGS1011Chars_1:
   \   000022 5F           CLRW      X
   \   000023 BF ..        LDW       S:?w0, X
   \                     ??FindGS1011Chars_3:
   \   000025 CE ....      LDW       X, L:BFRSIZE
   \   000028 58           SLLW      X
   \   000029 BF ..        LDW       S:?w5, X
   \   00002B BE ..        LDW       X, S:?w0
   \   00002D B3 ..        CPW       X, S:?w5
   \   00002F 2E 77        JRSGE     L:??FindGS1011Chars_4
    243              chr = GS1011_Receiver_Buffer[GS1011_Xmit_Pointer];
   \   000031 CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   000034 D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   000037 B7 ..        LD        S:?b9, A
    244              chr1 = chrstrng[strptr];
   \   000039 BE ..        LDW       X, S:?w2
   \   00003B 72BB ....    ADDW      X, S:?w1
   \   00003F F6           LD        A, (X)
   \   000040 B7 ..        LD        S:?b8, A
    245              if (chr == chr1){                   /*match first byte of string? */
   \   000042 B6 ..        LD        A, S:?b8
   \   000044 B1 ..        CP        A, S:?b9
   \   000046 26 3F        JRNE      L:??FindGS1011Chars_5
    246                for (i=0; i < strcnt; i++){
   \   000048 5F           CLRW      X
   \   000049 9093         LDW       Y, X
   \                     ??FindGS1011Chars_6:
   \   00004B 90B3 ..      CPW       Y, S:?w3
   \   00004E 2E 37        JRSGE     L:??FindGS1011Chars_5
    247                  chr = GS1011_Receiver_Buffer[GS1011_Xmit_Pointer + i];
   \   000050 93           LDW       X, Y
   \   000051 72BB ....    ADDW      X, L:GS1011_Xmit_Pointer
   \   000055 D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   000058 B7 ..        LD        S:?b9, A
    248                  chr1 = chrstrng[strptr + i];    /*keep checking till end*/
   \   00005A 93           LDW       X, Y
   \   00005B 72BB ....    ADDW      X, S:?w2
   \   00005F 72BB ....    ADDW      X, S:?w1
   \   000063 F6           LD        A, (X)
   \   000064 B7 ..        LD        S:?b8, A
    249                  if (chr != chr1){
   \   000066 B6 ..        LD        A, S:?b8
   \   000068 B1 ..        CP        A, S:?b9
   \   00006A 27 09        JREQ      L:??FindGS1011Chars_7
    250                    strptr=0x00;                 /*no reset the string pointer*/
   \   00006C 5F           CLRW      X
   \   00006D BF ..        LDW       S:?w2, X
    251                    GS1011_String_Found = 1;
   \   00006F 35 01 ....   MOV       L:GS1011_String_Found, #0x1
    252                    break;
   \   000073 20 12        JRA       L:??FindGS1011Chars_5
    253                   } 
    254                  else{
    255                    strcnt++;
   \                     ??FindGS1011Chars_7:
   \   000075 BE ..        LDW       X, S:?w3
   \   000077 5C           INCW      X
   \   000078 BF ..        LDW       S:?w3, X
    256                    GS1011_Xmit_Pointer++;               /*yes continue on*/
   \   00007A CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   00007D 5C           INCW      X
   \   00007E CF ....      LDW       L:GS1011_Xmit_Pointer, X
    257                  }
    258                }
   \   000081 93           LDW       X, Y
   \   000082 5C           INCW      X
   \   000083 9093         LDW       Y, X
   \   000085 20 C4        JRA       L:??FindGS1011Chars_6
    259              }
    260                if  (chr == 0x00){
   \                     ??FindGS1011Chars_5:
   \   000087 3D ..        TNZ       S:?b9
   \   000089 26 0E        JRNE      L:??FindGS1011Chars_8
    261                GS1011_Xmit_Char_Count++;
   \   00008B C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00008E AB 01        ADD       A, #0x1
   \   000090 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    262               GS1011_String_Found = 0;
   \   000093 35 00 ....   MOV       L:GS1011_String_Found, #0x0
    263                break;}
   \   000097 20 0F        JRA       L:??FindGS1011Chars_4
    264              GS1011_Xmit_Pointer++;
   \                     ??FindGS1011Chars_8:
   \   000099 CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   00009C 5C           INCW      X
   \   00009D CF ....      LDW       L:GS1011_Xmit_Pointer, X
    265            }
   \   0000A0 BE ..        LDW       X, S:?w0
   \   0000A2 5C           INCW      X
   \   0000A3 BF ..        LDW       S:?w0, X
   \   0000A5 CC ....      JP        L:??FindGS1011Chars_3
    266          }
   \                     ??FindGS1011Chars_4:
   \   0000A8 AC ......    JPF       L:?epilogue_l2
    267          /*****************************************************************************/
    268          /***** CountChars (buffer pointer)                                         ****/
    269          /*****                  source buffer must terminate with a 0x00.         ****/
    270          /*****          Returns an integer for number of characters in the buffer ****/
    271          /*****************************************************************************/
    272          /*void CountDeviceChars(void){
    273          char chr;
    274            for (Device_Xmit_Char_Count=0; Device_Xmit_Char_Count < BFRSIZE; Device_Xmit_Char_Count++){
    275              chr = Device_Xmit_Pointer;
    276              if  (chr == 0x03){
    277                Device_Xmit_Char_Count++;
    278                break;
    279                }
    280                Device_Xmit_Pointer++;
    281            }
    282          }*/
    283          /*****************************************************************************/
    284          /*****              DEVICE BUFFER  HANDLING ROUTINES                      ****/
    285          /*****  While the GS1011 buffers are purely ASCII, the Device_Buffer can  ****/
    286          /*****    ANY type of data, not only in the packet data, but as counts,   ****/
    287          /*****    etc. in the header of the message.                              ****/
    288          /*****                                                                    ****/
    289          /*****    where bufr is buffer containing parameters                      ****/
    290          /*****          ptr is pointer at begining of parameter                   ****/
    291          /*****          cntr is the parameter counter                             ****/
    292          /*****************************************************************************/
    293          
    294          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      13  Add_Char_to_Buffer
      21  Add_Char_to_GS1011_Buffer
      68  Add_Integer_to_Buffer
      63  Add_String_to_Buffer
      52  Add_String_to_GS1011_Buffer
      81  CopyBuffer
      45  CopyBufferCounted
      85  CopyBufferDevice
      77  CopyBufferGS1011
      26  CountChars
      54  CountGS1011Chars
      36  FillBuffer
     172  FindGS1011Chars
      24  InitializeDeviceBuffer
      29  InitializeGS1011Buffer

 
 846 bytes in section .far_func.text
 
 846 bytes of CODE memory

Errors: none
Warnings: none
