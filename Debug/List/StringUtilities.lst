###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             02/Jul/2013  06:23:01 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUti #
#                    lities.c                                                 #
#    Command line =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUti #
#                    lities.c -e --enable_multibytes -On --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o C:\Users\jurban\Documents\GitHub\ #
#                    7896_SNAP_100\Debug\Obj\ --dlib_config "C:\Program       #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8S007 -lC                #
#                    C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\ -I .\ --no_system_include --require_prototypes        #
#                    --vregs 16                                               #
#    List file    =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\StringUtilities.lst                                    #
#    Object file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Obj #
#                    \StringUtilities.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUtilities.c
      1          #include "stm8s.h"
      2          extern const int BFRSIZE;
      3          extern int Found_String_At_Byte;
      4          extern u8 GS1011_String_Found;
      5          extern char Device_Xmit_Pointer;
      6          extern u8 Device_Xmit_Char_Count;
      7          extern u8 GS1011_Xmit_Char_Count;
      8          extern int GS1011_Xmit_Pointer;
      9          extern int GS1011_Rvcr_Count;
     10          extern char GS1011_Xmit_Buffer[];
     11          extern char Device_Xmit_Buffer[];
     12          extern char GS1011_Receiver_Buffer[];
     13          extern char Device_Receiver_Buffer[];
     14          extern u16 GS1011_Rcvr_InPtr;
     15          extern u16 GS1011_Rcvr_OutPtr;
     16          extern u8 Device_RX_InPtr;
     17          extern u8 Device_RX_OutPtr;
     18          
     19          /*****************************************************************************/
     20          /*****            STRING UTILITY ROUTINES                                 ****/
     21          /*****************************************************************************/
     22          int CountChars(char s[]);
     23          
     24          void CountGS1011Chars(void);
     25          char CopyBuffer (char dest[], char srce[]);
     26          void CopyBufferDevice( char srce[]);
     27          void CopyBufferGS1011 (char srce[]);
     28          void CopyBufferCounted (char dest[], char srce[], char cntr);
     29          void FillBuffer (char bufr[],char filchr, char cntr);
     30          
     31          void InitializeDeviceBuffer (void);
     32          void InitializeGS1011Buffer (void);
     33          void Add_Char_to_Buffer (char bufr[], int ptr,char chr);
     34          void Add_Char_to_GS1011_Buffer (char chr);
     35          void Add_Integer_to_Buffer (char bufr[],int ptr, int vint);
     36          int Add_String_to_Buffer (char bufr[],int ptr, char *srce);
     37          void Add_String_to_GS1011_Buffer ( char *srce);
     38          
     39          void FindGS1011Chars(char chrstrng[]);
     40          void copy_buffer_from_offset_to_terminator(char srcebufr[],char destbufr[], int ofst, char trm);
     41          /*****************************************************************************/
     42          /*****              GENERAL BUFFER HANDLING ROUTINES                      ****/
     43          /*****************************************************************************/
     44          
     45          /*****************************************************************************/
     46          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     47          /*****                  source buffer must terminate with a 0x00.         ****/
     48          /*****          Returns an integer for number of characters in the buffer ****/
     49          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     50          void InitializeDeviceBuffer (void){
     51          int ptr;
     52            for (ptr = 0; ptr < 255; ptr++) 
   \                     InitializeDeviceBuffer:
   \   000000 905F         CLRW      Y
   \   000002 93           LDW       X, Y
   \                     ??InitializeDeviceBuffer_0:
   \   000003 A3 00FF      CPW       X, #0xff
   \   000006 2E 07        JRSGE     L:??InitializeDeviceBuffer_1
     53             Device_Receiver_Buffer[ptr] = 0x00;
   \   000008 4F           CLR       A
   \   000009 D7 ....      LD        (L:Device_Receiver_Buffer,X), A
   \   00000C 5C           INCW      X
   \   00000D 20 F4        JRA       L:??InitializeDeviceBuffer_0
     54          Device_RX_InPtr = 0;
   \                     ??InitializeDeviceBuffer_1:
   \   00000F 35 00 ....   MOV       L:Device_RX_InPtr, #0x0
     55          Device_RX_OutPtr = 0;
   \   000013 35 00 ....   MOV       L:Device_RX_OutPtr, #0x0
     56          }
   \   000017 87           RETF
     57          /*****************************************************************************/
     58          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     59          /*****                  source buffer must terminate with a 0x00.         ****/
     60          /*****          Returns an integer for number of characters in the buffer ****/
     61          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     62          void InitializeGS1011Buffer (void){
     63          int ptr;
     64            for (ptr = 0; ptr < 512; ptr++) 
   \                     InitializeGS1011Buffer:
   \   000000 5F           CLRW      X
   \   000001 9093         LDW       Y, X
   \                     ??InitializeGS1011Buffer_0:
   \   000003 90A3 0200    CPW       Y, #0x200
   \   000007 2E 0B        JRSGE     L:??InitializeGS1011Buffer_1
     65             GS1011_Receiver_Buffer[ptr] = 0x00;
   \   000009 4F           CLR       A
   \   00000A 93           LDW       X, Y
   \   00000B D7 ....      LD        (L:GS1011_Receiver_Buffer,X), A
   \   00000E 93           LDW       X, Y
   \   00000F 5C           INCW      X
   \   000010 9093         LDW       Y, X
   \   000012 20 EF        JRA       L:??InitializeGS1011Buffer_0
     66          GS1011_Rcvr_InPtr = 0;
   \                     ??InitializeGS1011Buffer_1:
   \   000014 5F           CLRW      X
   \   000015 CF ....      LDW       L:GS1011_Rcvr_InPtr, X
     67          GS1011_Rcvr_OutPtr = 0;
   \   000018 5F           CLRW      X
   \   000019 CF ....      LDW       L:GS1011_Rcvr_OutPtr, X
     68          }
   \   00001C 87           RETF
     69          /*****************************************************************************/
     70          /***** Add_Char_to_Buffer (char s)                                 ****/
     71          /*****                 Buffer pointer always contain the next space       ****/
     72          /*****                    available for data storage                      ****/
     73          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     74          void Add_Char_to_Buffer (char *bufr, int ptr, char chr){
   \                     Add_Char_to_Buffer:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 93           LDW       X, Y
     75            bufr[ptr] = chr;
   \   000003 9093         LDW       Y, X
   \   000005 72B9 ....    ADDW      Y, S:?w0
   \   000009 90F7         LD        (Y), A
     76            ptr = ptr + 0x01;
   \   00000B 5C           INCW      X
     77          }
   \   00000C 87           RETF

   \                                 In section .far_func.text, align 1
     78          void Add_Char_to_GS1011_Buffer (char chr){
   \                     Add_Char_to_GS1011_Buffer:
   \   000000 B7 ..        LD        S:?b0, A
     79            GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = chr;
   \   000002 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
     80            GS1011_Xmit_Char_Count++;
   \   00000C C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00000F AB 01        ADD       A, #0x1
   \   000011 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
     81          }
   \   000014 87           RETF
     82          
     83          /*****************************************************************************/
     84          /***** Add_Integer_to_Buffer (int s)                               ****/
     85          /*****                 Device buffers always contain the next space       ****/
     86          /*****                    available for data storage                      ****/
     87          /*****                 as an int in first 2 bytes                         ****/
     88          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     89          void Add_Integer_to_Buffer (char *bufr, int ptr, int vint){
   \                     Add_Integer_to_Buffer:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w4, X
   \   000006 90BF ..      LDW       S:?w1, Y
   \   000009 8D ......    CALLF     L:?mov_w3_w0
     90            int high, low;
     91            high = vint / 256;            /* calculate high byte and save */
   \   00000D 90AE 0100    LDW       Y, #0x100
   \   000011 BE ..        LDW       X, S:?w3
   \   000013 8D ......    CALLF     L:?sdiv16_x_x_y
   \   000017 BF ..        LDW       S:?w2, X
     92            low = vint % 256;             /* calculate low byte and save */
   \   000019 90AE 0100    LDW       Y, #0x100
   \   00001D BE ..        LDW       X, S:?w3
   \   00001F 8D ......    CALLF     L:?smod16_y_x_y
   \   000023 90BF ..      LDW       S:?w0, Y
     93            bufr[ptr] = low;
   \   000026 BE ..        LDW       X, S:?w1
   \   000028 72BB ....    ADDW      X, S:?w4
   \   00002C B6 ..        LD        A, S:?b1
   \   00002E F7           LD        (X), A
     94            bufr[ptr+1] = high;
   \   00002F BE ..        LDW       X, S:?w1
   \   000031 72BB ....    ADDW      X, S:?w4
   \   000035 5C           INCW      X
   \   000036 B6 ..        LD        A, S:?b5
   \   000038 F7           LD        (X), A
     95            ptr = ptr + 2;
   \   000039 BE ..        LDW       X, S:?w1
   \   00003B 1C 0002      ADDW      X, #0x2
   \   00003E BF ..        LDW       S:?w1, X
     96          }
   \   000040 AC ......    JPF       L:?epilogue_w4
     97          
     98          /*****************************************************************************/
     99          /***** Add_String_to_Buffer (buffer pointer, source pointer)       ****/
    100          /*****                 buffer & source buffer must terminate with a 0x00. ****/
    101          /*****    overwrites the receiving buffers terminating 0x00               ****/
    102          /*****                  copies source terminating 0x00.                   ****/
    103          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    104          int Add_String_to_Buffer (char *bufr,int ptr, char *srce){
   \                     Add_String_to_Buffer:
   \   000000 BF ..        LDW       S:?w3, X
   \   000002 90BF ..      LDW       S:?w1, Y
   \   000005 8D ......    CALLF     L:?mov_w2_w0
    105           u16 i,j;
    106              i = ptr;
   \   000009 8D ......    CALLF     L:?mov_w0_w1
    107              for (j = 0; j<BFRSIZE; j++)      
   \   00000D 5F           CLRW      X
   \   00000E 9093         LDW       Y, X
   \                     ??Add_String_to_Buffer_0:
   \   000010 90C3 ....    CPW       Y, L:BFRSIZE
   \   000014 24 26        JRNC      L:??Add_String_to_Buffer_1
    108               {
    109                  if (srce[j] == 0x00){
   \   000016 93           LDW       X, Y
   \   000017 72BB ....    ADDW      X, S:?w2
   \   00001B 7D           TNZ       (X)
   \   00001C 26 06        JRNE      L:??Add_String_to_Buffer_2
    110                      ptr = i;
   \   00001E 8D ......    CALLF     L:?mov_w1_w0
    111                      break;
   \   000022 20 18        JRA       L:??Add_String_to_Buffer_1
    112                  }
    113                  else {
    114                        bufr[i] = srce[j];      /* store string into buffer until */
   \                     ??Add_String_to_Buffer_2:
   \   000024 93           LDW       X, Y
   \   000025 72BB ....    ADDW      X, S:?w2
   \   000029 F6           LD        A, (X)
   \   00002A BE ..        LDW       X, S:?w0
   \   00002C 72BB ....    ADDW      X, S:?w3
   \   000030 F7           LD        (X), A
    115                        i++;                    /*   the strings terminating 0x00 */          
   \   000031 BE ..        LDW       X, S:?w0
   \   000033 5C           INCW      X
   \   000034 BF ..        LDW       S:?w0, X
    116                       }
    117               }
   \   000036 93           LDW       X, Y
   \   000037 5C           INCW      X
   \   000038 9093         LDW       Y, X
   \   00003A 20 D4        JRA       L:??Add_String_to_Buffer_0
    118          return i;
   \                     ??Add_String_to_Buffer_1:
   \   00003C BE ..        LDW       X, S:?w0
   \   00003E 87           RETF
    119          }

   \                                 In section .far_func.text, align 1
    120          void Add_String_to_GS1011_Buffer ( char *srce){
   \                     Add_String_to_GS1011_Buffer:
   \   000000 BF ..        LDW       S:?w1, X
    121           u16 j;
    122               for (j = 0; j<BFRSIZE; j++)      
   \   000002 5F           CLRW      X
   \   000003 9093         LDW       Y, X
   \                     ??Add_String_to_GS1011_Buffer_0:
   \   000005 90C3 ....    CPW       Y, L:BFRSIZE
   \   000009 24 28        JRNC      L:??Add_String_to_GS1011_Buffer_1
    123               {
    124                  if (srce[j] == 0x00){
   \   00000B 93           LDW       X, Y
   \   00000C 72BB ....    ADDW      X, S:?w1
   \   000010 7D           TNZ       (X)
   \   000011 26 02        JRNE      L:??Add_String_to_GS1011_Buffer_2
    125                      break;
   \   000013 20 1E        JRA       L:??Add_String_to_GS1011_Buffer_1
    126                  }
    127                  else {
    128                        GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = srce[j];      /* store string into buffer until */
   \                     ??Add_String_to_GS1011_Buffer_2:
   \   000015 93           LDW       X, Y
   \   000016 72BB ....    ADDW      X, S:?w1
   \   00001A F6           LD        A, (X)
   \   00001B B7 ..        LD        S:?b0, A
   \   00001D C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000020 5F           CLRW      X
   \   000021 97           LD        XL, A
   \   000022 B6 ..        LD        A, S:?b0
   \   000024 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    129                        GS1011_Xmit_Char_Count++;                    /*   the strings terminating 0x00 */          
   \   000027 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00002A AB 01        ADD       A, #0x1
   \   00002C C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    130                       }
    131               }
   \   00002F 905C         INCW      Y
   \   000031 20 D2        JRA       L:??Add_String_to_GS1011_Buffer_0
    132          }
   \                     ??Add_String_to_GS1011_Buffer_1:
   \   000033 87           RETF
    133          /*****************************************************************************/
    134          /***** FillBuffer (buffer pointer)                                         ****/
    135          /*****                  source buffer must terminate with a 0x00.         ****/
    136          /*****          Returns an integer for number of characters in the buffer ****/
    137          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    138          void FillBuffer (char bufr[],char filchr, char cntr){
   \                     FillBuffer:
   \   000000 B7 ..        LD        S:?b4, A
    139           u8 i;
    140           for (i = 0; i < cntr; i++) {
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b1, A
   \                     ??FillBuffer_0:
   \   000005 B6 ..        LD        A, S:?b1
   \   000007 B1 ..        CP        A, S:?b0
   \   000009 24 18        JRNC      L:??FillBuffer_1
    141             bufr[i] = filchr;
   \   00000B 905F         CLRW      Y
   \   00000D 61           EXG       A, YL
   \   00000E B6 ..        LD        A, S:?b1
   \   000010 61           EXG       A, YL
   \   000011 BF ..        LDW       S:?w1, X
   \   000013 72B9 ....    ADDW      Y, S:?w1
   \   000017 B6 ..        LD        A, S:?b4
   \   000019 90F7         LD        (Y), A
    142           }
   \   00001B B6 ..        LD        A, S:?b1
   \   00001D AB 01        ADD       A, #0x1
   \   00001F B7 ..        LD        S:?b1, A
   \   000021 20 E2        JRA       L:??FillBuffer_0
    143          }
   \                     ??FillBuffer_1:
   \   000023 87           RETF
    144          /*****************************************************************************/
    145          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    146          /*****                  source buffer must terminate with a 0x00.         ****/
    147          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    148          char CopyBuffer (char dest[], char srce[]){
   \                     CopyBuffer:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
    149           u8 i;
    150           for (i=0; i < BFRSIZE; i++){
   \   000005 4F           CLR       A
   \   000006 B7 ..        LD        S:?b0, A
   \                     ??CopyBuffer_0:
   \   000008 5F           CLRW      X
   \   000009 41           EXG       A, XL
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C 41           EXG       A, XL
   \   00000D C3 ....      CPW       X, L:BFRSIZE
   \   000010 2E 3C        JRSGE     L:??CopyBuffer_1
    151             if (srce[i] != 0)
   \   000012 5F           CLRW      X
   \   000013 41           EXG       A, XL
   \   000014 B6 ..        LD        A, S:?b0
   \   000016 41           EXG       A, XL
   \   000017 72BB ....    ADDW      X, S:?w1
   \   00001B 7D           TNZ       (X)
   \   00001C 27 1C        JREQ      L:??CopyBuffer_2
    152              dest[i] = srce[i];
   \   00001E 5F           CLRW      X
   \   00001F 41           EXG       A, XL
   \   000020 B6 ..        LD        A, S:?b0
   \   000022 41           EXG       A, XL
   \   000023 72BB ....    ADDW      X, S:?w1
   \   000027 F6           LD        A, (X)
   \   000028 5F           CLRW      X
   \   000029 41           EXG       A, XL
   \   00002A B6 ..        LD        A, S:?b0
   \   00002C 41           EXG       A, XL
   \   00002D 72BB ....    ADDW      X, S:?w2
   \   000031 F7           LD        (X), A
   \   000032 B6 ..        LD        A, S:?b0
   \   000034 AB 01        ADD       A, #0x1
   \   000036 B7 ..        LD        S:?b0, A
   \   000038 20 CE        JRA       L:??CopyBuffer_0
    153             else{
    154              dest[i] = srce[i];
   \                     ??CopyBuffer_2:
   \   00003A 5F           CLRW      X
   \   00003B 41           EXG       A, XL
   \   00003C B6 ..        LD        A, S:?b0
   \   00003E 41           EXG       A, XL
   \   00003F 72BB ....    ADDW      X, S:?w1
   \   000043 F6           LD        A, (X)
   \   000044 5F           CLRW      X
   \   000045 41           EXG       A, XL
   \   000046 B6 ..        LD        A, S:?b0
   \   000048 41           EXG       A, XL
   \   000049 72BB ....    ADDW      X, S:?w2
   \   00004D F7           LD        (X), A
    155              break;}
    156            }
    157            return i;
   \                     ??CopyBuffer_1:
   \   00004E B6 ..        LD        A, S:?b0
   \   000050 87           RETF
    158           }
    159          /*****************************************************************************/
    160          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    161          /*****                  source buffer must terminate with a 0x00.         ****/
    162          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    163          void CopyBufferDevice(char srce[]){
   \                     CopyBufferDevice:
   \   000000 BF ..        LDW       S:?w1, X
    164           u8 i;
    165           for (i=0; i < BFRSIZE; i++){
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferDevice_0:
   \   000005 5F           CLRW      X
   \   000006 41           EXG       A, XL
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 41           EXG       A, XL
   \   00000A C3 ....      CPW       X, L:BFRSIZE
   \   00000D 2E 45        JRSGE     L:??CopyBufferDevice_1
    166             if (srce[i] != 0x03)
   \   00000F 5F           CLRW      X
   \   000010 41           EXG       A, XL
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 41           EXG       A, XL
   \   000014 72BB ....    ADDW      X, S:?w1
   \   000018 F6           LD        A, (X)
   \   000019 A1 03        CP        A, #0x3
   \   00001B 27 1A        JREQ      L:??CopyBufferDevice_2
    167              Device_Xmit_Buffer[i] = srce[i];
   \   00001D 5F           CLRW      X
   \   00001E 41           EXG       A, XL
   \   00001F B6 ..        LD        A, S:?b0
   \   000021 41           EXG       A, XL
   \   000022 72BB ....    ADDW      X, S:?w1
   \   000026 F6           LD        A, (X)
   \   000027 5F           CLRW      X
   \   000028 41           EXG       A, XL
   \   000029 B6 ..        LD        A, S:?b0
   \   00002B 41           EXG       A, XL
   \   00002C D7 ....      LD        (L:Device_Xmit_Buffer,X), A
   \   00002F B6 ..        LD        A, S:?b0
   \   000031 AB 01        ADD       A, #0x1
   \   000033 B7 ..        LD        S:?b0, A
   \   000035 20 CE        JRA       L:??CopyBufferDevice_0
    168             else{
    169              Device_Xmit_Buffer[i] = srce[i];
   \                     ??CopyBufferDevice_2:
   \   000037 5F           CLRW      X
   \   000038 41           EXG       A, XL
   \   000039 B6 ..        LD        A, S:?b0
   \   00003B 41           EXG       A, XL
   \   00003C 72BB ....    ADDW      X, S:?w1
   \   000040 F6           LD        A, (X)
   \   000041 5F           CLRW      X
   \   000042 41           EXG       A, XL
   \   000043 B6 ..        LD        A, S:?b0
   \   000045 41           EXG       A, XL
   \   000046 D7 ....      LD        (L:Device_Xmit_Buffer,X), A
    170              i++;
   \   000049 B6 ..        LD        A, S:?b0
   \   00004B AB 01        ADD       A, #0x1
   \   00004D B7 ..        LD        S:?b0, A
    171              Device_Xmit_Char_Count =i;
   \   00004F B6 ..        LD        A, S:?b0
   \   000051 C7 ....      LD        L:Device_Xmit_Char_Count, A
    172              break;}
    173            }
    174          
    175           }
   \                     ??CopyBufferDevice_1:
   \   000054 87           RETF
    176          /*****************************************************************************/
    177          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    178          /*****                  source buffer must terminate with a 0x00.         ****/
    179          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    180          void CopyBufferGS1011 (char srce[]){
   \                     CopyBufferGS1011:
   \   000000 BF ..        LDW       S:?w1, X
    181           u8 i;
    182           for (i=0; i < BFRSIZE; i++){
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferGS1011_0:
   \   000005 5F           CLRW      X
   \   000006 41           EXG       A, XL
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 41           EXG       A, XL
   \   00000A C3 ....      CPW       X, L:BFRSIZE
   \   00000D 2E 3D        JRSGE     L:??CopyBufferGS1011_1
    183             if (srce[i] != 0)
   \   00000F 5F           CLRW      X
   \   000010 41           EXG       A, XL
   \   000011 B6 ..        LD        A, S:?b0
   \   000013 41           EXG       A, XL
   \   000014 72BB ....    ADDW      X, S:?w1
   \   000018 7D           TNZ       (X)
   \   000019 27 1A        JREQ      L:??CopyBufferGS1011_2
    184              GS1011_Xmit_Buffer[i] = srce[i];
   \   00001B 5F           CLRW      X
   \   00001C 41           EXG       A, XL
   \   00001D B6 ..        LD        A, S:?b0
   \   00001F 41           EXG       A, XL
   \   000020 72BB ....    ADDW      X, S:?w1
   \   000024 F6           LD        A, (X)
   \   000025 5F           CLRW      X
   \   000026 41           EXG       A, XL
   \   000027 B6 ..        LD        A, S:?b0
   \   000029 41           EXG       A, XL
   \   00002A D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
   \   00002D B6 ..        LD        A, S:?b0
   \   00002F AB 01        ADD       A, #0x1
   \   000031 B7 ..        LD        S:?b0, A
   \   000033 20 D0        JRA       L:??CopyBufferGS1011_0
    185             else{
    186              GS1011_Xmit_Buffer[i] = srce[i];
   \                     ??CopyBufferGS1011_2:
   \   000035 5F           CLRW      X
   \   000036 41           EXG       A, XL
   \   000037 B6 ..        LD        A, S:?b0
   \   000039 41           EXG       A, XL
   \   00003A 72BB ....    ADDW      X, S:?w1
   \   00003E F6           LD        A, (X)
   \   00003F 5F           CLRW      X
   \   000040 41           EXG       A, XL
   \   000041 B6 ..        LD        A, S:?b0
   \   000043 41           EXG       A, XL
   \   000044 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    187              GS1011_Xmit_Char_Count =i;
   \   000047 B6 ..        LD        A, S:?b0
   \   000049 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    188              break;}
    189            }
    190           }
   \                     ??CopyBufferGS1011_1:
   \   00004C 87           RETF
    191          /*****************************************************************************/
    192          /***** copy buffer from offset to terminator(pointer to destination, pointer to source buffer,****/
    193          /*****                                  number of bytes to copy)          ****/
    194          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    195          void copy_buffer_from_offset_to_terminator(char srcebufr[],char destbufr[], int ofst, char trm){
   \                     copy_buffer_from_offset_to_terminator:
   \   000000 BF ..        LDW       S:?w1, X
   \   000002 90BF ..      LDW       S:?w3, Y
   \   000005 90BE ..      LDW       Y, S:?w0
   \   000008 B7 ..        LD        S:?b0, A
    196          char destoffset,chkchr; 
    197          destoffset = 0;
   \   00000A 4F           CLR       A
   \   00000B B7 ..        LD        S:?b1, A
    198          for (destoffset =0; destoffset < 512; destoffset++){
                                                ^
Warning[Pa084]: pointless integer comparison, the result is always true
   \   00000D 4F           CLR       A
   \   00000E B7 ..        LD        S:?b1, A
    199            chkchr = srcebufr[ofst];
   \                     ??copy_buffer_from_offset_to_terminator_0:
   \   000010 93           LDW       X, Y
   \   000011 72BB ....    ADDW      X, S:?w1
   \   000015 F6           LD        A, (X)
   \   000016 B7 ..        LD        S:?b4, A
    200          if (chkchr != trm){
   \   000018 B6 ..        LD        A, S:?b0
   \   00001A B1 ..        CP        A, S:?b4
   \   00001C 27 1A        JREQ      L:??copy_buffer_from_offset_to_terminator_1
    201              destbufr[destoffset] = srcebufr[ofst];
   \   00001E 93           LDW       X, Y
   \   00001F 72BB ....    ADDW      X, S:?w1
   \   000023 F6           LD        A, (X)
   \   000024 5F           CLRW      X
   \   000025 41           EXG       A, XL
   \   000026 B6 ..        LD        A, S:?b1
   \   000028 41           EXG       A, XL
   \   000029 72BB ....    ADDW      X, S:?w3
   \   00002D F7           LD        (X), A
    202              ofst++;
   \   00002E 905C         INCW      Y
    203            }
   \   000030 B6 ..        LD        A, S:?b1
   \   000032 AB 01        ADD       A, #0x1
   \   000034 B7 ..        LD        S:?b1, A
   \   000036 20 D8        JRA       L:??copy_buffer_from_offset_to_terminator_0
    204          else
    205            break;
    206          }
    207           }
   \                     ??copy_buffer_from_offset_to_terminator_1:
   \   000038 87           RETF
    208          /*****************************************************************************/
    209          /***** copy buffer count(pointer to destination, pointer to source buffer,****/
    210          /*****                                  number of bytes to copy)          ****/
    211          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    212          void CopyBufferCounted (char dest[], char srce[], char cntr){
   \                     CopyBufferCounted:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
   \   000005 B7 ..        LD        S:?b1, A
    213          u8 i;
    214           
    215          for (i=0; i < cntr; i++){
   \   000007 4F           CLR       A
   \   000008 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferCounted_0:
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C B1 ..        CP        A, S:?b1
   \   00000E 24 1C        JRNC      L:??CopyBufferCounted_1
    216              dest[i] = srce[i];
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 41           EXG       A, XL
   \   000015 72BB ....    ADDW      X, S:?w1
   \   000019 F6           LD        A, (X)
   \   00001A 5F           CLRW      X
   \   00001B 41           EXG       A, XL
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E 41           EXG       A, XL
   \   00001F 72BB ....    ADDW      X, S:?w2
   \   000023 F7           LD        (X), A
    217            }
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 AB 01        ADD       A, #0x1
   \   000028 B7 ..        LD        S:?b0, A
   \   00002A 20 DE        JRA       L:??CopyBufferCounted_0
    218           }
   \                     ??CopyBufferCounted_1:
   \   00002C 87           RETF
    219          /*****************************************************************************/
    220          /***** CountChars (buffer pointer)                                         ****/
    221          /*****                  source buffer must terminate with a 0x00.         ****/
    222          /*****          Returns an integer for number of characters in the buffer ****/
    223          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    224          int CountChars(char *s){
   \                     CountChars:
   \   000000 BF ..        LDW       S:?w0, X
    225          int cntr;
    226            for (cntr=0; cntr < BFRSIZE; cntr++){
   \   000002 905F         CLRW      Y
   \   000004 93           LDW       X, Y
   \                     ??CountChars_0:
   \   000005 C3 ....      CPW       X, L:BFRSIZE
   \   000008 2E 0F        JRSGE     L:??CountChars_1
    227              if  (s[cntr] == 0x00)
   \   00000A 9093         LDW       Y, X
   \   00000C 72B9 ....    ADDW      Y, S:?w0
   \   000010 907D         TNZ       (Y)
   \   000012 26 02        JRNE      L:??CountChars_2
    228                break;
   \   000014 20 03        JRA       L:??CountChars_1
    229            }
   \                     ??CountChars_2:
   \   000016 5C           INCW      X
   \   000017 20 EC        JRA       L:??CountChars_0
    230            
    231            return cntr;
   \                     ??CountChars_1:
   \   000019 87           RETF
    232          }
    233          /*****************************************************************************/
    234          /***** CountChars (buffer pointer)                                         ****/
    235          /*****                  source buffer must terminate with a 0x00.         ****/
    236          /*****          Returns an integer for number of characters in the buffer ****/
    237          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    238          void CountGS1011Chars(void){
    239          char chr;
    240            for (GS1011_Xmit_Char_Count=0; GS1011_Xmit_Char_Count < BFRSIZE; GS1011_Xmit_Char_Count++){
   \                     CountGS1011Chars:
   \   000000 35 00 ....   MOV       L:GS1011_Xmit_Char_Count, #0x0
   \                     ??CountGS1011Chars_0:
   \   000004 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000007 5F           CLRW      X
   \   000008 97           LD        XL, A
   \   000009 C3 ....      CPW       X, L:BFRSIZE
   \   00000C 2E 27        JRSGE     L:??CountGS1011Chars_1
    241              chr = GS1011_Xmit_Buffer[GS1011_Xmit_Pointer];
   \   00000E CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   000011 D6 ....      LD        A, (L:GS1011_Xmit_Buffer,X)
   \   000014 B7 ..        LD        S:?b0, A
    242              if  (chr == 0x00){
   \   000016 3D ..        TNZ       S:?b0
   \   000018 26 0A        JRNE      L:??CountGS1011Chars_2
    243                GS1011_Xmit_Char_Count++;
   \   00001A C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00001D AB 01        ADD       A, #0x1
   \   00001F C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    244                break;}
   \   000022 20 11        JRA       L:??CountGS1011Chars_1
    245              GS1011_Xmit_Pointer++;
   \                     ??CountGS1011Chars_2:
   \   000024 CE ....      LDW       X, L:GS1011_Xmit_Pointer
   \   000027 5C           INCW      X
   \   000028 CF ....      LDW       L:GS1011_Xmit_Pointer, X
    246            }
   \   00002B C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00002E AB 01        ADD       A, #0x1
   \   000030 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
   \   000033 20 CF        JRA       L:??CountGS1011Chars_0
    247          }
   \                     ??CountGS1011Chars_1:
   \   000035 87           RETF
    248          
    249          /*****************************************************************************/
    250          /***** Find string ( buffer pointer, sting)                                         ****/
    251          /*****                  source buffer must terminate with a 0x00.         ****/
    252          /*****          Returns an integer for number of characters in the buffer ****/
    253          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    254          void FindGS1011Chars(char chrstrng[]){
   \                     FindGS1011Chars:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w1, X
    255          int bufptr, strptr,strcnt,i;
    256          char chr,chr1;
    257              GS1011_String_Found = 0;      /* expect not to find it*/
   \   000006 35 00 ....   MOV       L:GS1011_String_Found, #0x0
    258              strptr=0x00;                  /*point at first byte of compare string*/
   \   00000A 905F         CLRW      Y
   \   00000C 90BF ..      LDW       S:?w0, Y
    259          for (i = 0; i< 6; i++){
   \   00000F 905F         CLRW      Y
   \   000011 90BF ..      LDW       S:?w3, Y
   \                     ??FindGS1011Chars_0:
   \   000014 90BE ..      LDW       Y, S:?w3
   \   000017 90A3 0006    CPW       Y, #0x6
   \   00001B 2E 1B        JRSGE     L:??FindGS1011Chars_1
    260            if (chrstrng[i] == 0x00){
   \   00001D 90BE ..      LDW       Y, S:?w3
   \   000020 72B9 ....    ADDW      Y, S:?w1
   \   000024 907D         TNZ       (Y)
   \   000026 26 06        JRNE      L:??FindGS1011Chars_2
    261              strcnt = i;
   \   000028 8D ......    CALLF     L:?mov_w2_w3
    262              break;}
   \   00002C 20 0A        JRA       L:??FindGS1011Chars_1
    263          }
   \                     ??FindGS1011Chars_2:
   \   00002E 90BE ..      LDW       Y, S:?w3
   \   000031 905C         INCW      Y
   \   000033 90BF ..      LDW       S:?w3, Y
   \   000036 20 DC        JRA       L:??FindGS1011Chars_0
    264          for (bufptr=0; bufptr < GS1011_Rvcr_Count; bufptr++){
   \                     ??FindGS1011Chars_1:
   \   000038 905F         CLRW      Y
   \   00003A 93           LDW       X, Y
   \                     ??FindGS1011Chars_3:
   \   00003B C3 ....      CPW       X, L:GS1011_Rvcr_Count
   \   00003E 2F 03        JRSLT     ??lb_0
   \   000040 CC ....      JP        L:??FindGS1011Chars_4
    265              if (GS1011_String_Found == 1) 
   \                     ??lb_0:
   \   000043 C6 ....      LD        A, L:GS1011_String_Found
   \   000046 A1 01        CP        A, #0x1
   \   000048 26 02        JRNE      L:??FindGS1011Chars_5
    266                break;
   \   00004A 20 79        JRA       L:??FindGS1011Chars_4
    267              chr = GS1011_Receiver_Buffer[bufptr];
   \                     ??FindGS1011Chars_5:
   \   00004C D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   00004F B7 ..        LD        S:?b9, A
    268              chr1 = chrstrng[strptr];
   \   000051 90BE ..      LDW       Y, S:?w0
   \   000054 72B9 ....    ADDW      Y, S:?w1
   \   000058 90F6         LD        A, (Y)
   \   00005A B7 ..        LD        S:?b8, A
    269              if (chr == chr1){                   /*match first byte of string? */
   \   00005C B6 ..        LD        A, S:?b8
   \   00005E B1 ..        CP        A, S:?b9
   \   000060 26 5F        JRNE      L:??FindGS1011Chars_6
    270                for (i=1; i <= strcnt-1; i++){
   \   000062 90AE 0001    LDW       Y, #0x1
   \   000066 90BF ..      LDW       S:?w3, Y
   \                     ??FindGS1011Chars_7:
   \   000069 90BE ..      LDW       Y, S:?w2
   \   00006C 905A         DECW      Y
   \   00006E 90B3 ..      CPW       Y, S:?w3
   \   000071 2F 4E        JRSLT     L:??FindGS1011Chars_6
    271                  bufptr++;
   \   000073 5C           INCW      X
    272                  strptr++;
   \   000074 90BE ..      LDW       Y, S:?w0
   \   000077 905C         INCW      Y
   \   000079 90BF ..      LDW       S:?w0, Y
    273                  chr = GS1011_Receiver_Buffer[bufptr];
   \   00007C D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   00007F B7 ..        LD        S:?b9, A
    274                  chr1 = chrstrng[strptr];    /*keep checking till end*/
   \   000081 90BE ..      LDW       Y, S:?w0
   \   000084 72B9 ....    ADDW      Y, S:?w1
   \   000088 90F6         LD        A, (Y)
   \   00008A B7 ..        LD        S:?b8, A
    275                  if (chr != chr1){
   \   00008C B6 ..        LD        A, S:?b8
   \   00008E B1 ..        CP        A, S:?b9
   \   000090 27 07        JREQ      L:??FindGS1011Chars_8
    276                    strptr=0x00;                 /*no reset the string pointer*/
   \   000092 905F         CLRW      Y
   \   000094 90BF ..      LDW       S:?w0, Y
    277                    break;
   \   000097 20 28        JRA       L:??FindGS1011Chars_6
    278                   }
    279                  else 
    280                    if (i == strcnt-1){
   \                     ??FindGS1011Chars_8:
   \   000099 90BE ..      LDW       Y, S:?w2
   \   00009C 905A         DECW      Y
   \   00009E 90B3 ..      CPW       Y, S:?w3
   \   0000A1 26 14        JRNE      L:??FindGS1011Chars_9
    281                    Found_String_At_Byte = (bufptr - (strcnt-1));  
   \   0000A3 9093         LDW       Y, X
   \   0000A5 72B2 ....    SUBW      Y, S:?w2
   \   0000A9 72A2 FFFF    SUBW      Y, #0xffffffffffffffff
   \   0000AD 90CF ....    LDW       L:Found_String_At_Byte, Y
    282                    GS1011_String_Found = 1;
   \   0000B1 35 01 ....   MOV       L:GS1011_String_Found, #0x1
    283          
    284                    break;
   \   0000B5 20 0A        JRA       L:??FindGS1011Chars_6
    285                    }
    286                }
   \                     ??FindGS1011Chars_9:
   \   0000B7 90BE ..      LDW       Y, S:?w3
   \   0000BA 905C         INCW      Y
   \   0000BC 90BF ..      LDW       S:?w3, Y
   \   0000BF 20 A8        JRA       L:??FindGS1011Chars_7
    287              }
    288             }
   \                     ??FindGS1011Chars_6:
   \   0000C1 5C           INCW      X
   \   0000C2 CC ....      JP        L:??FindGS1011Chars_3
    289          }
   \                     ??FindGS1011Chars_4:
   \   0000C5 AC ......    JPF       L:?epilogue_w4
    290          
    291          /*****************************************************************************/
    292          /***** CountChars (buffer pointer)                                         ****/
    293          /*****                  source buffer must terminate with a 0x00.         ****/
    294          /*****          Returns an integer for number of characters in the buffer ****/
    295          /*****************************************************************************/
    296          /*void CountDeviceChars(void){
    297          char chr;
    298            for (Device_Xmit_Char_Count=0; Device_Xmit_Char_Count < BFRSIZE; Device_Xmit_Char_Count++){
    299              chr = Device_Xmit_Pointer;
    300              if  (chr == 0x03){
    301                Device_Xmit_Char_Count++;
    302                break;
    303                }
    304                Device_Xmit_Pointer++;
    305            }
    306          }*/
    307          /*****************************************************************************/
    308          /*****              DEVICE BUFFER  HANDLING ROUTINES                      ****/
    309          /*****  While the GS1011 buffers are purely ASCII, the Device_Buffer can  ****/
    310          /*****    ANY type of data, not only in the packet data, but as counts,   ****/
    311          /*****    etc. in the header of the message.                              ****/
    312          /*****                                                                    ****/
    313          /*****    where bufr is buffer containing parameters                      ****/
    314          /*****          ptr is pointer at begining of parameter                   ****/
    315          /*****          cntr is the parameter counter                             ****/
    316          /*****************************************************************************/
    317          
    318          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      13  Add_Char_to_Buffer
      21  Add_Char_to_GS1011_Buffer
      68  Add_Integer_to_Buffer
      63  Add_String_to_Buffer
      52  Add_String_to_GS1011_Buffer
      81  CopyBuffer
      45  CopyBufferCounted
      85  CopyBufferDevice
      77  CopyBufferGS1011
      26  CountChars
      54  CountGS1011Chars
      36  FillBuffer
     201  FindGS1011Chars
      24  InitializeDeviceBuffer
      29  InitializeGS1011Buffer
      57  copy_buffer_from_offset_to_terminator

 
 932 bytes in section .far_func.text
 
 932 bytes of CODE memory

Errors: none
Warnings: 1
