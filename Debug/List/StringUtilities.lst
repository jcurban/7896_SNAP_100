###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.40.1.50106 for STM8             03/Jul/2013  05:48:34 #
# Copyright 2010-2013 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUti #
#                    lities.c                                                 #
#    Command line =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUti #
#                    lities.c -e --enable_multibytes -On --no_cse             #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_cross_call --debug --code_model medium              #
#                    --data_model medium -o C:\Users\jurban\Documents\GitHub\ #
#                    7896_SNAP_100\Debug\Obj\ --dlib_config "C:\Program       #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\stm8\LIB\dlstm8mmn.h" -D STM8S007 -lC                #
#                    C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\ -I .\ --no_system_include --require_prototypes        #
#                    --vregs 16                                               #
#    List file    =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Lis #
#                    t\StringUtilities.lst                                    #
#    Object file  =  C:\Users\jurban\Documents\GitHub\7896_SNAP_100\Debug\Obj #
#                    \StringUtilities.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jurban\Documents\GitHub\7896_SNAP_100\StringUtilities.c
      1          #include "stm8s.h"
      2          #include "SNAP_Defines.h"
      3          
      4          extern int Found_String_At_Byte;
      5          extern u8 GS1011_String_Found;
      6          extern char Device_Xmit_Pointer;
      7          extern u8 Device_Xmit_Char_Count;
      8          extern u8 GS1011_Xmit_Char_Count;
      9          extern int GS1011_Xmit_Pointer;
     10          extern char GS1011_Xmit_Setup_Char_Pointer;
     11          extern char Device_Xmit_Setup_Char_Pointer;
     12          extern int GS1011_Rvcr_Count;
     13          extern char GS1011_Xmit_Buffer[];
     14          extern char Device_Xmit_Buffer[];
     15          extern char GS1011_Receiver_Buffer[];
     16          extern char Device_Receiver_Buffer[];
     17          extern u16 GS1011_Rcvr_InPtr;
     18          extern u16 GS1011_Rcvr_OutPtr;
     19          extern u8 Device_RX_InPtr;
     20          extern u8 Device_RX_OutPtr;
     21          extern char Device_Serial_number[];
     22          extern char Device_Processing_Buffer[];
     23          
     24          /*****************************************************************************/
     25          /*****            STRING UTILITY ROUTINES                                 ****/
     26          /*****************************************************************************/
     27          int CountChars(char s[]);
     28          void CopyBufferGS1011(char srce[]);
     29          char CountGS1011Chars(void);
     30          char CopyBuffer (char dest[], char srce[]);
     31          void CopyBufferDevice( char srce[]);
     32          void CopyBufferGS1011 (char srce[]);
     33          void CopyBufferCounted (char dest[], char srce[], char cntr);
     34          void FillBuffer (char bufr[],char filchr, char cntr);
     35          
     36          void InitializeDeviceBuffer (void);
     37          void InitializeGS1011Buffer (void);
     38          void Add_Char_to_Buffer (char bufr[], int ptr,char chr);
     39          void Add_Char_to_GS1011_Buffer (char chr);
     40          void Add_Integer_to_Buffer (char bufr[],int ptr, int vint);
     41          int Add_String_to_Buffer (char bufr[],int ptr, char srce[]);
     42          void Add_String_to_GS1011_Buffer ( char srce[]);
     43          void Add_String_to_GS1011_BufferCounted ( char srce[], char cnt);
     44          void CopySerialNumber(void);
     45          void FindGS1011Chars(char chrstrng[]);
     46          void copy_buffer_from_offset_to_terminator(char srcebufr[],char destbufr[], int ofst, char trm);
     47          /*****************************************************************************/
     48          /*****              GENERAL BUFFER HANDLING ROUTINES                      ****/
     49          /*****************************************************************************/
     50          
     51          /*****************************************************************************/
     52          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     53          /*****                  source buffer must terminate with a 0x00.         ****/
     54          /*****          Returns an integer for number of characters in the buffer ****/
     55          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     56          void InitializeDeviceBuffer (void){
     57          int ptr;
     58            for (ptr = 0; ptr < 255; ptr++) 
   \                     InitializeDeviceBuffer:
   \   000000 905F         CLRW      Y
   \   000002 93           LDW       X, Y
   \                     ??InitializeDeviceBuffer_0:
   \   000003 A3 00FF      CPW       X, #0xff
   \   000006 2E 07        JRSGE     L:??InitializeDeviceBuffer_1
     59             Device_Receiver_Buffer[ptr] = 0x00;
   \   000008 4F           CLR       A
   \   000009 D7 ....      LD        (L:Device_Receiver_Buffer,X), A
   \   00000C 5C           INCW      X
   \   00000D 20 F4        JRA       L:??InitializeDeviceBuffer_0
     60          Device_RX_InPtr = 0;
   \                     ??InitializeDeviceBuffer_1:
   \   00000F 35 00 ....   MOV       L:Device_RX_InPtr, #0x0
     61          Device_RX_OutPtr = 0;
   \   000013 35 00 ....   MOV       L:Device_RX_OutPtr, #0x0
     62          }
   \   000017 87           RETF
     63          /*****************************************************************************/
     64          /***** InitializeDeviceBuffer (buffer pointer)                            ****/
     65          /*****                  source buffer must terminate with a 0x00.         ****/
     66          /*****          Returns an integer for number of characters in the buffer ****/
     67          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     68          void InitializeGS1011Buffer (void){
     69          int ptr;
     70          for (ptr = 0; ptr < BFRSIZEX2; ptr++) 
   \                     InitializeGS1011Buffer:
   \   000000 5F           CLRW      X
   \   000001 9093         LDW       Y, X
   \                     ??InitializeGS1011Buffer_0:
   \   000003 90A3 0200    CPW       Y, #0x200
   \   000007 2E 0B        JRSGE     L:??InitializeGS1011Buffer_1
     71             GS1011_Receiver_Buffer[ptr] = 0x00;
   \   000009 4F           CLR       A
   \   00000A 93           LDW       X, Y
   \   00000B D7 ....      LD        (L:GS1011_Receiver_Buffer,X), A
   \   00000E 93           LDW       X, Y
   \   00000F 5C           INCW      X
   \   000010 9093         LDW       Y, X
   \   000012 20 EF        JRA       L:??InitializeGS1011Buffer_0
     72          for (ptr = 0; ptr < BFRSIZE; ptr++)
   \                     ??InitializeGS1011Buffer_1:
   \   000014 5F           CLRW      X
   \   000015 9093         LDW       Y, X
   \                     ??InitializeGS1011Buffer_2:
   \   000017 90A3 00FF    CPW       Y, #0xff
   \   00001B 2E 0B        JRSGE     L:??InitializeGS1011Buffer_3
     73              GS1011_Xmit_Buffer[ptr] = 0x00;
   \   00001D 4F           CLR       A
   \   00001E 93           LDW       X, Y
   \   00001F D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
   \   000022 93           LDW       X, Y
   \   000023 5C           INCW      X
   \   000024 9093         LDW       Y, X
   \   000026 20 EF        JRA       L:??InitializeGS1011Buffer_2
     74          
     75          GS1011_Rcvr_InPtr = 0;
   \                     ??InitializeGS1011Buffer_3:
   \   000028 5F           CLRW      X
   \   000029 CF ....      LDW       L:GS1011_Rcvr_InPtr, X
     76          GS1011_Rcvr_OutPtr = 0;
   \   00002C 5F           CLRW      X
   \   00002D CF ....      LDW       L:GS1011_Rcvr_OutPtr, X
     77          GS1011_Xmit_Char_Count=0;
   \   000030 35 00 ....   MOV       L:GS1011_Xmit_Char_Count, #0x0
     78          GS1011_Xmit_Setup_Char_Pointer=0;
   \   000034 35 00 ....   MOV       L:GS1011_Xmit_Setup_Char_Pointer, #0x0
     79          }
   \   000038 87           RETF
     80          /******************************************************************************/
     81          /***** Add_Char_to_Buffer (char s)                                         ****/
     82          /*****                 Buffer pointer always contain the next space        ****/
     83          /*****                    available for data storage                       ****/
     84          /*****     CALLING ROUTINE IS RESPONSIBLE TO BE SURE THERE'S ROOM AVAILABLE****/
     85          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     86          void Add_Char_to_Buffer (char bufr[], int ptr, char chr){
   \                     Add_Char_to_Buffer:
   \   000000 BF ..        LDW       S:?w0, X
   \   000002 93           LDW       X, Y
     87            bufr[ptr] = chr;
   \   000003 9093         LDW       Y, X
   \   000005 72B9 ....    ADDW      Y, S:?w0
   \   000009 90F7         LD        (Y), A
     88            ptr++;
   \   00000B 5C           INCW      X
     89          }
   \   00000C 87           RETF
     90          
     91          /******************************************************************************/
     92          /***** Add_Char_to_GS1011_Buffer (char s)                                  ****/
     93          /*****                 Buffer pointer always contain the next space        ****/
     94          /*****                    available for data storage                       ****/
     95          /*****     CALLING ROUTINE IS RESPONSIBLE TO BE SURE THERE'S ROOM AVAILABLE****/
     96          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
     97          void Add_Char_to_GS1011_Buffer (char chr){
   \                     Add_Char_to_GS1011_Buffer:
   \   000000 B7 ..        LD        S:?b0, A
     98            GS1011_Xmit_Buffer[GS1011_Xmit_Setup_Char_Pointer] = chr;
   \   000002 C6 ....      LD        A, L:GS1011_Xmit_Setup_Char_Pointer
   \   000005 5F           CLRW      X
   \   000006 97           LD        XL, A
   \   000007 B6 ..        LD        A, S:?b0
   \   000009 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
     99            GS1011_Xmit_Setup_Char_Pointer++;
   \   00000C C6 ....      LD        A, L:GS1011_Xmit_Setup_Char_Pointer
   \   00000F AB 01        ADD       A, #0x1
   \   000011 C7 ....      LD        L:GS1011_Xmit_Setup_Char_Pointer, A
    100          }
   \   000014 87           RETF
    101          
    102          /*****************************************************************************/
    103          /***** Add_Integer_to_Buffer (int s)                               ****/
    104          /*****                 Device buffers always contain the next space       ****/
    105          /*****                    available for data storage                      ****/
    106          /*****                 as an int in first 2 bytes                         ****/
    107          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    108          void Add_Integer_to_Buffer (char bufr[], int ptr, int vint){
   \                     Add_Integer_to_Buffer:
   \   000000 BF ..        LDW       S:?w3, X
   \   000002 8D ......    CALLF     L:?mov_w2_w0
    109            int high, low;
    110            high = vint>>8;            /* calculate high byte and save */
   \   000006 BE ..        LDW       X, S:?w2
   \   000008 8D ......    CALLF     L:?sra16_x_x_8
   \   00000C BF ..        LDW       S:?w1, X
    111            low = vint & 0Xff;             /* calculate low byte and save */
   \   00000E BE ..        LDW       X, S:?w2
   \   000010 02           RLWA      X, A
   \   000011 A4 00        AND       A, #0x0
   \   000013 02           RLWA      X, A
   \   000014 A4 FF        AND       A, #0xff
   \   000016 02           RLWA      X, A
   \   000017 BF ..        LDW       S:?w0, X
    112            bufr[ptr] = low;
   \   000019 93           LDW       X, Y
   \   00001A 72BB ....    ADDW      X, S:?w3
   \   00001E B6 ..        LD        A, S:?b1
   \   000020 F7           LD        (X), A
    113            bufr[ptr+1] = high;
   \   000021 93           LDW       X, Y
   \   000022 72BB ....    ADDW      X, S:?w3
   \   000026 5C           INCW      X
   \   000027 B6 ..        LD        A, S:?b3
   \   000029 F7           LD        (X), A
    114            ptr +=2;
   \   00002A 72A9 0002    ADDW      Y, #0x2
    115          }
   \   00002E 87           RETF
    116          
    117          /*****************************************************************************/
    118          /***** Add_String_to_Buffer (buffer pointer, source pointer)       ****/
    119          /*****                 buffer & source buffer must terminate with a 0x00. ****/
    120          /*****    overwrites the receiving buffers terminating 0x00               ****/
    121          /*****                  copies source terminating 0x00.                   ****/
    122          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    123          int Add_String_to_Buffer (char bufr[],int ptr, char srce[]){
   \                     Add_String_to_Buffer:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
    124           u16 i;
    125              
    126              for (i = 0; i<BFRSIZE; i++){
   \   000005 5F           CLRW      X
   \   000006 9093         LDW       Y, X
   \                     ??Add_String_to_Buffer_0:
   \   000008 90A3 00FF    CPW       Y, #0xff
   \   00000C 24 1D        JRNC      L:??Add_String_to_Buffer_1
    127                 bufr[ptr] = srce[i];      /* store string into buffer until */
   \   00000E 93           LDW       X, Y
   \   00000F 72BB ....    ADDW      X, S:?w0
   \   000013 F6           LD        A, (X)
   \   000014 BE ..        LDW       X, S:?w1
   \   000016 72BB ....    ADDW      X, S:?w2
   \   00001A F7           LD        (X), A
    128                 if (srce[i] == 0x00){
   \   00001B 93           LDW       X, Y
   \   00001C 72BB ....    ADDW      X, S:?w0
   \   000020 7D           TNZ       (X)
   \   000021 26 02        JRNE      L:??Add_String_to_Buffer_2
    129                      break;
   \   000023 20 06        JRA       L:??Add_String_to_Buffer_1
    130                  }
    131               }
   \                     ??Add_String_to_Buffer_2:
   \   000025 93           LDW       X, Y
   \   000026 5C           INCW      X
   \   000027 9093         LDW       Y, X
   \   000029 20 DD        JRA       L:??Add_String_to_Buffer_0
    132          return ptr;
   \                     ??Add_String_to_Buffer_1:
   \   00002B BE ..        LDW       X, S:?w1
   \   00002D 87           RETF
    133          }
    134          
    135          /*****************************************************************************/
    136          /***** Add_String_to_GS1011_Buffer (buffer pointer, source pointer)       ****/
    137          /*****                 buffer & source buffer must terminate with a 0x00. ****/
    138          /*****    overwrites the receiving buffers terminating 0x00               ****/
    139          /*****                  copies source terminating 0x00.                   ****/
    140          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    141          void Add_String_to_GS1011_Buffer ( char srce[]){
   \                     Add_String_to_GS1011_Buffer:
   \   000000 BF ..        LDW       S:?w1, X
    142           u16 i;
    143               for (i = 0; i<BFRSIZE; i++){
   \   000002 5F           CLRW      X
   \   000003 9093         LDW       Y, X
   \                     ??Add_String_to_GS1011_Buffer_0:
   \   000005 90A3 00FF    CPW       Y, #0xff
   \   000009 24 28        JRNC      L:??Add_String_to_GS1011_Buffer_1
    144               GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = srce[i];      /* store string into buffer until */
   \   00000B 93           LDW       X, Y
   \   00000C 72BB ....    ADDW      X, S:?w1
   \   000010 F6           LD        A, (X)
   \   000011 B7 ..        LD        S:?b0, A
   \   000013 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000016 5F           CLRW      X
   \   000017 97           LD        XL, A
   \   000018 B6 ..        LD        A, S:?b0
   \   00001A D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    145                  if (srce[i] == 0x00)break;
   \   00001D 93           LDW       X, Y
   \   00001E 72BB ....    ADDW      X, S:?w1
   \   000022 7D           TNZ       (X)
   \   000023 26 02        JRNE      L:??Add_String_to_GS1011_Buffer_2
   \   000025 20 0C        JRA       L:??Add_String_to_GS1011_Buffer_1
    146               GS1011_Xmit_Char_Count++;   
   \                     ??Add_String_to_GS1011_Buffer_2:
   \   000027 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00002A AB 01        ADD       A, #0x1
   \   00002C C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    147               }
   \   00002F 905C         INCW      Y
   \   000031 20 D2        JRA       L:??Add_String_to_GS1011_Buffer_0
    148          }
   \                     ??Add_String_to_GS1011_Buffer_1:
   \   000033 87           RETF
    149          
    150          /*****************************************************************************/
    151          /***** Add_String_to_GS1011_Buffer (buffer pointer, source pointer)       ****/
    152          /*****                 buffer & source buffer must terminate with a 0x00. ****/
    153          /*****    overwrites the receiving buffers terminating 0x00               ****/
    154          /*****                  copies source terminating 0x00.                   ****/
    155          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    156          void Add_String_to_GS1011_BufferCounted ( char srce[], char cnt){
   \                     Add_String_to_GS1011_BufferCounted:
   \   000000 BF ..        LDW       S:?w3, X
   \   000002 B7 ..        LD        S:?b1, A
    157           u16 i;
    158           if ((GS1011_Xmit_Char_Count + cnt) < BFRSIZE){
   \   000004 5F           CLRW      X
   \   000005 41           EXG       A, XL
   \   000006 B6 ..        LD        A, S:?b1
   \   000008 41           EXG       A, XL
   \   000009 BF ..        LDW       S:?w1, X
   \   00000B C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00000E 5F           CLRW      X
   \   00000F 97           LD        XL, A
   \   000010 72BB ....    ADDW      X, S:?w1
   \   000014 A3 00FF      CPW       X, #0xff
   \   000017 2E 2E        JRSGE     L:??Add_String_to_GS1011_BufferCounted_0
    159               for (i = 0; i<=cnt; i++)      
   \   000019 5F           CLRW      X
   \   00001A BF ..        LDW       S:?w2, X
   \                     ??Add_String_to_GS1011_BufferCounted_1:
   \   00001C 5F           CLRW      X
   \   00001D 41           EXG       A, XL
   \   00001E B6 ..        LD        A, S:?b1
   \   000020 41           EXG       A, XL
   \   000021 B3 ..        CPW       X, S:?w2
   \   000023 25 22        JRC       L:??Add_String_to_GS1011_BufferCounted_0
    160               {
    161                        GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = srce[i];      /* store string into buffer until */
   \   000025 BE ..        LDW       X, S:?w2
   \   000027 72BB ....    ADDW      X, S:?w3
   \   00002B F6           LD        A, (X)
   \   00002C B7 ..        LD        S:?b0, A
   \   00002E C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000031 5F           CLRW      X
   \   000032 97           LD        XL, A
   \   000033 B6 ..        LD        A, S:?b0
   \   000035 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    162                        GS1011_Xmit_Char_Count++;                    /*   the strings terminating 0x00 */          
   \   000038 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00003B AB 01        ADD       A, #0x1
   \   00003D C7 ....      LD        L:GS1011_Xmit_Char_Count, A
    163               }
   \   000040 BE ..        LDW       X, S:?w2
   \   000042 5C           INCW      X
   \   000043 BF ..        LDW       S:?w2, X
   \   000045 20 D5        JRA       L:??Add_String_to_GS1011_BufferCounted_1
    164            }
    165          }
   \                     ??Add_String_to_GS1011_BufferCounted_0:
   \   000047 87           RETF
    166          /*****************************************************************************/
    167          /***** FillBuffer (buffer pointer)                                         ****/
    168          /*****                  source buffer must terminate with a 0x00.         ****/
    169          /*****          Returns an integer for number of characters in the buffer ****/
    170          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    171          void FillBuffer (char bufr[],char filchr, char cntr){
   \                     FillBuffer:
   \   000000 B7 ..        LD        S:?b1, A
    172           u8 i;
    173           if (cntr < sizeof(bufr)){
   \   000002 B6 ..        LD        A, S:?b0
   \   000004 A1 02        CP        A, #0x2
   \   000006 24 21        JRNC      L:??FillBuffer_0
    174           for (i = 0; i < cntr; i++) {
   \   000008 4F           CLR       A
   \   000009 B7 ..        LD        S:?b4, A
   \                     ??FillBuffer_1:
   \   00000B B6 ..        LD        A, S:?b4
   \   00000D B1 ..        CP        A, S:?b0
   \   00000F 24 18        JRNC      L:??FillBuffer_0
    175             bufr[i] = filchr;
   \   000011 905F         CLRW      Y
   \   000013 61           EXG       A, YL
   \   000014 B6 ..        LD        A, S:?b4
   \   000016 61           EXG       A, YL
   \   000017 BF ..        LDW       S:?w1, X
   \   000019 72B9 ....    ADDW      Y, S:?w1
   \   00001D B6 ..        LD        A, S:?b1
   \   00001F 90F7         LD        (Y), A
    176           }
   \   000021 B6 ..        LD        A, S:?b4
   \   000023 AB 01        ADD       A, #0x1
   \   000025 B7 ..        LD        S:?b4, A
   \   000027 20 E2        JRA       L:??FillBuffer_1
    177           }
    178          }
   \                     ??FillBuffer_0:
   \   000029 87           RETF
    179          /*****************************************************************************/
    180          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    181          /*****                  source buffer must terminate with a 0x00.         ****/
    182          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    183          char CopyBuffer (char dest[], char srce[]){
   \                     CopyBuffer:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
    184           u8 i;
    185           for (i=0; i < BFRSIZE; i++){
   \   000005 4F           CLR       A
   \   000006 B7 ..        LD        S:?b0, A
   \                     ??CopyBuffer_0:
   \   000008 B6 ..        LD        A, S:?b0
   \   00000A A1 FF        CP        A, #0xff
   \   00000C 27 2A        JREQ      L:??CopyBuffer_1
    186             dest[i] = srce[i];
   \   00000E 5F           CLRW      X
   \   00000F 41           EXG       A, XL
   \   000010 B6 ..        LD        A, S:?b0
   \   000012 41           EXG       A, XL
   \   000013 72BB ....    ADDW      X, S:?w1
   \   000017 F6           LD        A, (X)
   \   000018 5F           CLRW      X
   \   000019 41           EXG       A, XL
   \   00001A B6 ..        LD        A, S:?b0
   \   00001C 41           EXG       A, XL
   \   00001D 72BB ....    ADDW      X, S:?w2
   \   000021 F7           LD        (X), A
    187             if (srce[i] == NULL) break;
   \   000022 5F           CLRW      X
   \   000023 41           EXG       A, XL
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 41           EXG       A, XL
   \   000027 72BB ....    ADDW      X, S:?w1
   \   00002B 7D           TNZ       (X)
   \   00002C 26 02        JRNE      L:??CopyBuffer_2
   \   00002E 20 08        JRA       L:??CopyBuffer_1
    188            }
   \                     ??CopyBuffer_2:
   \   000030 B6 ..        LD        A, S:?b0
   \   000032 AB 01        ADD       A, #0x1
   \   000034 B7 ..        LD        S:?b0, A
   \   000036 20 D0        JRA       L:??CopyBuffer_0
    189            return i;
   \                     ??CopyBuffer_1:
   \   000038 B6 ..        LD        A, S:?b0
   \   00003A 87           RETF
    190           }
    191          /*****************************************************************************/
    192          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    193          /*****                  source buffer must terminate with a 0x00.         ****/
    194          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    195          void CopyBufferDevice(char srce[]){
   \                     CopyBufferDevice:
   \   000000 BF ..        LDW       S:?w1, X
    196           u8 i;
    197           for (i=0; i < BFRSIZE; i++){
   \   000002 4F           CLR       A
   \   000003 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferDevice_0:
   \   000005 B6 ..        LD        A, S:?b0
   \   000007 A1 FF        CP        A, #0xff
   \   000009 27 2F        JREQ      L:??CopyBufferDevice_1
    198             Device_Xmit_Buffer[i] = srce[i];
   \   00000B 5F           CLRW      X
   \   00000C 41           EXG       A, XL
   \   00000D B6 ..        LD        A, S:?b0
   \   00000F 41           EXG       A, XL
   \   000010 72BB ....    ADDW      X, S:?w1
   \   000014 F6           LD        A, (X)
   \   000015 5F           CLRW      X
   \   000016 41           EXG       A, XL
   \   000017 B6 ..        LD        A, S:?b0
   \   000019 41           EXG       A, XL
   \   00001A D7 ....      LD        (L:Device_Xmit_Buffer,X), A
    199             if (srce[i] == ETX){
   \   00001D 5F           CLRW      X
   \   00001E 41           EXG       A, XL
   \   00001F B6 ..        LD        A, S:?b0
   \   000021 41           EXG       A, XL
   \   000022 72BB ....    ADDW      X, S:?w1
   \   000026 F6           LD        A, (X)
   \   000027 A1 03        CP        A, #0x3
   \   000029 26 07        JRNE      L:??CopyBufferDevice_2
    200              Device_Xmit_Setup_Char_Pointer =i;
   \   00002B B6 ..        LD        A, S:?b0
   \   00002D C7 ....      LD        L:Device_Xmit_Setup_Char_Pointer, A
    201              break;
   \   000030 20 08        JRA       L:??CopyBufferDevice_1
    202             }
    203            }
   \                     ??CopyBufferDevice_2:
   \   000032 B6 ..        LD        A, S:?b0
   \   000034 AB 01        ADD       A, #0x1
   \   000036 B7 ..        LD        S:?b0, A
   \   000038 20 CB        JRA       L:??CopyBufferDevice_0
    204           }
   \                     ??CopyBufferDevice_1:
   \   00003A 87           RETF
    205          
    206          /*****************************************************************************/
    207          /***** copy buffer (pointer to destination, pointer to source buffer)     ****/
    208          /*****                  source buffer must terminate with a 0x00.         ****/
    209          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    210          void CopyBufferGS1011 (char srce[]){
   \                     CopyBufferGS1011:
   \   000000 BF ..        LDW       S:?w1, X
    211           for (GS1011_Xmit_Char_Count=0; GS1011_Xmit_Char_Count < BFRSIZE; GS1011_Xmit_Char_Count++){
   \   000002 35 00 ....   MOV       L:GS1011_Xmit_Char_Count, #0x0
   \                     ??CopyBufferGS1011_0:
   \   000006 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000009 A1 FF        CP        A, #0xff
   \   00000B 27 2E        JREQ      L:??CopyBufferGS1011_1
    212              GS1011_Xmit_Buffer[GS1011_Xmit_Char_Count] = srce[GS1011_Xmit_Char_Count];
   \   00000D C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000010 5F           CLRW      X
   \   000011 97           LD        XL, A
   \   000012 72BB ....    ADDW      X, S:?w1
   \   000016 F6           LD        A, (X)
   \   000017 B7 ..        LD        S:?b0, A
   \   000019 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   00001C 5F           CLRW      X
   \   00001D 97           LD        XL, A
   \   00001E B6 ..        LD        A, S:?b0
   \   000020 D7 ....      LD        (L:GS1011_Xmit_Buffer,X), A
    213              if (srce[GS1011_Xmit_Char_Count] == 0){
   \   000023 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000026 5F           CLRW      X
   \   000027 97           LD        XL, A
   \   000028 72BB ....    ADDW      X, S:?w1
   \   00002C 7D           TNZ       (X)
   \   00002D 26 02        JRNE      L:??CopyBufferGS1011_2
    214                  break;
   \   00002F 20 0A        JRA       L:??CopyBufferGS1011_1
    215              }
    216            }
   \                     ??CopyBufferGS1011_2:
   \   000031 C6 ....      LD        A, L:GS1011_Xmit_Char_Count
   \   000034 AB 01        ADD       A, #0x1
   \   000036 C7 ....      LD        L:GS1011_Xmit_Char_Count, A
   \   000039 20 CB        JRA       L:??CopyBufferGS1011_0
    217          }
   \                     ??CopyBufferGS1011_1:
   \   00003B 87           RETF
    218          /*****************************************************************************/
    219          /***** copy buffer from offset to terminator(pointer to destination, pointer to source buffer,****/
    220          /*****                                  number of bytes to copy)          ****/
    221          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    222          void copy_buffer_from_offset_to_terminator(char srcebufr[],char destbufr[], int ofst, char trm){
   \                     copy_buffer_from_offset_to_terminator:
   \   000000 8D ......    CALLF     L:?push_w4
   \   000004 BF ..        LDW       S:?w1, X
   \   000006 90BF ..      LDW       S:?w2, Y
   \   000009 90BE ..      LDW       Y, S:?w0
   \   00000C B7 ..        LD        S:?b6, A
    223          int destoffset,chkchr; 
    224          destoffset = 0;
   \   00000E 5F           CLRW      X
   \   00000F BF ..        LDW       S:?w0, X
    225          for (destoffset =0; destoffset < 512; destoffset++){
   \   000011 5F           CLRW      X
   \   000012 BF ..        LDW       S:?w0, X
   \                     ??copy_buffer_from_offset_to_terminator_0:
   \   000014 BE ..        LDW       X, S:?w0
   \   000016 A3 0200      CPW       X, #0x200
   \   000019 2E 2B        JRSGE     L:??copy_buffer_from_offset_to_terminator_1
    226            chkchr = srcebufr[ofst];
   \   00001B 93           LDW       X, Y
   \   00001C 72BB ....    ADDW      X, S:?w1
   \   000020 F6           LD        A, (X)
   \   000021 5F           CLRW      X
   \   000022 97           LD        XL, A
   \   000023 BF ..        LDW       S:?w4, X
    227          if (chkchr != trm){
   \   000025 5F           CLRW      X
   \   000026 41           EXG       A, XL
   \   000027 B6 ..        LD        A, S:?b6
   \   000029 41           EXG       A, XL
   \   00002A B3 ..        CPW       X, S:?w4
   \   00002C 27 18        JREQ      L:??copy_buffer_from_offset_to_terminator_2
    228              destbufr[destoffset] = srcebufr[ofst];
   \   00002E 93           LDW       X, Y
   \   00002F 72BB ....    ADDW      X, S:?w1
   \   000033 F6           LD        A, (X)
   \   000034 BE ..        LDW       X, S:?w0
   \   000036 72BB ....    ADDW      X, S:?w2
   \   00003A F7           LD        (X), A
    229              ofst++;
   \   00003B 93           LDW       X, Y
   \   00003C 5C           INCW      X
   \   00003D 9093         LDW       Y, X
    230            }
   \   00003F BE ..        LDW       X, S:?w0
   \   000041 5C           INCW      X
   \   000042 BF ..        LDW       S:?w0, X
   \   000044 20 CE        JRA       L:??copy_buffer_from_offset_to_terminator_0
    231          else
    232            break;
    233          }
    234           }
   \                     ??copy_buffer_from_offset_to_terminator_2:
   \                     ??copy_buffer_from_offset_to_terminator_1:
   \   000046 AC ......    JPF       L:?epilogue_w4
    235          /*****************************************************************************/
    236          /***** copy buffer count(pointer to destination, pointer to source buffer,****/
    237          /*****                                  number of bytes to copy)          ****/
    238          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    239          void CopyBufferCounted (char dest[], char srce[], char cntr){
   \                     CopyBufferCounted:
   \   000000 BF ..        LDW       S:?w2, X
   \   000002 90BF ..      LDW       S:?w1, Y
   \   000005 B7 ..        LD        S:?b1, A
    240          u8 i;
    241           
    242          for (i=0; i < cntr; i++){
   \   000007 4F           CLR       A
   \   000008 B7 ..        LD        S:?b0, A
   \                     ??CopyBufferCounted_0:
   \   00000A B6 ..        LD        A, S:?b0
   \   00000C B1 ..        CP        A, S:?b1
   \   00000E 24 1C        JRNC      L:??CopyBufferCounted_1
    243              dest[i] = srce[i];
   \   000010 5F           CLRW      X
   \   000011 41           EXG       A, XL
   \   000012 B6 ..        LD        A, S:?b0
   \   000014 41           EXG       A, XL
   \   000015 72BB ....    ADDW      X, S:?w1
   \   000019 F6           LD        A, (X)
   \   00001A 5F           CLRW      X
   \   00001B 41           EXG       A, XL
   \   00001C B6 ..        LD        A, S:?b0
   \   00001E 41           EXG       A, XL
   \   00001F 72BB ....    ADDW      X, S:?w2
   \   000023 F7           LD        (X), A
    244            }
   \   000024 B6 ..        LD        A, S:?b0
   \   000026 AB 01        ADD       A, #0x1
   \   000028 B7 ..        LD        S:?b0, A
   \   00002A 20 DE        JRA       L:??CopyBufferCounted_0
    245           }
   \                     ??CopyBufferCounted_1:
   \   00002C 87           RETF

   \                                 In section .far_func.text, align 1
    246          void CopySerialNumber(void){
    247          u8 i;
    248          u8 cntr=15; 
   \                     CopySerialNumber:
   \   000000 35 0F ....   MOV       S:?b0, #0xf
    249          for (i=0;i<=16;i++){
   \   000004 4F           CLR       A
   \   000005 B7 ..        LD        S:?b1, A
   \                     ??CopySerialNumber_0:
   \   000007 B6 ..        LD        A, S:?b1
   \   000009 A1 11        CP        A, #0x11
   \   00000B 24 11        JRNC      L:??CopySerialNumber_1
    250            Device_Serial_number[i] = 0;
   \   00000D 5F           CLRW      X
   \   00000E 41           EXG       A, XL
   \   00000F B6 ..        LD        A, S:?b1
   \   000011 41           EXG       A, XL
   \   000012 4F           CLR       A
   \   000013 D7 ....      LD        (L:Device_Serial_number,X), A
    251          }
   \   000016 B6 ..        LD        A, S:?b1
   \   000018 AB 01        ADD       A, #0x1
   \   00001A B7 ..        LD        S:?b1, A
   \   00001C 20 E9        JRA       L:??CopySerialNumber_0
    252          for (i=0; i <= cntr; i++){
   \                     ??CopySerialNumber_1:
   \   00001E 4F           CLR       A
   \   00001F B7 ..        LD        S:?b1, A
   \                     ??CopySerialNumber_2:
   \   000021 B6 ..        LD        A, S:?b0
   \   000023 B1 ..        CP        A, S:?b1
   \   000025 25 19        JRC       L:??CopySerialNumber_3
    253              Device_Serial_number[i] = Device_Processing_Buffer[i+4];
   \   000027 5F           CLRW      X
   \   000028 41           EXG       A, XL
   \   000029 B6 ..        LD        A, S:?b1
   \   00002B 41           EXG       A, XL
   \   00002C 1C ....      ADDW      X, #Device_Processing_Buffer + 4
   \   00002F F6           LD        A, (X)
   \   000030 5F           CLRW      X
   \   000031 41           EXG       A, XL
   \   000032 B6 ..        LD        A, S:?b1
   \   000034 41           EXG       A, XL
   \   000035 D7 ....      LD        (L:Device_Serial_number,X), A
    254            }
   \   000038 B6 ..        LD        A, S:?b1
   \   00003A AB 01        ADD       A, #0x1
   \   00003C B7 ..        LD        S:?b1, A
   \   00003E 20 E1        JRA       L:??CopySerialNumber_2
    255           }
   \                     ??CopySerialNumber_3:
   \   000040 87           RETF
    256          /*****************************************************************************/
    257          /***** CountChars (buffer pointer)                                         ****/
    258          /*****                  source buffer must terminate with a 0x00.         ****/
    259          /*****          Returns an integer for number of characters in the buffer ****/
    260          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    261          int CountChars(char s[]){
   \                     CountChars:
   \   000000 BF ..        LDW       S:?w0, X
    262          int cntr;
    263            for (cntr=0; cntr < BFRSIZE; cntr++){
   \   000002 905F         CLRW      Y
   \   000004 93           LDW       X, Y
   \                     ??CountChars_0:
   \   000005 A3 00FF      CPW       X, #0xff
   \   000008 2E 0F        JRSGE     L:??CountChars_1
    264              if  (s[cntr] == 0x00) break;
   \   00000A 9093         LDW       Y, X
   \   00000C 72B9 ....    ADDW      Y, S:?w0
   \   000010 907D         TNZ       (Y)
   \   000012 26 02        JRNE      L:??CountChars_2
   \   000014 20 03        JRA       L:??CountChars_1
    265            }
   \                     ??CountChars_2:
   \   000016 5C           INCW      X
   \   000017 20 EC        JRA       L:??CountChars_0
    266            return cntr;
   \                     ??CountChars_1:
   \   000019 87           RETF
    267          }
    268          /*****************************************************************************/
    269          /***** CountChars (buffer pointer)                                         ****/
    270          /*****                  source buffer must terminate with a 0x00.         ****/
    271          /*****          Returns an integer for number of characters in the buffer ****/
    272          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    273          char CountGS1011Chars(void){
    274          char i;
    275            for (i=0; i < BFRSIZE; i++){
   \                     CountGS1011Chars:
   \   000000 3F ..        CLR       S:?b0
   \   000002 B6 ..        LD        A, S:?b0
   \                     ??CountGS1011Chars_0:
   \   000004 A1 FF        CP        A, #0xff
   \   000006 27 0E        JREQ      L:??CountGS1011Chars_1
    276               if  (GS1011_Xmit_Buffer[i] == 0x00) break;
   \   000008 5F           CLRW      X
   \   000009 97           LD        XL, A
   \   00000A 724D ....    TNZ       (L:GS1011_Xmit_Buffer,X)
   \   00000E 26 02        JRNE      L:??CountGS1011Chars_2
   \   000010 20 04        JRA       L:??CountGS1011Chars_1
    277            } 
   \                     ??CountGS1011Chars_2:
   \   000012 AB 01        ADD       A, #0x1
   \   000014 20 EE        JRA       L:??CountGS1011Chars_0
    278               return i;
   \                     ??CountGS1011Chars_1:
   \   000016 87           RETF
    279          }
    280          
    281          /*****************************************************************************/
    282          /***** Find string ( buffer pointer, string)                                         ****/
    283          /*****                  source buffer must terminate with a 0x00.         ****/
    284          /*****          Returns an integer for number of characters in the buffer ****/
    285          /*****************************************************************************/

   \                                 In section .far_func.text, align 1
    286          void FindGS1011Chars(char findstrng[]){
   \                     FindGS1011Chars:
   \   000000 8D ......    CALLF     L:?push_l2
   \   000004 BF ..        LDW       S:?w3, X
    287          int lookinptr, lookforptr, restartptr, lookforcnt,i;
    288          char lookinchr,lookforchr;
    289              GS1011_String_Found = 0;      /* expect not to find it*/
   \   000006 35 00 ....   MOV       L:GS1011_String_Found, #0x0
    290              lookforptr=0x00;                  /*point at first byte of compare string*/
   \   00000A 905F         CLRW      Y
   \   00000C 90BF ..      LDW       S:?w0, Y
    291              
    292          for (i = 0; i< BFRSIZE; i++){          /* get the size of the string to find*/
   \   00000F 905F         CLRW      Y
   \   000011 90BF ..      LDW       S:?w2, Y
   \                     ??FindGS1011Chars_0:
   \   000014 90BE ..      LDW       Y, S:?w2
   \   000017 90A3 00FF    CPW       Y, #0xff
   \   00001B 2E 1B        JRSGE     L:??FindGS1011Chars_1
    293            if (findstrng[i] == 0x00){
   \   00001D 90BE ..      LDW       Y, S:?w2
   \   000020 72B9 ....    ADDW      Y, S:?w3
   \   000024 907D         TNZ       (Y)
   \   000026 26 06        JRNE      L:??FindGS1011Chars_2
    294              lookforcnt = i;
   \   000028 8D ......    CALLF     L:?mov_w4_w2
    295              break;}
   \   00002C 20 0A        JRA       L:??FindGS1011Chars_1
    296          }
   \                     ??FindGS1011Chars_2:
   \   00002E 90BE ..      LDW       Y, S:?w2
   \   000031 905C         INCW      Y
   \   000033 90BF ..      LDW       S:?w2, Y
   \   000036 20 DC        JRA       L:??FindGS1011Chars_0
    297          for (lookinptr=0; lookinptr < GS1011_Rvcr_Count; lookinptr++){
   \                     ??FindGS1011Chars_1:
   \   000038 905F         CLRW      Y
   \   00003A 93           LDW       X, Y
   \                     ??FindGS1011Chars_3:
   \   00003B C3 ....      CPW       X, L:GS1011_Rvcr_Count
   \   00003E 2F 03        JRSLT     ??lb_0
   \   000040 CC ....      JP        L:??FindGS1011Chars_4
    298              if (GS1011_String_Found == 1)                       /* if found exit*/
   \                     ??lb_0:
   \   000043 C6 ....      LD        A, L:GS1011_String_Found
   \   000046 A1 01        CP        A, #0x1
   \   000048 26 03        JRNE      L:??FindGS1011Chars_5
    299                break;
   \   00004A CC ....      JP        L:??FindGS1011Chars_4
    300              lookinchr = GS1011_Receiver_Buffer[lookinptr];
   \                     ??FindGS1011Chars_5:
   \   00004D D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   000050 B7 ..        LD        S:?b11, A
    301              lookforchr = findstrng[lookforptr];                    /*match first byte of string? */
   \   000052 90BE ..      LDW       Y, S:?w0
   \   000055 72B9 ....    ADDW      Y, S:?w3
   \   000059 90F6         LD        A, (Y)
   \   00005B B7 ..        LD        S:?b10, A
    302              if (lookinchr == lookforchr){  
   \   00005D B6 ..        LD        A, S:?b10
   \   00005F B1 ..        CP        A, S:?b11
   \   000061 26 6B        JRNE      L:??FindGS1011Chars_6
    303                restartptr = lookinptr;                   /* save next char pointer to look in buffer */
   \   000063 BF ..        LDW       S:?w1, X
    304                restartptr++;                             /* in case of double character */
   \   000065 90BE ..      LDW       Y, S:?w1
   \   000068 905C         INCW      Y
   \   00006A 90BF ..      LDW       S:?w1, Y
    305           /***                                            loop while bytes match */
    306               for (i=1; i <= lookforcnt-1; i++){
   \   00006D 90AE 0001    LDW       Y, #0x1
   \   000071 90BF ..      LDW       S:?w2, Y
   \                     ??FindGS1011Chars_7:
   \   000074 90BE ..      LDW       Y, S:?w4
   \   000077 905A         DECW      Y
   \   000079 90B3 ..      CPW       Y, S:?w2
   \   00007C 2F 50        JRSLT     L:??FindGS1011Chars_6
    307                  lookinptr++;
   \   00007E 5C           INCW      X
    308                  lookforptr++;
   \   00007F 90BE ..      LDW       Y, S:?w0
   \   000082 905C         INCW      Y
   \   000084 90BF ..      LDW       S:?w0, Y
    309                  lookinchr = GS1011_Receiver_Buffer[lookinptr];    /*keep checking till end*/
   \   000087 D6 ....      LD        A, (L:GS1011_Receiver_Buffer,X)
   \   00008A B7 ..        LD        S:?b11, A
    310                  lookforchr = findstrng[lookforptr];    
   \   00008C 90BE ..      LDW       Y, S:?w0
   \   00008F 72B9 ....    ADDW      Y, S:?w3
   \   000093 90F6         LD        A, (Y)
   \   000095 B7 ..        LD        S:?b10, A
    311                  if (lookinchr != lookforchr){
   \   000097 B6 ..        LD        A, S:?b10
   \   000099 B1 ..        CP        A, S:?b11
   \   00009B 27 09        JREQ      L:??FindGS1011Chars_8
    312                    lookforptr=0x00;                         /*no reset the string pointer*/
   \   00009D 905F         CLRW      Y
   \   00009F 90BF ..      LDW       S:?w0, Y
    313                    lookinptr = restartptr;                  /* and the lookin pointer */
   \   0000A2 BE ..        LDW       X, S:?w1
    314                    break;
   \   0000A4 20 28        JRA       L:??FindGS1011Chars_6
    315                   }
    316                  else 
    317                    if (i == lookforcnt-1){
   \                     ??FindGS1011Chars_8:
   \   0000A6 90BE ..      LDW       Y, S:?w4
   \   0000A9 905A         DECW      Y
   \   0000AB 90B3 ..      CPW       Y, S:?w2
   \   0000AE 26 14        JRNE      L:??FindGS1011Chars_9
    318                    Found_String_At_Byte = (lookinptr - (lookforcnt-1));  
   \   0000B0 9093         LDW       Y, X
   \   0000B2 72B2 ....    SUBW      Y, S:?w4
   \   0000B6 72A2 FFFF    SUBW      Y, #0xffffffffffffffff
   \   0000BA 90CF ....    LDW       L:Found_String_At_Byte, Y
    319                    GS1011_String_Found = 1;           /* save start of string in bufr */
   \   0000BE 35 01 ....   MOV       L:GS1011_String_Found, #0x1
    320                    break;
   \   0000C2 20 0A        JRA       L:??FindGS1011Chars_6
    321                    }
    322                }
   \                     ??FindGS1011Chars_9:
   \   0000C4 90BE ..      LDW       Y, S:?w2
   \   0000C7 905C         INCW      Y
   \   0000C9 90BF ..      LDW       S:?w2, Y
   \   0000CC 20 A6        JRA       L:??FindGS1011Chars_7
    323              }
    324            /***                                            loop while bytes match */
    325             
    326             }
   \                     ??FindGS1011Chars_6:
   \   0000CE 5C           INCW      X
   \   0000CF CC ....      JP        L:??FindGS1011Chars_3
    327          }
   \                     ??FindGS1011Chars_4:
   \   0000D2 AC ......    JPF       L:?epilogue_l2
    328          
    329          /*****************************************************************************/
    330          /***** CountChars (buffer pointer)                                         ****/
    331          /*****                  source buffer must terminate with a 0x00.         ****/
    332          /*****          Returns an integer for number of characters in the buffer ****/
    333          /*****************************************************************************/
    334          /*void CountDeviceChars(void){
    335          char chr;
    336            for (Device_Xmit_Char_Count=0; Device_Xmit_Char_Count < BFRSIZE; Device_Xmit_Char_Count++){
    337              chr = Device_Xmit_Pointer;
    338              if  (chr == 0x03){
    339                Device_Xmit_Char_Count++;
    340                break;
    341                }
    342                Device_Xmit_Pointer++;
    343            }
    344          }*/
    345          /*****************************************************************************/
    346          /*****              DEVICE BUFFER  HANDLING ROUTINES                      ****/
    347          /*****  While the GS1011 buffers are purely ASCII, the Device_Buffer can  ****/
    348          /*****    ANY type of data, not only in the packet data, but as counts,   ****/
    349          /*****    etc. in the header of the message.                              ****/
    350          /*****                                                                    ****/
    351          /*****    where bufr is buffer containing parameters                      ****/
    352          /*****          ptr is pointer at begining of parameter                   ****/
    353          /*****          cntr is the parameter counter                             ****/
    354          /*****************************************************************************/
    355          
    356          

   Section sizes:

   Bytes  Function/Label
   -----  --------------
      13  Add_Char_to_Buffer
      21  Add_Char_to_GS1011_Buffer
      47  Add_Integer_to_Buffer
      46  Add_String_to_Buffer
      52  Add_String_to_GS1011_Buffer
      72  Add_String_to_GS1011_BufferCounted
      59  CopyBuffer
      45  CopyBufferCounted
      59  CopyBufferDevice
      60  CopyBufferGS1011
      65  CopySerialNumber
      26  CountChars
      23  CountGS1011Chars
      42  FillBuffer
     214  FindGS1011Chars
      24  InitializeDeviceBuffer
      57  InitializeGS1011Buffer
      74  copy_buffer_from_offset_to_terminator

 
 999 bytes in section .far_func.text
 
 999 bytes of CODE memory

Errors: none
Warnings: none
